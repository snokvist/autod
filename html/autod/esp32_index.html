<!doctype html>
<meta charset="utf-8">
<title>autod — ESP32 console</title>
<link rel="stylesheet" href="./assets/console-theme.css">
<link rel="stylesheet" href="./assets/vrx/vrx.css">
<style>
  main { padding: 1.5rem; display: flex; flex-direction: column; gap: 1.5rem; }
  header { padding: 1.5rem; display: flex; justify-content: space-between; align-items: center; }
  .node-controls { gap: 1rem; }
  .node-relay { border-top: 1px solid rgba(255,255,255,0.08); padding-top: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; }
  .node-relay textarea { width: 100%; min-height: 120px; }
  .node-relay .row { gap: 0.5rem; flex-wrap: wrap; }
  .node-relay input[type="text"],
  .node-relay input[type="number"],
  .node-relay select { min-width: 120px; }
  .sync-grid { grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); }
  .sync-slot-actions { display: flex; gap: 0.5rem; align-items: center; }
  textarea { font-family: "SFMono-Regular", Consolas, "Liberation Mono", monospace; }
</style>

<header>
  <div>
    <div class="title">autod — ESP32 console</div>
    <div class="sub" id="subtitle">nodes + sync overview</div>
  </div>
  <div class="row" style="justify-content:flex-end; gap:0.5rem; flex-wrap:wrap;">
    <button id="refreshNodesBtn">Refresh /nodes</button>
    <button id="refreshSyncBtn">Refresh /sync/slaves</button>
  </div>
</header>

<main>
  <section class="card" id="capsCard">
    <h2>Device & runtime</h2>
    <div class="body grid">
      <div class="row" style="gap:0.75rem; flex-wrap:wrap;">
        <button id="capsRefreshBtn">Refresh /caps</button>
        <div class="spacer"></div>
        <div class="mut" id="capsStatus">waiting…</div>
      </div>
      <div class="kv"><div class="mut">Device</div><div id="dev_device">—</div></div>
      <div class="kv"><div class="mut">Role</div><div id="dev_role">—</div></div>
      <div class="kv"><div class="mut">Version</div><div id="dev_version">—</div></div>
      <div class="kv"><div class="mut">Interfaces</div><div id="dev_if">—</div></div>
      <div class="kv"><div class="mut">Uptime</div><div id="dev_uptime">—</div></div>
      <div class="kv"><div class="mut">Loadavg</div><div id="dev_load">—</div></div>
      <div class="kv"><div class="mut">Capabilities</div><div class="caps" id="dev_caps">—</div></div>
      <div class="kv"><div class="mut">SSE</div><div class="sse" id="dev_sse">—</div></div>
      <div class="row" id="deviceRuntimeActions" style="display:none">
        <button id="pixelpilotMiniRkRebootBtn">Reboot device</button>
        <button id="pixelpilotMiniRkShutdownBtn">Shutdown device</button>
      </div>
    </div>
  </section>

  <section class="card" id="pixelpilotMiniRkCard" style="display:none">
    <h2>Pixelpilot Mini RK</h2>
    <div class="body grid">
      <div class="cap-toolbar">
        <div class="row" id="pixelpilotMiniRkActions">
          <button id="pixelpilotMiniRkToggleOsdBtn">Toggle OSD</button>
          <button id="pixelpilotMiniRkToggleRecordingBtn">Toggle Recording</button>
          <button id="pixelpilotMiniRkRestartServiceBtn">Restart pixelpilot_mini_rk</button>
          <button id="pixelpilotMiniRkStopServiceBtn">Stop pixelpilot_mini_rk</button>
          <button id="pixelpilotMiniRkStartServiceBtn">Start pixelpilot_mini_rk</button>
        </div>
        <div class="row mini-rk-gamma-row">
          <label for="pixelpilotMiniRkGammaSelect">Gamma preset</label>
          <select id="pixelpilotMiniRkGammaSelect" disabled>
            <option>Loading presets…</option>
          </select>
          <button id="pixelpilotMiniRkApplyGammaBtn" type="button" disabled>Apply preset</button>
          <button id="pixelpilotMiniRkReloadGammaBtn" type="button">Reload presets</button>
          <div class="mut" id="pixelpilotMiniRkGammaNotice">Loading presets…</div>
        </div>
        <div class="spacer"></div>
        <div class="mini-status">
          <div class="status-indicator" id="pixelpilotMiniRkStatus" aria-live="polite">Idle</div>
        </div>
      </div>
    </div>
  </section>

  <section class="card" id="dvrCard" style="display:none">
    <h2>DVR recordings</h2>
    <div class="body grid dvr-body">
      <div class="row">
        <button id="dvrRefreshBtn">Refresh list</button>
        <button id="dvrDeleteAllBtn">Delete all</button>
        <div class="spacer"></div>
        <div class="mut" id="dvrStatus">—</div>
      </div>
      <div class="dvr-scroll">
        <div id="dvrMessage" class="dvr-message" style="display:none"></div>
        <div id="dvrEmptyState" class="dvr-empty" style="display:none">No recordings found.</div>
        <div id="dvrList" class="dvr-list"></div>
      </div>
    </div>
  </section>

  <section class="card" id="execCard">
    <h2>/exec — local runner</h2>
    <div class="body">
      <div class="row" style="gap:0.75rem; flex-wrap:wrap;">
        <label>path <input id="exec_path" value="/sys/help"></label>
        <label>args (space-separated) <input id="exec_args" placeholder=''></label>
        <button id="exec_btn">POST /exec</button>
      </div>
      <div class="mut">Body preview:</div>
      <pre class="inline" id="exec_body_preview">{}</pre>
      <div class="mut">Response:</div>
      <textarea id="exec_out" readonly></textarea>
    </div>
  </section>

  <section class="card" id="nodesCard">
    <h2>Nodes</h2>
    <div class="body grid">
      <div class="nodes-toolbar">
        <button id="nodesScanBtn">POST /nodes (scan)</button>
        <div class="spacer"></div>
        <div class="nodes-stats" id="nodesStats">—</div>
      </div>
      <div class="progress" aria-label="Scan progress"><div id="nodesProgress"></div></div>
      <div id="nodesNotice" class="mut">—</div>
      <div class="nodes-grid" id="nodesGrid"></div>
    </div>
  </section>

  <section class="card" id="syncCard">
    <h2>Sync slots</h2>
    <div class="body grid">
      <div class="row" style="gap:0.75rem; flex-wrap:wrap;">
        <button id="syncRefreshBtn">Refresh status</button>
        <div class="spacer"></div>
        <div class="mut" id="syncStatus">waiting…</div>
      </div>
      <div class="sync-grid" id="syncGrid"></div>
      <div>
        <div class="mut">Waiting / unassigned slaves</div>
        <div id="syncWaiting" class="sync-waiting">—</div>
      </div>
    </div>
  </section>
</main>

<script type="module">
const $ = (sel, root = document) => root.querySelector(sel);
const nodesState = { expanded: new Set(), pollTimer: null, loading: false };
const MAX_SYNC_SLOTS = 3;
const DEFAULT_CMD_TIMEOUT_MS = 6000;
const capsState = { capList: new Set(), hasExec: false };
const dvrState = { initialized: false, hasExec: false, loading: false };
const miniRkState = { initialized: false, gamma: { presets: [], loading: false } };

function parseArgs(text){
  const out = [];
  const re = /"([^\"]*)"|'([^']*)'|(\S+)/g;
  (text || '').replace(re, (_, dq, sq, bare) => {
    out.push((dq ?? sq ?? bare) + '');
    return '';
  });
  return out;
}

function secsToHhMmSs(value){
  const sec = Number(value);
  if (!Number.isFinite(sec) || sec < 0) return '—';
  const hours = Math.floor(sec / 3600);
  const minutes = Math.floor((sec % 3600) / 60);
  const seconds = Math.floor(sec % 60);
  const pad = num => String(num).padStart(2, '0');
  return `${hours}:${pad(minutes)}:${pad(seconds)}`;
}

function formatInterfaces(list){
  if (!Array.isArray(list) || !list.length) return '—';
  return list.map(entry => `${entry.if || entry.name || 'if'}:${entry.ip || entry.addr || '—'}`).join('  ');
}

function formatLoadavg(list){
  if (!Array.isArray(list) || !list.length) return '—';
  return list.join(' ');
}

function renderCapsList(list){
  const el = document.getElementById('dev_caps');
  if (!el) return;
  el.innerHTML = '';
  if (!Array.isArray(list) || !list.length){
    el.textContent = '—';
    return;
  }
  list.forEach(cap => {
    const pill = document.createElement('span');
    pill.className = 'pill';
    pill.textContent = cap;
    el.appendChild(pill);
  });
}

function renderSseList(entries){
  const el = document.getElementById('dev_sse');
  if (!el) return;
  el.innerHTML = '';
  if (!Array.isArray(entries) || !entries.length){
    el.textContent = '—';
    return;
  }
  const frag = document.createDocumentFragment();
  entries.forEach(item => {
    if (!item || !item.url) return;
    const link = document.createElement('a');
    link.href = item.url;
    link.target = '_blank';
    link.rel = 'noreferrer';
    link.textContent = item.name || item.url;
    frag.appendChild(link);
    frag.appendChild(document.createTextNode(' '));
  });
  el.appendChild(frag);
}

function formatBytes(bytes){
  const value = Number(bytes);
  if (!Number.isFinite(value) || value < 0) return '—';
  if (value >= 1024 * 1024) return `${(value / (1024 * 1024)).toFixed(1)} MB`;
  if (value >= 1024) return `${(value / 1024).toFixed(1)} KB`;
  return `${value} B`;
}

function formatLocalDate(ts){
  const value = Number(ts);
  if (!Number.isFinite(value) || value <= 0) return '—';
  return new Date(value * 1000).toLocaleString();
}

function formatAgoFromSeconds(ts){
  if (!ts) return '—';
  const sec = Number(ts);
  if (!Number.isFinite(sec)) return '—';
  const now = Math.floor(Date.now() / 1000);
  const delta = Math.max(0, now - sec);
  if (delta < 60) return `${delta}s ago`;
  if (delta < 3600) return `${Math.floor(delta / 60)}m ago`;
  if (delta < 86400) return `${Math.floor(delta / 3600)}h ago`;
  return `${Math.floor(delta / 86400)}d ago`;
}

function formatAgoMs(ms, refMs){
  const value = Number(ms);
  const ref = Number(refMs);
  if (!Number.isFinite(value)) return '—';
  let delta = Number.isFinite(ref) ? Math.max(0, ref - value) : 0;
  if (!Number.isFinite(ref)) delta = Math.max(0, Date.now() - value);
  const sec = Math.round(delta / 1000);
  if (sec < 60) return `${sec}s ago`;
  const min = Math.round(sec / 60);
  if (min < 60) return `${min}m ago`;
  const hr = Math.round(min / 60);
  if (hr < 48) return `${hr}h ago`;
  return `${Math.round(hr / 24)}d ago`;
}

function decodeBase64ToUtf8(b64){
  if (!b64) return '';
  try {
    const bin = atob(b64);
    const bytes = Uint8Array.from(bin, ch => ch.charCodeAt(0));
    const dec = new TextDecoder('utf-8', { fatal: false });
    return dec.decode(bytes);
  } catch (err) {
    console.warn('Failed to decode relay body', err);
    try { return atob(b64); } catch { return ''; }
  }
}

async function postExec(payload, timeoutMs = DEFAULT_CMD_TIMEOUT_MS){
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch('/exec', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
      signal: controller.signal
    });
    const data = await res.json().catch(() => null);
    if (!res.ok){
      const message = data?.error || data?.stderr || data?.stdout || `HTTP ${res.status}`;
      throw new Error(message);
    }
    return data || {};
  } finally {
    clearTimeout(timer);
  }
}

function setCapsStatus(text){
  const statusEl = document.getElementById('capsStatus');
  if (statusEl) statusEl.textContent = text;
}

function applyCapabilityToggles(capList){
  const list = Array.isArray(capList) ? capList : [];
  capsState.capList = new Set(list);
  capsState.hasExec = capsState.capList.has('exec');
  const hasMiniRk = capsState.capList.has('pixelpilot_mini_rk');
  const hasDvr = capsState.capList.has('dvr');

  const deviceActionsRow = document.getElementById('deviceRuntimeActions');
  if (deviceActionsRow) deviceActionsRow.style.display = hasMiniRk ? '' : 'none';

  const pixelpilotCard = document.getElementById('pixelpilotMiniRkCard');
  if (pixelpilotCard){
    pixelpilotCard.style.display = hasMiniRk ? '' : 'none';
    if (hasMiniRk){
      ensureMiniRkCard();
      setMiniRkStatusIdle('Idle');
    } else {
      setMiniRkStatusIdle('cap missing');
    }
  }

  ensureDvrHandlers();
  dvrState.hasExec = capsState.hasExec;
  updateDvrControls();
  const dvrCard = document.getElementById('dvrCard');
  if (dvrCard){
    dvrCard.style.display = hasDvr ? '' : 'none';
    if (hasDvr){
      refreshDvrList();
    } else {
      clearDvrCard();
    }
  }
}

function renderCaps(caps){
  document.getElementById('dev_device').textContent = caps?.device || '—';
  document.getElementById('dev_role').textContent = caps?.role || '—';
  document.getElementById('dev_version').textContent = caps?.version || '—';
  document.getElementById('dev_if').textContent = formatInterfaces(caps?.ifaddrs);
  document.getElementById('dev_uptime').textContent = secsToHhMmSs(caps?.uptime_s);
  document.getElementById('dev_load').textContent = formatLoadavg(caps?.loadavg);
  renderCapsList(caps?.caps);
  renderSseList(caps?.sse);
  const subtitle = document.getElementById('subtitle');
  if (subtitle){
    const label = [caps?.device || 'device', caps?.version ? `v${caps.version}` : ''].filter(Boolean).join(' ');
    subtitle.textContent = label || 'Device summary';
  }
  setCapsStatus(`Updated ${new Date().toLocaleTimeString()}`);
  applyCapabilityToggles(Array.isArray(caps?.caps) ? caps.caps : []);
}

async function fetchCaps(){
  setCapsStatus('Loading /caps…');
  try {
    const res = await fetch('/caps', { cache: 'no-store' });
    if (!res.ok){
      const txt = await res.text().catch(() => '');
      throw new Error(`${res.status} ${txt.trim()}`);
    }
    const data = await res.json();
    renderCaps(data);
  } catch (err) {
    setCapsStatus(`Failed (${err.message})`);
  }
}

function ensureDvrHandlers(){
  if (dvrState.initialized) return;
  const refreshBtn = document.getElementById('dvrRefreshBtn');
  const deleteBtn = document.getElementById('dvrDeleteAllBtn');
  if (refreshBtn) refreshBtn.addEventListener('click', () => { void refreshDvrList(); });
  if (deleteBtn) deleteBtn.addEventListener('click', () => { void deleteAllDvrRecordings(); });
  dvrState.initialized = true;
}

function updateDvrControls(){
  const deleteBtn = document.getElementById('dvrDeleteAllBtn');
  if (deleteBtn){
    deleteBtn.disabled = !dvrState.hasExec;
    deleteBtn.title = dvrState.hasExec ? '' : 'Requires exec capability';
  }
}

function showDvrMessage(text, type){
  const msgEl = document.getElementById('dvrMessage');
  if (!msgEl) return;
  msgEl.classList.remove('ok', 'err');
  if (!text){
    msgEl.style.display = 'none';
    msgEl.textContent = '';
    return;
  }
  msgEl.textContent = text;
  if (type) msgEl.classList.add(type);
  msgEl.style.display = 'block';
}

function clearDvrCard(){
  const listEl = document.getElementById('dvrList');
  const emptyEl = document.getElementById('dvrEmptyState');
  const statusEl = document.getElementById('dvrStatus');
  showDvrMessage('', '');
  if (listEl) listEl.innerHTML = '';
  if (emptyEl) emptyEl.style.display = 'none';
  if (statusEl) statusEl.textContent = 'cap missing';
}

function renderDvrEntries(entries){
  const listEl = document.getElementById('dvrList');
  const emptyEl = document.getElementById('dvrEmptyState');
  if (!listEl || !emptyEl) return;
  listEl.innerHTML = '';
  if (!Array.isArray(entries) || !entries.length){
    emptyEl.style.display = 'block';
    return;
  }
  emptyEl.style.display = 'none';
  const frag = document.createDocumentFragment();
  entries.forEach(entry => {
    if (!entry || typeof entry.name !== 'string') return;
    const item = document.createElement('div');
    item.className = 'dvr-item';
    const link = document.createElement('a');
    link.href = `/media/${encodeURIComponent(entry.name)}`;
    link.textContent = entry.name;
    link.download = entry.name;
    item.appendChild(link);
    const meta = document.createElement('div');
    meta.className = 'dvr-meta';
    const sizeText = formatBytes(entry.sizeBytes);
    const timeText = formatLocalDate(entry.mtimeSec);
    meta.textContent = (sizeText === '—' && timeText === '—') ? '—' : `${sizeText} • ${timeText}`;
    item.appendChild(meta);
    frag.appendChild(item);
  });
  listEl.appendChild(frag);
}

function parseDvrListFromHtml(html){
  if (typeof DOMParser !== 'function') return [];
  try {
    const doc = new DOMParser().parseFromString(html, 'text/html');
    return Array.from(doc.querySelectorAll('a')).map(a => a.getAttribute('href') || '')
      .map(raw => raw.split('#')[0].split('?')[0].replace(/^\/+|\/+$/g, ''))
      .filter(Boolean)
      .filter(name => name !== '..' && name.toLowerCase().endsWith('.mp4'));
  } catch {
    return [];
  }
}

async function refreshDvrList(){
  const card = document.getElementById('dvrCard');
  if (!card || card.style.display === 'none') return;
  if (dvrState.loading) return;
  const statusEl = document.getElementById('dvrStatus');
  const listEl = document.getElementById('dvrList');
  const emptyEl = document.getElementById('dvrEmptyState');
  if (!statusEl || !listEl || !emptyEl) return;
  dvrState.loading = true;
  statusEl.textContent = 'Loading…';
  listEl.innerHTML = '';
  emptyEl.style.display = 'none';
  showDvrMessage('', '');
  try {
    let entries = [];
    if (dvrState.hasExec){
      const res = await postExec({ path: '/sys/dvr/list', args: [] });
      const ok = typeof res?.rc === 'number' ? res.rc === 0 : true;
      const stdout = String(res?.stdout ?? '');
      if (!ok){
        const errMsg = (res?.stderr || stdout || 'failed to list recordings').trim();
        throw new Error(errMsg || 'failed to list recordings');
      }
      entries = stdout.split(/\r?\n/).map(line => {
        const trimmed = line.trim();
        if (!trimmed) return null;
        const parts = trimmed.split('\t');
        const name = parts[0]?.trim();
        if (!name) return null;
        const size = parts.length > 1 ? Number(parts[1]) : NaN;
        const mtime = parts.length > 2 ? Number(parts[2]) : NaN;
        return {
          name,
          sizeBytes: Number.isFinite(size) && size >= 0 ? size : null,
          mtimeSec: Number.isFinite(mtime) && mtime > 0 ? Math.floor(mtime) : null
        };
      }).filter(Boolean);
    } else {
      const resp = await fetch('/media/', { cache: 'no-store' });
      if (!resp.ok){
        throw new Error(`/media/ responded with ${resp.status}`);
      }
      const html = await resp.text();
      const names = parseDvrListFromHtml(html);
      entries = names.map(name => ({ name }));
    }
    entries.sort((a, b) => {
      const aTs = Number.isFinite(a?.mtimeSec) ? a.mtimeSec : 0;
      const bTs = Number.isFinite(b?.mtimeSec) ? b.mtimeSec : 0;
      if (bTs !== aTs) return bTs - aTs;
      return (a?.name || '').localeCompare(b?.name || '', 'en', { numeric: true, sensitivity: 'base' });
    });
    renderDvrEntries(entries);
    statusEl.textContent = `${entries.length} recording${entries.length === 1 ? '' : 's'} • ${new Date().toLocaleTimeString()}`;
  } catch (err) {
    statusEl.textContent = 'Failed';
    showDvrMessage(err.message || 'failed to load recordings', 'err');
  } finally {
    dvrState.loading = false;
  }
}

async function deleteAllDvrRecordings(){
  if (!dvrState.hasExec) return;
  if (!confirm('Delete all DVR recordings?')) return;
  const deleteBtn = document.getElementById('dvrDeleteAllBtn');
  const statusEl = document.getElementById('dvrStatus');
  if (deleteBtn) deleteBtn.disabled = true;
  showDvrMessage('', '');
  if (statusEl) statusEl.textContent = 'Deleting…';
  try {
    const res = await postExec({ path: '/sys/dvr/delete_all', args: [] });
    const ok = typeof res?.rc === 'number' ? res.rc === 0 : true;
    const detail = (res?.stderr || res?.stdout || (ok ? 'Deleted recordings' : 'Delete failed')).trim();
    showDvrMessage(detail || (ok ? 'Deleted recordings' : 'Delete failed'), ok ? 'ok' : 'err');
  } catch (err) {
    showDvrMessage(err.message || 'Delete failed', 'err');
  } finally {
    if (deleteBtn) deleteBtn.disabled = !dvrState.hasExec;
    await refreshDvrList();
  }
}

function miniRkStatusEl(){
  return document.getElementById('pixelpilotMiniRkStatus');
}

function setMiniRkStatusIdle(text = 'Idle'){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('running', 'ok', 'err', 'flash');
  el.textContent = text;
  el.title = '';
}

function setMiniRkStatusRunning(){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('ok', 'err', 'flash');
  el.classList.add('running');
  el.textContent = 'Running…';
  el.title = '';
}

function setMiniRkStatusResult(ok, detail = ''){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('running', 'ok', 'err', 'flash');
  el.classList.add(ok ? 'ok' : 'err');
  el.textContent = `${ok ? 'Success' : 'Error'} • ${new Date().toLocaleTimeString()}`;
  el.title = detail || '';
  void el.offsetWidth;
  el.classList.add('flash');
}

async function runMiniRkCommand(command, btnEl){
  const payload = typeof command === 'string'
    ? { path: command, args: [] }
    : {
        path: command?.path || '',
        args: Array.isArray(command?.args) ? command.args : []
      };
  if (!payload.path){
    setMiniRkStatusResult(false, 'invalid command');
    return;
  }
  setMiniRkStatusRunning();
  if (btnEl) btnEl.disabled = true;
  try {
    const res = await postExec(payload);
    const ok = typeof res?.rc === 'number' ? res.rc === 0 : true;
    const stdout = (res?.stdout || '').trim();
    const stderr = (res?.stderr || '').trim();
    const detail = ok ? (stdout.split('\n')[0] || '') : (stderr || stdout || 'command failed');
    setMiniRkStatusResult(ok, detail);
  } catch (err) {
    setMiniRkStatusResult(false, err.message || 'command failed');
  } finally {
    if (btnEl) btnEl.disabled = false;
  }
}

function parseMiniRkGammaPresets(stdout){
  const out = [];
  const seen = new Set();
  String(stdout || '').split(/\r?\n/).forEach(rawLine => {
    const line = rawLine.trim();
    if (!line || /^available presets/i.test(line) || seen.has(line)) return;
    seen.add(line);
    out.push(line);
  });
  return out;
}

function renderMiniRkGammaPresets(presets){
  const select = document.getElementById('pixelpilotMiniRkGammaSelect');
  const applyBtn = document.getElementById('pixelpilotMiniRkApplyGammaBtn');
  if (!select || !applyBtn) return;
  select.innerHTML = '';
  const items = Array.isArray(presets) ? presets : [];
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.disabled = true;
  placeholder.selected = true;
  placeholder.textContent = items.length ? 'Select preset…' : 'No presets available';
  select.appendChild(placeholder);
  items.forEach(preset => {
    const option = document.createElement('option');
    option.value = preset;
    option.textContent = preset;
    select.appendChild(option);
  });
  select.disabled = items.length === 0;
  applyBtn.disabled = true;
}

async function loadMiniRkGammaPresets(){
  const select = document.getElementById('pixelpilotMiniRkGammaSelect');
  const applyBtn = document.getElementById('pixelpilotMiniRkApplyGammaBtn');
  const reloadBtn = document.getElementById('pixelpilotMiniRkReloadGammaBtn');
  const noticeEl = document.getElementById('pixelpilotMiniRkGammaNotice');
  if (!select || !applyBtn) return;
  if (miniRkState.gamma.loading) return;
  miniRkState.gamma.loading = true;
  select.disabled = true;
  applyBtn.disabled = true;
  if (reloadBtn) reloadBtn.disabled = true;
  if (noticeEl) noticeEl.textContent = 'Loading presets…';
  try {
    const res = await postExec({ path: '/sys/pixelpilot_mini_rk/gamma', args: ['--list'] });
    const presets = parseMiniRkGammaPresets(res?.stdout || '');
    miniRkState.gamma.presets = presets;
    renderMiniRkGammaPresets(presets);
    if (noticeEl){
      noticeEl.textContent = presets.length ? `Loaded ${presets.length} preset${presets.length === 1 ? '' : 's'}` : 'No presets reported';
    }
  } catch (err) {
    miniRkState.gamma.presets = [];
    renderMiniRkGammaPresets([]);
    if (noticeEl) noticeEl.textContent = err.message || 'Failed to load presets';
  } finally {
    if (reloadBtn) reloadBtn.disabled = false;
    miniRkState.gamma.loading = false;
  }
}

function initMiniRkGammaControls(){
  const select = document.getElementById('pixelpilotMiniRkGammaSelect');
  const applyBtn = document.getElementById('pixelpilotMiniRkApplyGammaBtn');
  const reloadBtn = document.getElementById('pixelpilotMiniRkReloadGammaBtn');
  if (!select || !applyBtn) return;
  select.addEventListener('change', () => {
    applyBtn.disabled = !select.value;
  });
  applyBtn.addEventListener('click', () => {
    const preset = select.value.trim();
    if (!preset) return;
    runMiniRkCommand({ path: '/sys/pixelpilot_mini_rk/gamma', args: [preset] }, applyBtn);
  });
  if (reloadBtn){
    reloadBtn.addEventListener('click', () => { void loadMiniRkGammaPresets(); });
  }
  void loadMiniRkGammaPresets();
}

function ensureMiniRkCard(){
  if (miniRkState.initialized) return;
  setMiniRkStatusIdle('Idle');
  const mapping = [
    { selector: '#pixelpilotMiniRkToggleOsdBtn', command: { path: '/sys/pixelpilot_mini_rk/toggle_osd' } },
    { selector: '#pixelpilotMiniRkToggleRecordingBtn', command: { path: '/sys/pixelpilot_mini_rk/toggle_recording' } },
    { selector: '#pixelpilotMiniRkRestartServiceBtn', command: { path: '/sys/pixelpilot_mini_rk/restart' } },
    { selector: '#pixelpilotMiniRkStopServiceBtn', command: { path: '/sys/pixelpilot_mini_rk/stop' } },
    { selector: '#pixelpilotMiniRkStartServiceBtn', command: { path: '/sys/pixelpilot_mini_rk/start' } },
    { selector: '#pixelpilotMiniRkRebootBtn', command: { path: '/sys/reboot' } },
    { selector: '#pixelpilotMiniRkShutdownBtn', command: { path: '/sys/shutdown' } }
  ];
  mapping.forEach(entry => {
    const btn = document.querySelector(entry.selector);
    if (btn) btn.addEventListener('click', () => { void runMiniRkCommand(entry.command, btn); });
  });
  initMiniRkGammaControls();
  miniRkState.initialized = true;
}

function setupExecCard(){
  const btn = $('#exec_btn');
  const pathInput = $('#exec_path');
  const argsInput = $('#exec_args');
  const previewEl = $('#exec_body_preview');
  const outEl = $('#exec_out');
  if (!btn || !pathInput || !argsInput || !previewEl || !outEl) return;
  btn.addEventListener('click', async () => {
    const path = pathInput.value.trim();
    const args = parseArgs(argsInput.value || '');
    const body = { path, args };
    previewEl.textContent = JSON.stringify(body);
    try {
      const res = await fetch('/exec', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });
      const txt = await res.text();
      outEl.value = txt.replace(/\n/g, '\\n');
    } catch (err) {
      outEl.value = JSON.stringify({ error: 'request_failed', message: err.message });
    }
  });
}

function nodeKey(node, idx){
  const ip = (node?.ip || node?.host || '').trim();
  const port = node?.port;
  if (ip && (port || port === 0)) return `${ip}:${port}`;
  if (ip) return ip;
  return `node-${idx}`;
}

function setNodesNotice(text){
  const notice = $('#nodesNotice');
  if (notice) notice.textContent = text;
}

async function sendRelayRequest(node, elements){
  const { methodEl, pathEl, bodyEl, timeoutEl, outputEl, buttonEl } = elements;
  if (!node || !methodEl || !pathEl || !outputEl || !buttonEl) return;
  const method = (methodEl.value || 'GET').toUpperCase();
  const path = pathEl.value.trim() || '/';
  const timeout = Math.max(0, parseInt(timeoutEl?.value || '4000', 10) || 4000);
  const bodyText = bodyEl?.value.trim();
  const payload = {
    node_ip: node.ip || node.host,
    method,
    path,
    timeout_ms: timeout
  };
  if (bodyText && method !== 'GET' && method !== 'HEAD'){
    payload.body = bodyText;
    payload.headers = { 'Content-Type': 'application/json' };
  }
  buttonEl.disabled = true;
  outputEl.value = 'Sending via /http…';
  try {
    const res = await fetch('/http', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const data = await res.json().catch(() => null);
    if (!res.ok){
      outputEl.value = data && data.error ? `error: ${data.error}` : `HTTP ${res.status}`;
      return;
    }
    if (!data || data.error){
      outputEl.value = data && data.error ? `error: ${data.error}` : 'relay_failed';
      return;
    }
    const bodyStr = decodeBase64ToUtf8(data.body_base64);
    const headerLines = Array.isArray(data.headers)
      ? data.headers.map(h => `${h.name}: ${h.value}`).join('\n')
      : '';
    const summary = [
      `status ${data.status_code ?? '?'} ${data.reason || ''}`.trim(),
      `target ${data.target_ip || '?'}:${data.target_port || ''}`.trim(),
      data.sync_id ? `sync id ${data.sync_id}` : '',
      headerLines ? '\n-- headers --\n' + headerLines : '',
      '\n-- body --',
      bodyStr
    ].filter(Boolean).join('\n');
    outputEl.value = summary;
  } catch (err) {
    outputEl.value = `relay_error: ${err.message}`;
  } finally {
    buttonEl.disabled = false;
  }
}

function buildNodeCard(node, idx){
  const key = nodeKey(node, idx);
  const expanded = nodesState.expanded.has(key);
  const nodeDiv = document.createElement('div');
  nodeDiv.className = 'node' + (expanded ? ' expanded' : '');

  const head = document.createElement('div');
  head.className = 'node-head';
  head.tabIndex = 0;
  head.setAttribute('role', 'button');
  head.setAttribute('aria-expanded', expanded ? 'true' : 'false');

  const top = document.createElement('div');
  top.className = 'top';
  const roleSpan = document.createElement('span');
  roleSpan.className = 'pill role';
  roleSpan.textContent = node.role || '—';
  const ipSpan = document.createElement('span');
  ipSpan.className = 'ip';
  ipSpan.textContent = `${node.ip || '—'}:${node.port ?? ''}`;
  top.append(roleSpan, ipSpan);

  const deviceLine = document.createElement('div');
  const strong = document.createElement('strong');
  strong.textContent = node.device || '—';
  const meta = document.createElement('span');
  meta.className = 'meta';
  meta.textContent = node.version ? `v${node.version}` : '';
  deviceLine.append(strong, document.createTextNode(' '), meta);

  const lastSeen = document.createElement('div');
  lastSeen.className = 'meta';
  lastSeen.textContent = `last seen ${formatAgoFromSeconds(node.last_seen)}`;

  head.append(top, deviceLine, lastSeen);
  nodeDiv.append(head);

  const controls = document.createElement('div');
  controls.className = 'node-controls';
  controls.style.display = expanded ? 'grid' : 'none';

  const relay = document.createElement('div');
  relay.className = 'node-relay';
  const intro = document.createElement('div');
  intro.className = 'mut';
  intro.textContent = 'Relay requests via /http to reach /caps, /exec, or other endpoints on this node.';
  relay.append(intro);

  const pathRow = document.createElement('div');
  pathRow.className = 'row';
  const methodLabel = document.createElement('label');
  methodLabel.textContent = 'method ';
  const methodSelect = document.createElement('select');
  methodSelect.innerHTML = '<option>GET</option><option>POST</option><option>PUT</option><option>DELETE</option>';
  methodLabel.append(methodSelect);
  const pathLabel = document.createElement('label');
  pathLabel.textContent = 'path ';
  const pathInput = document.createElement('input');
  pathInput.type = 'text';
  pathInput.value = '/caps';
  pathLabel.append(pathInput);
  const timeoutLabel = document.createElement('label');
  timeoutLabel.textContent = 'timeout (ms) ';
  const timeoutInput = document.createElement('input');
  timeoutInput.type = 'number';
  timeoutInput.min = '100';
  timeoutInput.value = '4000';
  timeoutLabel.append(timeoutInput);
  pathRow.append(methodLabel, pathLabel, timeoutLabel);
  relay.append(pathRow);

  const bodyArea = document.createElement('textarea');
  bodyArea.placeholder = 'Optional JSON body (defaults to /caps)';
  relay.append(bodyArea);

  const actionRow = document.createElement('div');
  actionRow.className = 'row';
  const capsBtn = document.createElement('button');
  capsBtn.type = 'button';
  capsBtn.textContent = 'Load /caps';
  capsBtn.addEventListener('click', ev => {
    ev.stopPropagation();
    methodSelect.value = 'GET';
    pathInput.value = '/caps';
    bodyArea.value = '';
  });
  const execBtn = document.createElement('button');
  execBtn.type = 'button';
  execBtn.textContent = 'POST /exec';
  execBtn.addEventListener('click', ev => {
    ev.stopPropagation();
    methodSelect.value = 'POST';
    pathInput.value = '/exec';
    bodyArea.value = JSON.stringify({ path: '/sys/help', args: [] }, null, 2);
  });
  const spacer = document.createElement('div');
  spacer.className = 'spacer';
  const sendBtn = document.createElement('button');
  sendBtn.type = 'button';
  sendBtn.textContent = 'Send via /http';
  sendBtn.addEventListener('click', ev => {
    ev.stopPropagation();
    void sendRelayRequest(node, {
      methodEl: methodSelect,
      pathEl: pathInput,
      bodyEl: bodyArea,
      timeoutEl: timeoutInput,
      outputEl: relayOutput,
      buttonEl: sendBtn
    });
  });
  actionRow.append(capsBtn, execBtn, spacer, sendBtn);
  relay.append(actionRow);

  const relayOutput = document.createElement('textarea');
  relayOutput.readOnly = true;
  relayOutput.placeholder = 'Relay response will appear here';
  relay.append(relayOutput);

  controls.append(relay);
  nodeDiv.append(controls);

  const toggle = () => {
    const isOpen = nodesState.expanded.has(key);
    if (isOpen){
      nodesState.expanded.delete(key);
      controls.style.display = 'none';
      nodeDiv.classList.remove('expanded');
      head.setAttribute('aria-expanded', 'false');
    } else {
      nodesState.expanded.add(key);
      controls.style.display = 'grid';
      nodeDiv.classList.add('expanded');
      head.setAttribute('aria-expanded', 'true');
    }
  };

  head.addEventListener('click', toggle);
  head.addEventListener('keydown', ev => {
    if (ev.key === 'Enter' || ev.key === ' '){
      ev.preventDefault();
      toggle();
    }
  });

  return nodeDiv;
}

function renderNodes(data){
  const statsEl = $('#nodesStats');
  const progressEl = $('#nodesProgress');
  const nodes = Array.isArray(data?.nodes) ? data.nodes : [];
  const pct = typeof data?.progress_pct === 'number'
    ? Math.max(0, Math.min(100, Math.round(data.progress_pct)))
    : (data?.targets ? Math.round((data.done || 0) / (data.targets || 1) * 100) : 0);
  if (statsEl){
    statsEl.textContent = `feature:${data?.scan_feature_enabled ? 'on' : 'off'} • scanning:${data?.scanning ? 'yes' : 'no'} • targets:${data?.targets ?? 0} • done:${data?.done ?? 0}`;
  }
  if (progressEl){
    progressEl.style.width = `${pct}%`;
  }
  setNodesNotice(nodes.length ? `${nodes.length} node(s) found` : (data?.scanning ? 'Scanning…' : 'No nodes found'));
  $('#nodesScanBtn').disabled = !data?.scan_feature_enabled || !!data?.scanning;
  const grid = $('#nodesGrid');
  if (grid){
    grid.innerHTML = '';
    const frag = document.createDocumentFragment();
    nodes.forEach((node, idx) => frag.append(buildNodeCard(node, idx)));
    grid.append(frag);
  }
}

async function fetchNodes(){
  if (nodesState.loading) return;
  nodesState.loading = true;
  try {
    const res = await fetch('/nodes', { cache: 'no-store' });
    if (!res.ok){
      const detail = await res.text().catch(() => '');
      setNodesNotice(`Failed to load /nodes (${res.status} ${detail.trim()})`);
      renderNodes({ nodes: [] });
    } else {
      const data = await res.json();
      renderNodes(data);
      scheduleNodesPoll(!!data?.scanning);
    }
  } catch (err) {
    setNodesNotice(`Failed to load /nodes (${err.message})`);
  } finally {
    nodesState.loading = false;
  }
}

function scheduleNodesPoll(keepPolling){
  if (nodesState.pollTimer){
    clearTimeout(nodesState.pollTimer);
    nodesState.pollTimer = null;
  }
  if (keepPolling){
    nodesState.pollTimer = setTimeout(() => { nodesState.pollTimer = null; fetchNodes(); }, 1000);
  }
}

async function triggerNodesScan(){
  $('#nodesScanBtn').disabled = true;
  try {
    await fetch('/nodes', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: '{}' });
  } catch (err) {
    setNodesNotice(`Failed to start scan: ${err.message}`);
  } finally {
    fetchNodes();
  }
}

function buildSlotCard(slotNumber, rec, meta, refMs){
  const slot = document.createElement('div');
  slot.className = 'sync-slot';
  const header = document.createElement('div');
  header.className = 'sync-slot-head';
  header.textContent = `Slot ${slotNumber}` + (meta?.label ? ` — ${meta.label}` : '');
  slot.append(header);
  const body = document.createElement('div');
  body.className = 'sync-slot-body';
  if (rec){
    const title = document.createElement('div');
    title.innerHTML = `<strong>${rec.id || 'unnamed'}</strong>`;
    body.append(title);
    const metaLine = document.createElement('div');
    metaLine.className = 'mut';
    const parts = [];
    if (rec.device) parts.push(rec.device);
    if (rec.role) parts.push(rec.role);
    if (rec.version) parts.push(`v${rec.version}`);
    if (rec.remote_ip) parts.push(rec.remote_ip);
    metaLine.textContent = parts.join(' • ') || '—';
    body.append(metaLine);
    const lastSeen = document.createElement('div');
    lastSeen.className = 'mut';
    lastSeen.textContent = `Last seen ${formatAgoMs(rec.last_seen_ms, refMs)}`;
    body.append(lastSeen);
    const gen = document.createElement('div');
    gen.className = 'mut';
    gen.textContent = `Generation ack ${rec.last_ack_generation ?? '—'} / slot ${rec.slot_generation ?? '—'}`;
    body.append(gen);
    const actions = document.createElement('div');
    actions.className = 'sync-slot-actions';
    const replayBtn = document.createElement('button');
    replayBtn.type = 'button';
    replayBtn.textContent = 'Replay commands';
    replayBtn.addEventListener('click', () => { requestReplay(slotNumber); });
    actions.append(replayBtn);
    body.append(actions);
  } else {
    const empty = document.createElement('div');
    empty.className = 'mut';
    empty.textContent = 'Empty';
    body.append(empty);
  }
  if (meta?.prefer_id){
    const prefer = document.createElement('div');
    prefer.className = 'mut';
    prefer.textContent = `Preferred id: ${meta.prefer_id}`;
    body.append(prefer);
  }
  slot.append(body);
  return slot;
}

function renderSync(data){
  const statusEl = $('#syncStatus');
  const grid = $('#syncGrid');
  const waitingEl = $('#syncWaiting');
  if (!statusEl || !grid || !waitingEl) return;
  if (!data){
    statusEl.textContent = 'No data';
    grid.innerHTML = '';
    waitingEl.textContent = '—';
    return;
  }
  const slotsMeta = new Map();
  (Array.isArray(data.slots) ? data.slots : []).forEach(entry => {
    const slotNum = Number(entry?.slot);
    if (Number.isFinite(slotNum) && slotNum >= 1 && slotNum <= MAX_SYNC_SLOTS){
      slotsMeta.set(slotNum, entry);
    }
  });
  const slots = Array.from({ length: MAX_SYNC_SLOTS }, () => null);
  const waiting = [];
  let refMs = 0;
  (Array.isArray(data.slaves) ? data.slaves : []).forEach(rec => {
    if (!rec || typeof rec !== 'object') return;
    if (Number.isFinite(rec.last_seen_ms) && rec.last_seen_ms > refMs) refMs = rec.last_seen_ms;
    const slotNum = Number(rec.slot);
    if (Number.isFinite(slotNum) && slotNum >= 1 && slotNum <= MAX_SYNC_SLOTS){
      slots[slotNum - 1] = rec;
    } else {
      waiting.push(rec);
    }
  });
  grid.innerHTML = '';
  const frag = document.createDocumentFragment();
  slots.forEach((rec, idx) => {
    const slotNum = idx + 1;
    frag.append(buildSlotCard(slotNum, rec, slotsMeta.get(slotNum), refMs));
  });
  grid.append(frag);
  if (waiting.length){
    waitingEl.textContent = waiting.map(rec => `${rec.id || rec.remote_ip || 'unknown'} (${formatAgoMs(rec.last_seen_ms, refMs)})`).join(', ');
  } else {
    waitingEl.textContent = 'None';
  }
  statusEl.textContent = `Updated ${new Date().toLocaleTimeString()} • ${ (data.slaves?.length) || 0 } known`;
}

async function fetchSync(){
  $('#syncStatus').textContent = 'Loading /sync/slaves…';
  try {
    const res = await fetch('/sync/slaves', { cache: 'no-store' });
    if (!res.ok){
      const text = await res.text().catch(() => '');
      $('#syncStatus').textContent = `Failed (${res.status} ${text.trim()})`;
      $('#syncGrid').innerHTML = '';
      $('#syncWaiting').textContent = '—';
      return;
    }
    const data = await res.json();
    renderSync(data);
  } catch (err) {
    $('#syncStatus').textContent = `Failed (${err.message})`;
    $('#syncGrid').innerHTML = '';
    $('#syncWaiting').textContent = '—';
  }
}

async function requestReplay(slotNumber){
  $('#syncStatus').textContent = `Requesting replay for slot ${slotNumber}…`;
  try {
    const res = await fetch('/sync/push', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ replay_slots: [slotNumber] })
    });
    if (!res.ok){
      const txt = await res.text().catch(() => '');
      $('#syncStatus').textContent = `Replay failed (${res.status} ${txt.trim()})`;
      return;
    }
    $('#syncStatus').textContent = `Replay requested for slot ${slotNumber}`;
    fetchSync();
  } catch (err) {
    $('#syncStatus').textContent = `Replay failed (${err.message})`;
  }
}

const capsRefreshBtn = document.getElementById('capsRefreshBtn');
if (capsRefreshBtn) capsRefreshBtn.addEventListener('click', () => { void fetchCaps(); });
ensureDvrHandlers();
setupExecCard();
$('#refreshNodesBtn').addEventListener('click', fetchNodes);
$('#refreshSyncBtn').addEventListener('click', fetchSync);
$('#nodesScanBtn').addEventListener('click', triggerNodesScan);
$('#syncRefreshBtn').addEventListener('click', fetchSync);
void fetchCaps();
fetchNodes();
fetchSync();
</script>
