<!doctype html>
<meta charset="utf-8">
<title>autod — VRX console</title>
<style>
  :root {
    --bg:#0b0d10; --fg:#e8e8ea; --mut:#9aa1a6; --ok:#36c275; --err:#ff6b6b;
    --panel:#12161a; --card:#151a1f; --line:#21262c;
    --scroll-track:#0f1317; --scroll-thumb:#2a3139; --scroll-thumb-hover:#36404a;
  }
  *{box-sizing:border-box; min-width:0; scrollbar-width:thin; scrollbar-color:var(--scroll-thumb) var(--scroll-track)}
  *::-webkit-scrollbar{width:10px;height:10px}
  *::-webkit-scrollbar-track{background:var(--scroll-track)}
  *::-webkit-scrollbar-thumb{background:var(--scroll-thumb);border-radius:999px;border:2px solid transparent;background-clip:content-box}
  *::-webkit-scrollbar-thumb:hover{background:var(--scroll-thumb-hover); background-clip:content-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,Segoe UI,Roboto,Inter,sans-serif;-webkit-tap-highlight-color:transparent;overflow-wrap:anywhere; word-break:break-word; overscroll-behavior:contain}
  header{padding:14px 16px;border-bottom:1px solid var(--line);background:var(--panel);display:flex;justify-content:space-between;align-items:center;gap:12px;position:sticky;top:0;z-index:1}
  header .title{font-weight:700}
  header .sub{color:var(--mut);font-size:12px}
  main{padding:14px;display:grid;gap:12px;grid-template-columns:1fr}
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;overflow:hidden}
  .card h2{margin:0;padding:12px 14px;border-bottom:1px solid var(--line);font-size:14px}
  .card .body{padding:12px 14px;display:grid;gap:10px}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .row > label{display:flex;align-items:center;gap:8px;flex:1 1 180px}
  input,button,textarea,select{
    background:#0f1317;color:var(--fg);border:1px solid var(--line);
    border-radius:10px;padding:8px 10px;font:inherit;max-width:100%
  }
  input[type="text"], input:not([type]){width:clamp(140px, 100%, 280px)}
  textarea{width:100%;min-height:100px;resize:vertical;border-radius:12px;white-space:pre-wrap;overflow-wrap:anywhere;word-break:break-word}
  button{cursor:pointer}
  code,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .inline{display:block;max-width:100%;overflow:auto;white-space:pre-wrap;overflow-wrap:anywhere;word-break:break-word;padding:8px 10px;background:#0f1317;border:1px solid var(--line);border-radius:10px}
  .kv{display:grid;grid-template-columns:minmax(90px,160px) 1fr;gap:6px;align-items:center}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border:1px solid var(--line);border-radius:999px;color:var(--mut);font-size:12px}
  .ok{color:var(--ok)} .err{color:var(--err)}
  .grid{display:grid;gap:8px}
  .caps{display:flex;flex-wrap:wrap;gap:6px}
  .mut{color:var(--mut)}
  .sse a{color:inherit;text-decoration:underline dotted;word-break:break-all}

  .dvr-body{display:grid;grid-template-rows:auto 1fr;gap:10px;height:360px;min-height:0}
  .dvr-scroll{display:grid;gap:6px;overflow:auto;padding-right:4px;min-height:0}
  .dvr-list{display:grid;gap:6px}
  .dvr-item{display:grid;gap:4px;padding:10px 12px;border:1px solid var(--line);border-radius:10px;background:#0f1317}
  .dvr-item a{color:inherit;text-decoration:none;font-weight:600;word-break:break-all}
  .dvr-item a:hover{text-decoration:underline}
  .dvr-meta{color:var(--mut);font-size:12px}
  .dvr-message{font-size:12px}
  .dvr-message.ok{color:var(--ok)}
  .dvr-message.err{color:var(--err)}
  .dvr-empty{color:var(--mut);font-size:12px}

  .nodes-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:10px}
  .node{border:1px solid var(--line);background:#0f1317;border-radius:12px;padding:10px;display:grid;gap:6px}
  .node .top{display:flex;align-items:center;justify-content:space-between;gap:6px}
  .node .ip{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;color:var(--mut)}
  .node .meta{font-size:12px;color:var(--mut)}
  .node .role{border-color:#2d333b}
  .progress{height:10px;border:1px solid var(--line);border-radius:999px;overflow:hidden;background:#0f1317}
  .progress > div{height:100%;background:linear-gradient(90deg,var(--ok),#64d38f);width:0%}
  .nodes-toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .nodes-toolbar .mut{font-size:12px}
  .nodes-stats{display:flex;flex-wrap:wrap;gap:8px;font-size:12px;color:var(--mut)}
  .spacer{flex:1}

  .cap-toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .cap-stats{display:flex;flex-wrap:wrap;gap:8px;font-size:12px;color:var(--mut)}
  .cap-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px}

  .ctl{display:grid;gap:6px;padding:10px;border:1px solid var(--line);border-radius:12px;background:#0f1317}
  .ctl .lbl{display:flex;justify-content:space-between;gap:8px;align-items:center}
  .ctl .lbl .name{font-weight:600}
  .ctl .lbl .val{color:var(--mut);font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;transition:color .35s ease}
  .ctl .desc{color:var(--mut);font-size:12px}
  .ctl .errtxt{color:var(--err);font-size:12px}
  .switch{position:relative;width:46px;height:26px}
  .switch input{appearance:none;width:46px;height:26px;background:#12161a;border:1px solid var(--line);border-radius:999px;outline:none;transition:.15s;display:block}
  .switch input:checked{background:#1b2d22;border-color:#254a35}
  .switch input::after{content:"";position:absolute;top:3px;left:3px;width:20px;height:20px;border-radius:50%;background:#cfd6dd;transition:.15s}
  .switch input:checked::after{left:23px;background:#e8f6ee}

  .freebox{display:none;margin-top:6px}
  .cap-toolbar button + .cap-toolbar button{margin-left:0}

  .embed-wrap{border:1px solid var(--line);border-radius:12px;overflow:hidden;background:#0f1317;min-height:320px;display:grid;gap:0}
  .embed-frame{width:100%;min-height:320px;border:0;background:#0f1317}
  .embed-note{padding:10px 12px;font-size:12px}

  .mini-status{display:flex;justify-content:flex-end;align-items:center;min-height:26px}
  .status-indicator{display:inline-flex;align-items:center;gap:6px;font-size:12px;padding:2px 10px;border-radius:999px;border:1px solid var(--line);color:var(--mut);background:#0f1317;transition:color .3s ease,border-color .3s ease,background .3s ease}
  .status-indicator::before{content:"";width:8px;height:8px;border-radius:50%;background:var(--mut);transition:background .3s ease}
  .status-indicator.running{color:var(--mut)}
  .status-indicator.running::before{background:var(--mut)}
  .status-indicator.ok{color:var(--ok);border-color:rgba(54,194,117,.4);background:rgba(54,194,117,.08)}
  .status-indicator.ok::before{background:var(--ok)}
  .status-indicator.err{color:var(--err);border-color:rgba(255,107,107,.4);background:rgba(255,107,107,.08)}
  .status-indicator.err::before{background:var(--err)}
  .status-indicator.flash{animation:statusBlink .7s ease-out}
  .status-indicator.err.flash{animation:statusBlinkErr .7s ease-out}
  @keyframes statusBlink{0%{box-shadow:0 0 0 0 rgba(54,194,117,.35)}100%{box-shadow:0 0 0 10px rgba(54,194,117,0)}}
  @keyframes statusBlinkErr{0%{box-shadow:0 0 0 0 rgba(255,107,107,.35)}100%{box-shadow:0 0 0 10px rgba(255,107,107,0)}}
  @media (prefers-reduced-motion:reduce){
    .status-indicator.flash,.status-indicator.err.flash{animation:none}
  }
  .ctl.flash-ok{border-color:rgba(54,194,117,.4);box-shadow:0 0 0 1px rgba(54,194,117,.3)}
  .ctl.flash-err{border-color:rgba(255,107,107,.45);box-shadow:0 0 0 1px rgba(255,107,107,.3)}



:root { --udp-embed-height: 800px; } /* tweak as needed */
/* Let the container grow naturally; don't fix its height */
#card-udp-relay #udpRelayEmbedContainer.embed-wrap {
  height: auto;
  min-height: 0;
}

/* Force the iframe to the desired height (override any global iframe rules) */
#card-udp-relay #udpRelayEmbedContainer .embed-frame {
  display: block;
  width: 100%;
  height: var(--udp-embed-height) !important;
  border: 0;
}

/* Give the note normal flow space below the embed */
#card-udp-relay .embed-note { margin-top: 8px; }

</style>

<header>
  <div>
    <div class="title">autod — VRX console</div>
    <div class="sub" id="subtitle">loading caps…</div>
  </div>
  <div class="row" style="justify-content:flex-end">
    <button id="refreshCaps">Refresh /caps</button>
  </div>
</header>

<main>
  <section class="card" id="capsCard" style="display:none">
    <h2>Device & runtime</h2>
    <div class="body grid">
      <div class="kv"><div class="mut">Device</div><div id="dev_device">—</div></div>
      <div class="kv"><div class="mut">Role</div><div id="dev_role">—</div></div>
      <div class="kv"><div class="mut">Version</div><div id="dev_version">—</div></div>
      <div class="kv"><div class="mut">Interfaces</div><div id="dev_if">—</div></div>
      <div class="kv"><div class="mut">Uptime</div><div id="dev_uptime">—</div></div>
      <div class="kv"><div class="mut">Loadavg</div><div id="dev_load">—</div></div>
      <div class="kv"><div class="mut">Capabilities</div><div class="caps" id="dev_caps">—</div></div>
      <div class="kv"><div class="mut">SSE</div><div class="sse" id="dev_sse">—</div></div>
      <div class="row" id="deviceRuntimeActions" style="display:none">
        <button id="pixelpilotMiniRkRebootBtn">Reboot device</button>
        <button id="pixelpilotMiniRkShutdownBtn">Shutdown device</button>
      </div>
    </div>
  </section>

  <section class="card" id="nodesCard" style="display:none">
    <h2>Nodes</h2>
    <div class="body grid">
      <div class="nodes-toolbar">
        <button id="nodesScanBtn">POST /nodes (scan)</button>
        <div class="spacer"></div>
        <div class="nodes-stats" id="nodesStats">—</div>
      </div>
      <div class="progress" aria-label="Scan progress"><div id="nodesProgress"></div></div>
      <div id="nodesNotice" class="mut">—</div>
      <div class="nodes-grid" id="nodesGrid"></div>
    </div>
  </section>

  <section class="card" id="pixelpilotCard" style="display:none">
    <h2>Pixelpilot</h2>
    <div class="body grid">
      <div class="cap-toolbar">
        <div id="pixelpilotCmds" class="row"></div>
        <button id="pixelpilotRefreshBtn">Refresh values</button>
        <div class="spacer"></div>
        <div class="cap-stats" id="pixelpilotStats">—</div>
      </div>
      <div class="cap-grid" id="pixelpilotGrid"></div>
      <div>
        <div class="mut">Last request:</div>
        <pre class="inline" id="pixelpilotReqPreview">{}</pre>
        <div class="mut">Last response:</div>
        <textarea id="pixelpilotResp" readonly></textarea>
      </div>
    </div>
  </section>

  <section class="card" id="pixelpilotMiniRkCard" style="display:none">
    <h2>Pixelpilot Mini RK</h2>
    <div class="body grid">
      <div class="cap-toolbar">
        <div class="row" id="pixelpilotMiniRkActions">
          <button id="pixelpilotMiniRkToggleOsdBtn">Toggle OSD</button>
          <button id="pixelpilotMiniRkToggleRecordingBtn">Toggle Recording</button>
          <button id="pixelpilotMiniRkRestartServiceBtn">Restart pixelpilot_mini_rk</button>
          <button id="pixelpilotMiniRkStopServiceBtn">Stop pixelpilot_mini_rk</button>
          <button id="pixelpilotMiniRkStartServiceBtn">Start pixelpilot_mini_rk</button>
        </div>
        <div class="spacer"></div>
        <div class="mini-status">
          <div class="status-indicator" id="pixelpilotMiniRkStatus" aria-live="polite">Idle</div>
        </div>
      </div>
    </div>
  </section>

  <section class="card" id="dvrCard" style="display:none">
    <h2>DVR recordings</h2>
    <div class="body grid dvr-body">
      <div class="row">
        <button id="dvrRefreshBtn">Refresh list</button>
        <button id="dvrDeleteAllBtn">Delete all</button>
        <div class="spacer"></div>
        <div class="mut" id="dvrStatus">—</div>
      </div>
      <div class="dvr-scroll">
        <div id="dvrMessage" class="dvr-message" style="display:none"></div>
        <div id="dvrEmptyState" class="dvr-empty" style="display:none">No recordings found.</div>
        <div id="dvrList" class="dvr-list"></div>
      </div>
    </div>
  </section>

  <section class="card" id="udpRelayCard" style="display:none">
    <h2>UDP relay</h2>
    <div class="body grid">
      <div class="cap-toolbar">
        <div id="udpRelayCmds" class="row"></div>
        <button id="udpRelayRefreshBtn">Refresh values</button>
        <button id="udpRelayReloadEmbedBtn">Reload relay UI</button>
        <div class="spacer"></div>
        <div class="cap-stats" id="udpRelayStats">—</div>
      </div>

      <section id="card-udp-relay" class="card">
      <div id="udpRelayEmbedContainer" class="embed-wrap">
        <div class="embed-note mut">Trying to load http://localhost:9000/…</div>
      </div>
      </section>

      <div class="cap-grid" id="udpRelayGrid"></div>
      <div>
        <div class="mut">Last request:</div>
        <pre class="inline" id="udpRelayReqPreview">{}</pre>
        <div class="mut">Last response:</div>
        <textarea id="udpRelayResp" readonly></textarea>
      </div>
    </div>
  </section>

  <section class="card" id="linkCard" style="display:none">
    <h2>Link</h2>
    <div class="body grid">
      <div class="cap-toolbar">
        <div id="linkCmds" class="row"></div>
        <div class="spacer"></div>
        <div class="cap-stats" id="linkStats">—</div>
      </div>
      <div class="cap-grid" id="linkGrid"></div>
      <div>
        <div class="mut">Last request:</div>
        <pre class="inline" id="linkReqPreview">{}</pre>
        <div class="mut">Last response:</div>
        <textarea id="linkResp" readonly></textarea>
      </div>
    </div>
  </section>
  <section class="card" id="execCard">
    <h2>/exec — raw runner</h2>
    <div class="body">
      <div class="row">
        <label>path <input id="exec_path" value="/sys/pixelpilot/help"></label>
        <label>args (space-separated) <input id="exec_args" placeholder=''></label>
        <button id="exec_btn">POST /exec</button>
      </div>
      <div class="mut">Body preview:</div>
      <pre class="inline" id="exec_body_preview">{}</pre>
      <div class="mut">Response:</div>
      <textarea id="exec_out" readonly></textarea>
    </div>
  </section>
  <section class="card" id="remoteExecCard" style="display:none">
    <h2>Remote /exec — raw runner</h2>
    <div class="body">
      <div class="row">
        <label>target <input id="remoteExec_targetInput" value="http://192.168.2.203:55667/exec" placeholder="http://host:port/exec"></label>
        <div class="spacer"></div>
      </div>
      <div class="row">
        <label>path <input id="remoteExec_path" value="/sys/help"></label>
        <label>args (space-separated) <input id="remoteExec_args" placeholder=''></label>
        <button id="remoteExec_btn">POST remote /exec</button>
      </div>
      <div class="mut" id="remoteExec_target">Target: —</div>
      <div class="mut">Body preview:</div>
      <pre class="inline" id="remoteExec_body_preview">{}</pre>
      <div class="mut">Response:</div>
      <textarea id="remoteExec_out" readonly></textarea>
    </div>
  </section>
</main>

<script>
const $ = s => document.querySelector(s);
const fmtOneLine = obj => JSON.stringify(obj);
const sleep = ms => new Promise(r => setTimeout(r, ms));
const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
const DEFAULT_REMOTE_EXEC_TARGET = 'http://192.168.2.203:55667/exec';

function joinCaps(caps){
  if (!Array.isArray(caps) || !caps.length) return '—';
  const frag = document.createDocumentFragment();
  caps.forEach(c => { const span = document.createElement('span'); span.className='pill'; span.textContent=c; frag.appendChild(span); });
  return frag;
}

function normalizeRemoteExecTarget(raw){
  let next = (raw ?? '').trim();
  if (!next) return DEFAULT_REMOTE_EXEC_TARGET;
  if (!/^https?:\/\//i.test(next)){
    next = 'http://' + next.replace(/^\/+/, '');
  }
  return next;
}

function getRemoteExecTarget(){
  const input = document.getElementById('remoteExec_targetInput');
  if (!input) return DEFAULT_REMOTE_EXEC_TARGET;
  return normalizeRemoteExecTarget(input.value);
}

function updateRemoteExecTargetDisplay(){
  const targetEl = document.getElementById('remoteExec_target');
  if (!targetEl) return;
  targetEl.textContent = `Target: ${getRemoteExecTarget()}`;
}
function secsToHhMmSs(secs){ if(!secs&&secs!==0)return'—'; const s=Math.floor(secs); const h=(s/3600)|0,m=((s%3600)/60)|0,ss=s%60; return `${h}h ${m}m ${ss}s`; }
function tsToAgo(tsSec){ if(!tsSec)return'—'; const now=(Date.now()/1000)|0; const d=Math.max(0,now-tsSec); if(d<60)return`${d|0}s ago`; if(d<3600)return`${(d/60)|0}m ago`; if(d<86400)return`${(d/3600)|0}h ago`; return`${(d/86400)|0}d ago`; }
function fmtDate(tsSec){ if(!tsSec)return'—'; const d=new Date(tsSec*1000); return d.toISOString().replace('T',' ').replace(/\.\d+Z$/,'Z'); }
function fmtSizeMb(bytes){ if(typeof bytes!=='number'||!Number.isFinite(bytes)||bytes<0)return'—'; const mb=bytes/1048576; const places=mb>=100?0:(mb>=10?1:2); return `${mb.toFixed(places)} MB`; }
function fmtLocalDateTime(tsSec){ if(typeof tsSec!=='number'||!Number.isFinite(tsSec)||tsSec<=0)return'—'; const d=new Date(tsSec*1000); if(Number.isNaN(d.getTime()))return'—'; return d.toLocaleString(); }

function makeDebounce(fn, wait){
  let t=null, lastArgs=null;
  return (...args)=>{
    lastArgs=args;
    if(t) clearTimeout(t);
    t=setTimeout(()=>{ t=null; fn(...lastArgs); }, wait);
  };
}

function flashCtl(ctlEl, ok){
  const cls = ok ? 'flash-ok' : 'flash-err';
  ctlEl.classList.add(cls);
  setTimeout(()=> ctlEl.classList.remove(cls), 700);
}

function miniRkStatusEl(){
  return document.getElementById('pixelpilotMiniRkStatus');
}

function setMiniRkStatusIdle(text='Idle'){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('running','ok','err','flash');
  el.textContent = text;
  el.title = '';
}

function setMiniRkStatusRunning(){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('ok','err','flash');
  el.classList.add('running');
  el.textContent = 'Running…';
  el.title = '';
}

function setMiniRkStatusResult(ok, detail=''){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('running','ok','err','flash');
  el.classList.add(ok ? 'ok' : 'err');
  const stamp = new Date().toLocaleTimeString();
  const label = ok ? 'Success' : 'Error';
  el.textContent = `${label} • ${stamp}`;
  el.title = detail || '';
  // restart animation
  void el.offsetWidth;
  el.classList.add('flash');
}

async function runMiniRkCommand(command, btnEl){
  const payload = typeof command === 'string'
    ? { path: command, args: [] }
    : {
        path: command?.path || '',
        args: Array.isArray(command?.args) ? command.args : []
      };
  if (!payload.path){
    setMiniRkStatusResult(false, 'invalid command');
    return;
  }
  setMiniRkStatusRunning();
  if (btnEl) btnEl.disabled = true;
  try{
    const res = await postExec(payload, CMD_TIMEOUT_MS, 'pixelpilotMiniRk');
    const ok = (res && typeof res.rc === 'number') ? res.rc === 0 : true;
    const rawStdout = (res?.stdout ?? '').trim();
    const rawStderr = (res?.stderr ?? '').trim();
    const detail = ok ? (rawStdout.split('\n')[0] || '') : (rawStderr || rawStdout || 'command failed');
    setMiniRkStatusResult(ok, detail);
  }catch(e){
    setMiniRkStatusResult(false, e?.message || 'command failed');
  }finally{
    if (btnEl) btnEl.disabled = false;
  }
}

const CAP_GET_STAGGER_MS = 100;
const CAP_GET_TIMEOUT_MS = 150;
const CAP_SET_DEBOUNCE_MS = 500;
const CMD_TIMEOUT_MS = 3000;

async function fetchWithTimeout(url, opts = {}, ms = 100){
  const ctrl = new AbortController();
  const id = setTimeout(() => ctrl.abort('timeout'), ms);
  try{
    return await fetch(url, { ...opts, signal: ctrl.signal });
  } finally {
    clearTimeout(id);
  }
}

async function postExec(body, timeoutMs = 100, prefix = ''){
  const reqEl = document.getElementById(prefix+'ReqPreview');
  const respEl = document.getElementById(prefix+'Resp');
  if (reqEl) reqEl.textContent = fmtOneLine(body);
  try{
    const r = await fetchWithTimeout('/exec', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(body)
    }, timeoutMs);
    const txt = await r.text();
    if (respEl) respEl.value = txt.replace(/\n/g,'\\n');
    try { return JSON.parse(txt); }
    catch { return { rc:-1, stdout:txt, stderr:"", elapsed_ms:0 }; }
  }catch(e){
    const payload = { error: (e?.name === 'AbortError' ? 'timeout' : 'network_error'), message: e?.message || String(e), timeout_ms: timeoutMs };
    if (respEl) respEl.value = JSON.stringify(payload);
    throw e;
  }
}


  // Resolve which host to use for the relay UI
function getTargetHost() {
  const qp = new URLSearchParams(location.search);
  // Allow ?host=192.168.2.20 (useful when embedding this page from a scanner)
  return qp.get('host') || location.hostname || 'localhost';
}

// Build base URL for the UI on port 9000 using the resolved host
function relayBase() {
  // If parent is https, prefer http for :9000 unless you terminate TLS there
  const proto = (location.protocol === 'https:' ? 'http:' : location.protocol);
  return `${proto}//${getTargetHost()}:9000/`;
}


function parseArgs(text){
  const out = [];
  text.trim().replace(/"([^\"]*)"|'([^']*)'|(\S+)/g, (_,dq,sq,bare) => { out.push((dq ?? sq ?? bare) + ''); return ''; });
  return out;
}
async function doExec(){
  const path = $('#exec_path').value.trim();
  const args = parseArgs($('#exec_args').value);
  const body = { path, args };
  $('#exec_body_preview').textContent = fmtOneLine(body);
  try{
    const r = await fetch('/exec',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)});
    const txt = await r.text();
    $('#exec_out').value = txt.replace(/\n/g,'\\n');
  }catch(e){
    $('#exec_out').value = `{"error":"fetch_failed","msg":"${e.message}"}`;
  }
}

async function doRemoteExec(){
  const pathInput = $('#remoteExec_path');
  const argsInput = $('#remoteExec_args');
  const previewEl = $('#remoteExec_body_preview');
  const outEl = $('#remoteExec_out');
  if (!pathInput || !argsInput || !previewEl || !outEl) return;
  const path = pathInput.value.trim();
  const args = parseArgs(argsInput.value);
  const body = { path, args };
  previewEl.textContent = fmtOneLine(body);
  const target = getRemoteExecTarget();
  updateRemoteExecTargetDisplay();
  try{
    const r = await fetch(target,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)});
    const txt = await r.text();
    outEl.value = txt.replace(/\n/g,'\\n');
  }catch(e){
    outEl.value = `{"error":"fetch_failed","msg":"${e.message}"}`;
  }
}

let nodesPollTimer = null;
function renderNodesCard(state){
  const {nodes=[],scan_feature_enabled=0,scanning=0,targets=0,done=0,progress_pct,last_started,last_finished}=state||{};
  const pct = typeof progress_pct==='number' ? clamp(Math.round(progress_pct),0,100)
             : (targets>0 ? clamp(Math.round(100*done/targets),0,100) : (scanning?0:100));
  $('#nodesStats').textContent = `feature:${scan_feature_enabled?'on':'off'} • scanning:${scanning?'yes':'no'} • targets:${targets} • done:${done} • progress:${pct}% • started:${fmtDate(last_started)} • finished:${fmtDate(last_finished)}`;
  $('#nodesProgress').style.width = pct + '%';
  $('#nodesNotice').textContent = scanning ? 'Scanning… polling /nodes every 800ms' : (nodes.length?`${nodes.length} node(s) found`:'No nodes found');
  $('#nodesScanBtn').disabled = !scan_feature_enabled || !!scanning;
  const grid=$('#nodesGrid'); grid.innerHTML=''; nodes.forEach(n=>{
    const div=document.createElement('div'); div.className='node';
    div.innerHTML=`<div class="top"><span class="pill role">${n.role||'—'}</span><span class="ip">${n.ip||'—'}:${n.port||''}</span></div>
      <div><strong>${n.device||'—'}</strong> <span class="meta">v${n.version||'—'}</span></div>
      <div class="meta">last seen: ${tsToAgo(n.last_seen)} (${fmtDate(n.last_seen)})</div>`;
    grid.appendChild(div);
  });
}
async function fetchNodes(){
  if (!nodesUI.enabled) return;
  try{
    const r = await fetch('/nodes',{cache:'no-store'});
    if (!nodesUI.enabled) return;
    const data = await r.json();
    if (!nodesUI.enabled) return;
    renderNodesCard(data);
    if (data.scanning){ if(!nodesPollTimer){ nodesPollTimer=setInterval(fetchNodes,800); } }
    else { if(nodesPollTimer){ clearInterval(nodesPollTimer); nodesPollTimer=null; } }
  }catch(e){
    if (!nodesUI.enabled) return;
    renderNodesCard({nodes:[]});
    $('#nodesNotice').textContent = `Failed to load /nodes: ${e.message}`;
    if (nodesPollTimer){ clearInterval(nodesPollTimer); nodesPollTimer = null; }
  }
}
async function triggerNodesScan(){
  if (!nodesUI.enabled) return;
  $('#nodesScanBtn').disabled = true;
  try{ await fetch('/nodes',{method:'POST',headers:{'Content-Type':'application/json'},body:'{}'}); }
  catch(e){ $('#nodesNotice').textContent = `Failed to POST /nodes: ${e.message}`; }
  finally{ fetchNodes(); }
}

function sortSettings(settings){
  const sliders=[], selects=[], toggles=[];
  for (const s of settings){
    const k = s.control?.kind;
    if (k==='range') sliders.push(s);
    else if (k==='select') selects.push(s);
    else if (k==='toggle') toggles.push(s);
  }
  return [...sliders, ...selects, ...toggles];
}
function coerceForKey(meta, raw){
  if (raw==null) return raw;
  const t = meta.type;
  if (t==='int') return (raw===true?1:(raw===false?0:parseInt(raw,10)));
  if (t==='float') return (raw===true?1:(raw===false?0:parseFloat(raw)));
  if (t==='bool') {
    if (typeof raw === 'boolean') return raw;
    const s = String(raw).toLowerCase();
    return (s==='1'||s==='true'||s==='yes'||s==='on');
  }
  return String(raw);
}
function valueToString(meta, v){
  if (meta.type==='bool') return v ? 'true' : 'false';
  if (typeof v === 'number') return (Number.isFinite(v)? String(v) : '');
  return String(v ?? '');
}

function createCtlContainer(meta){
  const wrap = document.createElement('div'); wrap.className='ctl';
  const lbl  = document.createElement('div'); lbl.className='lbl';
  const name = document.createElement('div'); name.className='name'; name.textContent = meta.key;
  const val  = document.createElement('div'); val.className='val'; val.textContent = '…';
  lbl.append(name,val);
  const holder = document.createElement('div');
  const desc = document.createElement('div'); desc.className='desc'; desc.textContent = meta.description || '';
  const err = document.createElement('div'); err.className='errtxt'; err.style.display='none';
  wrap.append(lbl, holder, desc, err);
  return {wrap,holder,valEl:val,errEl:err};
}

function createSlider(meta){
  const {wrap,holder,valEl,errEl} = createCtlContainer(meta);
  const input = document.createElement('input');
  input.type = 'range';
  const min = Number(meta.control?.min ?? 0);
  const max = Number(meta.control?.max ?? 100);
  const step= Number(meta.control?.step ?? 1);
  input.min = String(min); input.max = String(max); input.step = String(step);
  input.addEventListener('input', ()=>{ valEl.textContent = input.value + (meta.control?.unit?(' '+meta.control.unit):''); });
  holder.append(input);
  return {el:wrap,input,valEl,errEl,kind:'range',min,max,step};
}

function createSelect(meta){
  const {wrap,holder,valEl,errEl} = createCtlContainer(meta);
  const sel = document.createElement('select');
  const opts = (meta.control?.options ?? []);
  for (const o of opts){
    const opt = document.createElement('option'); opt.value = String(o); opt.textContent = String(o); sel.appendChild(opt);
  }

  const allowFree = !!meta.control?.allow_free;
  let freeWrap=null, freeInput=null;
  if (allowFree){
    const optFree = document.createElement('option'); optFree.value="__free__"; optFree.textContent="Input value…";
    sel.appendChild(optFree);

    freeWrap = document.createElement('div'); freeWrap.className = 'freebox';
    freeInput = document.createElement('input'); freeInput.type='text'; freeInput.placeholder='Enter value…';
    freeWrap.appendChild(freeInput);
  }

  sel.addEventListener('change', ()=>{
    if (allowFree && sel.value==="__free__"){
      if (freeWrap) freeWrap.style.display = 'block';
      valEl.textContent = (freeInput && freeInput.value) || '';
    } else {
      if (allowFree && freeWrap) freeWrap.style.display = 'none';
      valEl.textContent = sel.value;
    }
  });
  if (allowFree && freeInput){
    freeInput.addEventListener('input', ()=>{ valEl.textContent = freeInput.value; });
  }

  holder.append(sel);
  if (allowFree) holder.append(freeWrap);

  return {el:wrap,input:sel,valEl,errEl,kind:'select',allowFree,freeWrap,freeInput};
}

function createToggle(meta){
  const {wrap,holder,valEl,errEl} = createCtlContainer(meta);
  const label = document.createElement('label'); label.className='switch';
  const chk = document.createElement('input'); chk.type='checkbox';
  chk.addEventListener('change', ()=>{ valEl.textContent = chk.checked ? 'true' : 'false'; });
  label.append(chk); holder.append(label);
  return {el:wrap,input:chk,valEl,errEl,kind:'toggle'};
}

function createCapManager(config){
  const state = { help:null, controls:{}, order:[] };

  function parseGetStdoutValue(key, stdout){
    if (stdout==null) return undefined;
    const t = String(stdout).trim();
    try{
      const j = JSON.parse(t);
      if (j && typeof j==='object'){
        if ('value' in j) return j.value;
        if (key in j) return j[key];
      }
    }catch{}
    const m = /^([^=\s]+)\s*=\s*(.+)$/.exec(t);
    if (m && m[1]===key) return m[2];
    return t;
  }

  function applyValueToUI(meta, value){
    const ctl = state.controls[meta.key];
    if (!ctl) return;
    ctl.errEl.style.display='none';
    const coerced = coerceForKey(meta, value);

    if (ctl.kind==='toggle'){
      ctl.input.checked = !!coerced;
      ctl.valEl.textContent = ctl.input.checked ? 'true' : 'false';
      return;
    }
    if (ctl.kind==='range'){
      const num = Number(coerced);
      const v = clamp(Number.isFinite(num)?num:Number(ctl.input.min), ctl.min, ctl.max);
      ctl.input.value = String(v);
      ctl.valEl.textContent = v + (meta.control?.unit?(' '+meta.control.unit):'');
      return;
    }
    if (ctl.kind==='select'){
      const s = String(coerced ?? '');
      let matched = false;
      for (const opt of ctl.input.options){
        if (opt.value !== "__free__" && opt.value === s){
          ctl.input.value = s; matched = true; break;
        }
      }
      if (matched){
        if (ctl.allowFree && ctl.freeWrap) ctl.freeWrap.style.display='none';
        ctl.valEl.textContent = ctl.input.value;
      } else if (ctl.allowFree){
        ctl.input.value = "__free__";
        if (ctl.freeWrap) ctl.freeWrap.style.display='block';
        if (ctl.freeInput) ctl.freeInput.value = s;
        ctl.valEl.textContent = s;
      } else {
        ctl.valEl.textContent = s;
      }
      return;
    }
  }

  async function getWithRetries(key, retries){
    let attempt=0, lastErr='unknown';
    while (attempt<retries){
      try{
        const body = { path:`/sys/${config.cap}/get`, args:[ key ] };
        const res = await postExec(body, CAP_GET_TIMEOUT_MS, config.prefix);
        const v = parseGetStdoutValue(key, res.stdout ?? '');
        if (v!==undefined && v!==null && String(v).length){
          return {ok:true, value:v};
        }
        if (v !== undefined && v !== null) return {ok:true, value:v};
        lastErr = 'empty';
      }catch(e){
        lastErr = e.message || 'fetch';
      }
      attempt++;
      if (attempt<retries) await sleep(50);
    }
    return {ok:false, err:lastErr};
  }

  function attachImmediateApply(meta, ctl){
    const key = meta.key;
    const apply = async (nextVal)=>{
      const valStr = valueToString(meta, nextVal);
      const body = { path:`/sys/${config.cap}/set`, args:[ `${key}=${valStr}` ] };
      try{
        ctl.errEl.style.display='none';
        const res = await postExec(body, CMD_TIMEOUT_MS, config.prefix);
        const ok = (res && typeof res.rc === 'number') ? res.rc === 0 : true;
        flashCtl(ctl.el, ok);
        try {
          const got = await getWithRetries(key, 2);
          if (got.ok) applyValueToUI(meta, got.value);
        } catch {}
      }catch(e){
        flashCtl(ctl.el, false);
        ctl.errEl.textContent = `set failed: ${e.message}`;
        ctl.errEl.style.display='block';
      }
    };
    const deb = makeDebounce(apply, CAP_SET_DEBOUNCE_MS);
    ctl.debouncedSet = deb;

    if (ctl.kind==='range'){
      const emit = ()=> ctl.debouncedSet(Number(ctl.input.value));
      ctl.input.addEventListener('input', emit);
      ctl.input.addEventListener('change', emit);
    } else if (ctl.kind==='select'){
      const emitSel = ()=>{
        if (ctl.allowFree && ctl.input.value==="__free__"){
          if (ctl.freeWrap) ctl.freeWrap.style.display='block';
          const v = (ctl.freeInput?.value ?? '').trim();
          if (!v) return;
          ctl.debouncedSet(v);
        } else {
          if (ctl.allowFree && ctl.freeWrap) ctl.freeWrap.style.display='none';
          ctl.debouncedSet(ctl.input.value);
        }
      };
      ctl.input.addEventListener('change', emitSel);
      if (ctl.allowFree && ctl.freeInput){
        ctl.freeInput.addEventListener('input', ()=>{
          const v=(ctl.freeInput.value||'').trim();
          if (!v) return;
          ctl.debouncedSet(v);
        });
      }
    } else if (ctl.kind==='toggle'){
      ctl.input.addEventListener('change', ()=> ctl.debouncedSet(!!ctl.input.checked));
    }
  }

  function buildCommandButtons(help){
    const holder = document.getElementById(config.cmdsId);
    if (!holder) return;
    holder.innerHTML = '';
    const names = new Set((help?.commands||[]).map(c=>c.name));
    const labelMap = { start:'Start', stop:'Stop', restart:'Restart', apply:'Apply', status:'Status', mode:'Mode', toggle_record:'Toggle record' };
    for (const cmd of ['start','stop','restart','apply','status','toggle_record']){
      if (!names.has(cmd)) continue;
      const btn = document.createElement('button');
      btn.textContent = labelMap[cmd] || cmd;
      btn.addEventListener('click', async ()=>{
        try{
          const res = await postExec({path:`/sys/${config.cap}/${cmd}`, args:[]}, CMD_TIMEOUT_MS, config.prefix);
          const ok = (res && typeof res.rc === 'number') ? res.rc===0 : true;
          const anyCtl = Object.values(state.controls)[0];
          if (anyCtl) flashCtl(anyCtl.el, ok);
        }catch{
          const anyCtl = Object.values(state.controls)[0];
          if (anyCtl) flashCtl(anyCtl.el, false);
        }
      });
      holder.appendChild(btn);
    }
  }

  function buildControls(settings){
    const grid = document.getElementById(config.gridId);
    if (!grid) return;
    grid.innerHTML = '';
    const sorted = sortSettings(settings);
    state.order = sorted.map(s=>s.key);
    for (const meta of sorted){
      let ctl;
      const kind = meta.control?.kind;
      if (kind==='range') ctl = createSlider(meta);
      else if (kind==='select') ctl = createSelect(meta);
      else if (kind==='toggle') ctl = createToggle(meta);
      else continue;
      attachImmediateApply(meta, ctl);
      grid.appendChild(ctl.el);
      state.controls[meta.key] = {...ctl, meta};
      applyValueToUI(meta, meta.default);
    }
  }

  async function refreshValues(){
    const keys = state.order.slice();
    let idx = 0, ok=0, fail=0;
    for (const key of keys){
      await sleep(CAP_GET_STAGGER_MS * (idx>0?1:0));
      const meta = state.controls[key]?.meta;
      if (!meta){ idx++; continue; }
      const got = await getWithRetries(key, 3);
      if (got.ok){ ok++; applyValueToUI(meta, got.value); }
      else { fail++; const ctl = state.controls[key]; if (ctl){ ctl.errEl.textContent = got.err || 'get failed'; ctl.errEl.style.display='block'; } }
      idx++;
    }
    const statsEl = document.getElementById(config.statsId);
    if (statsEl) statsEl.textContent = `refreshed ${ok} ok, ${fail} failed • ${new Date().toLocaleTimeString()}`;
  }

  async function ensureUI(){
    const statsEl = document.getElementById(config.statsId);
    if (!state.help){
      if (statsEl) statsEl.textContent = 'loading help…';
      let helpRes;
      try {
        helpRes = await postExec({path:`/sys/${config.cap}/help`, args:[]}, 350, config.prefix);
      } catch(e){
        if (statsEl) statsEl.textContent = `failed to load help: ${e.message}`;
        return;
      }
      let helpJson = null;
      try { helpJson = JSON.parse(helpRes.stdout || '{}'); } catch { helpJson = null; }
      if (!helpJson || !Array.isArray(helpJson.settings)){
        if (statsEl) statsEl.textContent = 'failed to parse help';
        return;
      }
      state.help = helpJson;
      buildCommandButtons(helpJson);
      buildControls(helpJson.settings);
      if (typeof config.onFirstHelp === 'function') config.onFirstHelp(helpJson, state);
    }
    if (statsEl) statsEl.textContent = 'refreshing…';
    await refreshValues();
  }

  return { ensureUI, refreshValues };
}

const pixelpilotManager = createCapManager({
  cap:'pixelpilot',
  prefix:'pixelpilot',
  gridId:'pixelpilotGrid',
  statsId:'pixelpilotStats',
  cmdsId:'pixelpilotCmds'
});

const udpRelayManager = createCapManager({
  cap:'udp_relay',
  prefix:'udpRelay',
  gridId:'udpRelayGrid',
  statsId:'udpRelayStats',
  cmdsId:'udpRelayCmds',
  onFirstHelp(){ ensureUdpRelayEmbed(); }
});

const udpRelayEmbed = { initialized:false, iframe:null };
function ensureUdpRelayEmbed(){
  if (udpRelayEmbed.initialized) return;
  const wrap = document.getElementById('udpRelayEmbedContainer');
  if (!wrap) return;
  wrap.innerHTML = '';
  const iframe = document.createElement('iframe');
  iframe.src = relayBase();
  iframe.loading = 'lazy';
  iframe.referrerPolicy = 'no-referrer';
  iframe.className = 'embed-frame';
  iframe.title = 'UDP relay UI';
  wrap.appendChild(iframe);

  const note = document.createElement('div');
  note.className = 'embed-note mut';
  const base = relayBase();
  note.innerHTML = `If the live UI fails to load, <a href="${base}" target="_blank" rel="noreferrer">open ${base}</a> or <a href="../udp_relay/vtx_udp_relay.html" target="_blank" rel="noreferrer">view the static copy</a>.`;

  wrap.parentNode.insertBefore(note, wrap.nextSibling);

  udpRelayEmbed.initialized = true;
  udpRelayEmbed.iframe = iframe;
}
function reloadUdpRelayEmbed(){
  if (!udpRelayEmbed.iframe) ensureUdpRelayEmbed();
  if (udpRelayEmbed.iframe){
    const base = relayBase();
    udpRelayEmbed.iframe.src = base + (base.includes('?') ? '&' : '?') + 't=' + Date.now();

  }
}

const linkUI = { help:null };

const nodesUI = { enabled:false };

const pixelpilotMiniRkUI = { initialized:false };

const dvrUI = { initialized:false, hasExec:false, entries:[] };

function ensurePixelpilotMiniRkUI(){
  if (pixelpilotMiniRkUI.initialized) return;
  setMiniRkStatusIdle('Idle');
  const cfg = [
    { btn:'#pixelpilotMiniRkToggleOsdBtn', command:{ path:'/sys/pixelpilot_mini_rk/toggle_osd' } },
    { btn:'#pixelpilotMiniRkToggleRecordingBtn', command:{ path:'/sys/pixelpilot_mini_rk/toggle_recording' } },
    { btn:'#pixelpilotMiniRkRebootBtn', command:{ path:'/sys/reboot' } },
    { btn:'#pixelpilotMiniRkShutdownBtn', command:{ path:'/sys/shutdown' } },
    { btn:'#pixelpilotMiniRkRestartServiceBtn', command:{ path:'/sys/pixelpilot_mini_rk/restart' } },
    { btn:'#pixelpilotMiniRkStopServiceBtn', command:{ path:'/sys/pixelpilot_mini_rk/stop' } },
    { btn:'#pixelpilotMiniRkStartServiceBtn', command:{ path:'/sys/pixelpilot_mini_rk/start' } }
  ];
  for (const {btn, command} of cfg){
    const btnEl = document.querySelector(btn);
    if (!btnEl) continue;
    btnEl.addEventListener('click', ()=> runMiniRkCommand(command, btnEl));
  }
  pixelpilotMiniRkUI.initialized = true;
}

function parseDvrListFromHtml(html){
  if (typeof DOMParser !== 'function') return [];
  try{
    const doc = new DOMParser().parseFromString(html, 'text/html');
    const anchors = Array.from(doc.querySelectorAll('a'));
    const files = [];
    for (const a of anchors){
      const raw = a.getAttribute('href') || '';
      if (!raw || raw === '../') continue;
      const cleaned = raw.split('#')[0].split('?')[0].replace(/^\/+|\/+$/g,'');
      if (!cleaned || cleaned === '..') continue;
      let decoded = cleaned;
      try{ decoded = decodeURIComponent(cleaned); }catch{}
      if (decoded.toLowerCase().endsWith('.mp4')) files.push(decoded);
    }
    files.sort((a,b)=>a.localeCompare(b,'en',{numeric:true,sensitivity:'base'}));
    return files;
  }catch{
    return [];
  }
}

function renderDvrList(entries){
  const listEl = document.getElementById('dvrList');
  if (!listEl) return;
  dvrUI.entries = Array.isArray(entries) ? entries : [];
  listEl.innerHTML = '';
  for (const entry of dvrUI.entries){
    if (!entry || typeof entry.name !== 'string') continue;
    const item = document.createElement('div');
    item.className = 'dvr-item';
    const link = document.createElement('a');
    const encoded = encodeURIComponent(entry.name);
    link.href = `/media/${encoded}`;
    link.textContent = entry.name;
    link.download = entry.name;
    link.addEventListener('click', ev => {
      if (ev.button !== 0 || ev.metaKey || ev.ctrlKey || ev.shiftKey || ev.altKey) return;
      ev.preventDefault();
      downloadDvrRecording(entry);
    });
    item.appendChild(link);
    const meta = document.createElement('div');
    meta.className = 'dvr-meta';
    const sizeTxt = fmtSizeMb(entry.sizeBytes);
    const timeTxt = fmtLocalDateTime(entry.mtimeSec);
    meta.textContent = (sizeTxt === '—' && timeTxt === '—') ? '—' : `${sizeTxt} • ${timeTxt}`;
    meta.title = (typeof entry.mtimeSec === 'number' && Number.isFinite(entry.mtimeSec) && entry.mtimeSec > 0) ? fmtDate(entry.mtimeSec) : '';
    item.appendChild(meta);
    listEl.appendChild(item);
  }
}

async function enrichDvrEntries(entries){
  if (!Array.isArray(entries) || !entries.length) return;
  for (const entry of entries){
    if (!entry || typeof entry.name !== 'string') continue;
    const needsSize = !(typeof entry.sizeBytes === 'number' && Number.isFinite(entry.sizeBytes) && entry.sizeBytes >= 0);
    const needsTime = !(typeof entry.mtimeSec === 'number' && Number.isFinite(entry.mtimeSec) && entry.mtimeSec > 0);
    if (!needsSize && !needsTime) continue;
    try{
      const resp = await fetch(`/media/${encodeURIComponent(entry.name)}`, { method:'HEAD', cache:'no-store' });
      if (!resp.ok) continue;
      if (needsSize){
        const len = resp.headers.get('content-length');
        if (len){
          const size = Number(len);
          if (Number.isFinite(size) && size >= 0) entry.sizeBytes = size;
        }
      }
      if (needsTime){
        const lm = resp.headers.get('last-modified');
        if (lm){
          const ts = Date.parse(lm);
          if (!Number.isNaN(ts) && Number.isFinite(ts)) entry.mtimeSec = Math.floor(ts/1000);
        }
      }
    }catch{}
  }
}

async function downloadDvrRecording(entry){
  if (!entry || typeof entry.name !== 'string') return;
  const statusEl = document.getElementById('dvrStatus');
  const msgEl = document.getElementById('dvrMessage');
  const previousStatus = statusEl ? statusEl.textContent : '';
  if (statusEl) statusEl.textContent = `downloading ${entry.name}…`;
  if (msgEl){
    msgEl.classList.remove('ok','err');
    msgEl.textContent = `Preparing download for ${entry.name}…`;
    msgEl.style.display = 'block';
  }
  try{
    const resp = await fetch(`/media/${encodeURIComponent(entry.name)}`, { cache:'no-store' });
    if (!resp.ok) throw new Error(`download failed (${resp.status})`);
    const blob = await resp.blob();
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement('a');
    anchor.href = url;
    anchor.download = entry.name;
    document.body.appendChild(anchor);
    anchor.click();
    anchor.remove();
    setTimeout(()=> URL.revokeObjectURL(url), 1000);
    if (msgEl){
      msgEl.classList.add('ok');
      msgEl.textContent = `Download ready for ${entry.name}`;
    }
  }catch(e){
    if (msgEl){
      msgEl.classList.add('err');
      msgEl.textContent = e?.message || `Failed to download ${entry.name}`;
    }
  }finally{
    if (statusEl) statusEl.textContent = previousStatus || '';
  }
}

async function refreshDvrList(){
  const statusEl = document.getElementById('dvrStatus');
  const listEl = document.getElementById('dvrList');
  const emptyEl = document.getElementById('dvrEmptyState');
  const msgEl = document.getElementById('dvrMessage');
  if (!statusEl || !listEl || !emptyEl || !msgEl) return;
  statusEl.textContent = 'loading…';
  listEl.innerHTML = '';
  emptyEl.style.display = 'none';
  msgEl.style.display = 'none';
  msgEl.textContent = '';
  msgEl.classList.remove('ok','err');
  try{
    let entries = [];
    if (dvrUI.hasExec){
      const res = await postExec({path:'/sys/dvr/list', args:[]}, CMD_TIMEOUT_MS, 'dvr');
      const ok = (res && typeof res.rc === 'number') ? res.rc === 0 : true;
      const stdout = String(res?.stdout ?? '');
      entries = stdout.split(/\r?\n/).map(line => line.trim()).filter(Boolean).map(line => {
        const parts = line.split('\t');
        const name = (parts[0] || '').trim();
        if (!name) return null;
        const sizeCandidate = parts.length > 1 ? Number(parts[1]) : NaN;
        const mtimeCandidate = parts.length > 2 ? Number(parts[2]) : NaN;
        const sizeBytes = (Number.isFinite(sizeCandidate) && sizeCandidate >= 0) ? sizeCandidate : null;
        const mtimeSec = (Number.isFinite(mtimeCandidate) && mtimeCandidate > 0) ? Math.floor(mtimeCandidate) : null;
        return { name, sizeBytes, mtimeSec };
      }).filter(Boolean);
      if (!ok){
        entries = [];
        const errMsg = (res?.stderr || res?.stdout || 'failed to list recordings').trim();
        if (errMsg){
          msgEl.textContent = errMsg;
          msgEl.classList.add('err');
          msgEl.style.display = 'block';
        }
      }
    } else {
      const resp = await fetch('/media/', {cache:'no-store'});
      if (!resp.ok){
        throw new Error(`/media/ responded with ${resp.status}`);
      }
      const text = await resp.text();
      const names = parseDvrListFromHtml(text);
      entries = names.map(name => ({ name, sizeBytes:null, mtimeSec:null }));
    }
    if (entries.some(entry => !entry || typeof entry.name !== 'string')){
      entries = entries.filter(entry => entry && typeof entry.name === 'string');
    }
    const needsMeta = entries.some(entry => !(typeof entry.sizeBytes === 'number' && Number.isFinite(entry.sizeBytes) && entry.sizeBytes >= 0) || !(typeof entry.mtimeSec === 'number' && Number.isFinite(entry.mtimeSec) && entry.mtimeSec > 0));
    if (needsMeta){
      await enrichDvrEntries(entries);
    }
    entries.sort((a,b)=>{
      const aTs = (typeof a.mtimeSec === 'number' && Number.isFinite(a.mtimeSec)) ? a.mtimeSec : 0;
      const bTs = (typeof b.mtimeSec === 'number' && Number.isFinite(b.mtimeSec)) ? b.mtimeSec : 0;
      if (bTs !== aTs) return bTs - aTs;
      return a.name.localeCompare(b.name,'en',{numeric:true,sensitivity:'base'});
    });
    renderDvrList(entries);
    if (!entries.length){
      emptyEl.style.display = 'block';
    }
    statusEl.textContent = `${entries.length} recording${entries.length===1?'':'s'} • ${new Date().toLocaleTimeString()}`;
  }catch(e){
    statusEl.textContent = `error • ${new Date().toLocaleTimeString()}`;
    msgEl.textContent = e?.message || 'failed to load recordings';
    msgEl.classList.add('err');
    msgEl.style.display = 'block';
  }
}

async function deleteAllDvrRecordings(){
  if (!dvrUI.hasExec) return;
  if (!confirm('Delete all DVR recordings? This cannot be undone.')) return;
  const deleteBtn = document.getElementById('dvrDeleteAllBtn');
  const statusEl = document.getElementById('dvrStatus');
  const msgEl = document.getElementById('dvrMessage');
  if (deleteBtn) deleteBtn.disabled = true;
  if (msgEl){
    msgEl.style.display = 'none';
    msgEl.textContent = '';
    msgEl.classList.remove('ok','err');
  }
  if (statusEl) statusEl.textContent = 'deleting…';
  let finalMsg = '';
  let finalClass = '';
  try{
    const res = await postExec({path:'/sys/dvr/delete_all', args:[]}, CMD_TIMEOUT_MS, 'dvr');
    const ok = (res && typeof res.rc === 'number') ? res.rc === 0 : true;
    const stdout = (res?.stdout || '').trim();
    const stderr = (res?.stderr || '').trim();
    finalMsg = ok ? stdout : (stderr || stdout || 'failed to delete recordings');
    finalClass = ok ? 'ok' : 'err';
  }catch(e){
    finalMsg = e?.message || 'failed to delete recordings';
    finalClass = 'err';
  }
  await refreshDvrList();
  if (deleteBtn) deleteBtn.disabled = false;
  if (msgEl && finalMsg){
    msgEl.textContent = finalMsg;
    msgEl.classList.add(finalClass);
    msgEl.style.display = 'block';
  }
}

function ensureDvrUI(hasExec){
  dvrUI.hasExec = !!hasExec;
  const refreshBtn = document.getElementById('dvrRefreshBtn');
  const deleteBtn = document.getElementById('dvrDeleteAllBtn');
  if (!refreshBtn || !deleteBtn) return;
  if (!dvrUI.initialized){
    refreshBtn.addEventListener('click', refreshDvrList);
    deleteBtn.addEventListener('click', deleteAllDvrRecordings);
    dvrUI.initialized = true;
  }
  deleteBtn.disabled = !dvrUI.hasExec;
  deleteBtn.title = dvrUI.hasExec ? '' : 'Requires exec capability';
  refreshDvrList();
}

function buildLinkButtonsFromHelp(help){
  const names = new Set((help?.commands||[]).map(c=>c.name));
  const cmds = $('#linkCmds'); cmds.innerHTML='';
  const mk = (label, path)=> {
    const b = document.createElement('button'); b.textContent = label;
    b.addEventListener('click', async ()=>{
      try{
        const res = await postExec({path, args:[]}, CMD_TIMEOUT_MS, 'link');
        const ok = (res && typeof res.rc === 'number') ? res.rc===0 : true;
        const gridChild = $('#linkGrid')?.firstElementChild;
        if (gridChild) flashCtl(gridChild, ok);
      }catch{
        const gridChild = $('#linkGrid')?.firstElementChild;
        if (gridChild) flashCtl(gridChild, false);
      }
    });
    return b;
  };
  if (names.has('mode'))   cmds.appendChild(mk('Mode',   '/sys/link/mode'));
  if (names.has('start'))  cmds.appendChild(mk('Start',  '/sys/link/start'));
  if (names.has('stop'))   cmds.appendChild(mk('Stop',   '/sys/link/stop'));
  if (names.has('status')) cmds.appendChild(mk('Status', '/sys/link/status'));
}

function buildLinkModeSelector(help){
  const selectCmd = (help?.commands||[]).find(c=>c.name==='select');
  const arg0 = selectCmd?.args?.[0] || {};
  const opts = arg0?.control?.options || ['udp_relay','pixelpilot','none'];
  const allowFree = !!arg0?.control?.allow_free;

  const grid = $('#linkGrid'); grid.innerHTML='';
  const box = document.createElement('div'); box.className='ctl';
  const lbl = document.createElement('div'); lbl.className='lbl';
  const name = document.createElement('div'); name.className='name'; name.textContent='mode';
  const val = document.createElement('div'); val.className='val'; val.textContent='—';
  lbl.append(name,val);

  const holder = document.createElement('div');
  const sel = document.createElement('select');
  for (const o of opts){ const op=document.createElement('option'); op.value=String(o); op.textContent=String(o); sel.appendChild(op); }
  let freeWrap=null, freeInput=null;
  if (allowFree){
    const opFree=document.createElement('option'); opFree.value="__free__"; opFree.textContent="Input value…"; sel.appendChild(opFree);
    freeWrap = document.createElement('div'); freeWrap.className='freebox';
    freeInput = document.createElement('input'); freeInput.type='text'; freeInput.placeholder='Enter value…';
    freeWrap.appendChild(freeInput);
  }
  sel.addEventListener('change', ()=>{
    if (allowFree && sel.value==="__free__"){ if (freeWrap) freeWrap.style.display='block'; val.textContent = freeInput?.value || ''; }
    else { if (allowFree && freeWrap) freeWrap.style.display='none'; val.textContent = sel.value; }
  });
  if (allowFree && freeInput) freeInput.addEventListener('input', ()=>{ val.textContent = freeInput.value; });

  const err = document.createElement('div'); err.className='errtxt'; err.style.display='none';
  const getCur = ()=> (allowFree && sel.value==="__free__" ? (freeInput?.value ?? '') : sel.value);

  const applyBtn = document.createElement('button'); applyBtn.textContent='Apply mode';
  applyBtn.addEventListener('click', async ()=>{
    err.style.display='none';
    val.textContent = getCur();
    try{
      const res = await postExec({ path:'/sys/link/select', args:[ getCur() ] }, CMD_TIMEOUT_MS, 'link');
      const ok = (res && typeof res.rc === 'number') ? res.rc===0 : true;
      flashCtl(box, ok);
    }catch(e){
      flashCtl(box, false);
      err.textContent = `select failed: ${e.message}`; err.style.display='block';
    }
  });

  const statusBtn = document.createElement('button'); statusBtn.textContent='Status';
  statusBtn.addEventListener('click', async ()=>{ try{ await postExec({path:'/sys/link/status', args:[]}, CMD_TIMEOUT_MS, 'link'); }catch{} });

  const desc = document.createElement('div'); desc.className='desc'; desc.textContent='Routes the active downlink between pixelpilot, udp_relay, or none';

  holder.append(sel);
  if (allowFree) holder.append(freeWrap);
  box.append(lbl, holder, applyBtn, statusBtn, desc, err);
  grid.appendChild(box);

  // seed with current mode if available
  (async ()=>{
    try{
      const res = await postExec({path:'/sys/link/mode', args:[]}, CMD_TIMEOUT_MS, 'link');
      const stdout = String(res.stdout ?? '').trim();
      if (!stdout) return;
      let mode = stdout;
      const match = /([A-Za-z0-9_\-]+)/.exec(stdout);
      if (match) mode = match[1];
      val.textContent = mode;
      let matched = false;
      for (const opt of sel.options){
        if (opt.value === mode){ sel.value = mode; matched = true; break; }
      }
      if (!matched && allowFree){
        sel.value = "__free__";
        if (freeWrap) freeWrap.style.display='block';
        if (freeInput) freeInput.value = mode;
      }
    }catch{}
  })();
}

async function ensureLinkUI(){
  if (!linkUI.help){
    const helpRes = await postExec({path:'/sys/link/help', args:[]}, 400, 'link');
    let helpJson = null;
    try { helpJson = JSON.parse(helpRes.stdout || '{}'); } catch {}
    linkUI.help = helpJson || {commands:[]};
    buildLinkButtonsFromHelp(linkUI.help);
    buildLinkModeSelector(linkUI.help);
  }
  $('#linkStats').textContent = `ready • ${new Date().toLocaleTimeString()}`;
}

async function loadCaps(){
  $('#subtitle').textContent = 'loading caps…';
  try{
    const r = await fetch('/caps', {cache:'no-store'});
    const caps = await r.json();
    $('#dev_device').textContent  = caps.device || '—';
    $('#dev_role').textContent    = caps.role || '—';
    $('#dev_version').textContent = caps.version || '—';
    if (Array.isArray(caps.ifaddrs) && caps.ifaddrs.length){
      $('#dev_if').textContent = caps.ifaddrs.map(i => `${i.if}:${i.ip}`).join('  ');
    } else $('#dev_if').textContent = '—';
    $('#dev_uptime').textContent = caps.uptime_s ? secsToHhMmSs(caps.uptime_s) : '—';
    if (Array.isArray(caps.loadavg)) $('#dev_load').textContent = caps.loadavg.join(' ');
    else $('#dev_load').textContent = '—';
    const capsEl = $('#dev_caps'); capsEl.innerHTML = '';
    const chip = joinCaps(caps.caps);
    if (chip === '—') capsEl.textContent = '—'; else capsEl.appendChild(chip);
    const sseEl = $('#dev_sse'); sseEl.innerHTML = '';
    if (Array.isArray(caps.sse) && caps.sse.length){
      sseEl.innerHTML = caps.sse.map(e => `<a href="${e.url}" target="_blank" rel="noreferrer">${e.name||e.url}</a>`).join('  ');
    } else sseEl.textContent = '—';
    $('#subtitle').textContent = `${caps.device||'device'} ${caps.version?('v'+caps.version):''}`;

    const capList = Array.isArray(caps.caps) ? caps.caps : [];
    const hasExec = capList.includes('exec');
    const hasPixelpilotMiniRk = capList.includes('pixelpilot_mini_rk');

    const deviceCard = document.getElementById('capsCard');
    if (deviceCard){
      deviceCard.style.display = capList.includes('device') ? '' : 'none';
    }

    const deviceActionsRow = document.getElementById('deviceRuntimeActions');
    if (deviceActionsRow){
      deviceActionsRow.style.display = hasPixelpilotMiniRk ? '' : 'none';
    }

    const nodesCard = document.getElementById('nodesCard');
    const nodesEnabled = capList.includes('nodes');
    nodesUI.enabled = nodesEnabled;
    if (nodesCard){
      if (nodesEnabled){
        nodesCard.style.display = '';
        fetchNodes();
      } else {
        nodesCard.style.display = 'none';
        $('#nodesStats').textContent = 'cap missing';
        $('#nodesNotice').textContent = 'cap missing';
        $('#nodesProgress').style.width = '0%';
        $('#nodesGrid').innerHTML = '';
        $('#nodesScanBtn').disabled = true;
        if (nodesPollTimer){
          clearInterval(nodesPollTimer);
          nodesPollTimer = null;
        }
      }
    }

    if (capList.includes('pixelpilot')){
      $('#pixelpilotCard').style.display = '';
      await pixelpilotManager.ensureUI();
    } else {
      $('#pixelpilotCard').style.display = 'none';
      $('#pixelpilotStats').textContent = 'cap missing';
    }

    if (capList.includes('udp_relay')){
      $('#udpRelayCard').style.display = '';
      ensureUdpRelayEmbed();
      await udpRelayManager.ensureUI();
    } else {
      $('#udpRelayCard').style.display = 'none';
      $('#udpRelayStats').textContent = 'cap missing';
    }

    if (hasPixelpilotMiniRk){
      $('#pixelpilotMiniRkCard').style.display = '';
      ensurePixelpilotMiniRkUI();
      const statusEl = document.getElementById('pixelpilotMiniRkStatus');
      if (statusEl && statusEl.textContent === 'cap missing') setMiniRkStatusIdle('Idle');
    } else {
      $('#pixelpilotMiniRkCard').style.display = 'none';
      setMiniRkStatusIdle('cap missing');
    }

    if (capList.includes('link')){
      $('#linkCard').style.display = '';
      await ensureLinkUI();
    } else {
      $('#linkCard').style.display = 'none';
      $('#linkStats').textContent = 'cap missing';
    }

    if (capList.includes('dvr')){
      $('#dvrCard').style.display = '';
      ensureDvrUI(hasExec);
    } else {
      $('#dvrCard').style.display = 'none';
      const statusEl = document.getElementById('dvrStatus');
      const listEl = document.getElementById('dvrList');
      const emptyEl = document.getElementById('dvrEmptyState');
      const msgEl = document.getElementById('dvrMessage');
      if (statusEl) statusEl.textContent = 'cap missing';
      if (listEl) listEl.innerHTML = '';
      if (emptyEl) emptyEl.style.display = 'none';
      if (msgEl){
        msgEl.style.display = 'none';
        msgEl.textContent = '';
        msgEl.classList.remove('ok','err');
      }
    }

    const execCard = document.getElementById('execCard');
    if (execCard){
      execCard.style.display = hasExec ? '' : 'none';
    }

    const remoteExecCard = document.getElementById('remoteExecCard');
    if (remoteExecCard){
      remoteExecCard.style.display = hasExec ? '' : 'none';
    }

  }catch(e){
    $('#subtitle').textContent = 'failed to load /caps';
  }
}

$('#exec_btn').addEventListener('click', doExec);
$('#refreshCaps').addEventListener('click', loadCaps);
$('#exec_args').addEventListener('keydown',e=>{ if(e.key==='Enter') doExec(); });
$('#nodesScanBtn').addEventListener('click', triggerNodesScan);
$('#pixelpilotRefreshBtn').addEventListener('click', ()=> pixelpilotManager.refreshValues());
$('#udpRelayRefreshBtn').addEventListener('click', ()=> udpRelayManager.refreshValues());
$('#udpRelayReloadEmbedBtn').addEventListener('click', reloadUdpRelayEmbed);

const remoteExecTargetInput = $('#remoteExec_targetInput');
if (remoteExecTargetInput){
  if (!remoteExecTargetInput.value){
    remoteExecTargetInput.value = DEFAULT_REMOTE_EXEC_TARGET;
  }
  remoteExecTargetInput.addEventListener('input', updateRemoteExecTargetDisplay);
  remoteExecTargetInput.addEventListener('change', updateRemoteExecTargetDisplay);
  remoteExecTargetInput.addEventListener('keydown', e=>{ if(e.key==='Enter') doRemoteExec(); });
}
updateRemoteExecTargetDisplay();
const remoteExecBtn = $('#remoteExec_btn');
if (remoteExecBtn){
  remoteExecBtn.addEventListener('click', doRemoteExec);
}
const remoteExecArgs = $('#remoteExec_args');
if (remoteExecArgs){
  remoteExecArgs.addEventListener('keydown', e=>{ if(e.key==='Enter') doRemoteExec(); });
}

loadCaps();
fetchNodes();
</script>
