<!doctype html>
<meta charset="utf-8">
<title>autod — ESP32 console</title>
<style>
  /* Inline console theme (from assets/console-theme.css) */
  :root {
    --bg: #e7eef9;
    --fg: #142033;
    --mut: #3f516b;
    --ok: #23853f;
    --err: #b83228;
    --panel: #0f6cd1;
    --card: #ffffff;
    --line: #c5d4ea;
    --scroll-track: #d7e3f5;
    --scroll-thumb: #87a5d5;
    --scroll-thumb-hover: #6b8ac3;
  }

  * {
    box-sizing: border-box;
    min-width: 0;
    scrollbar-width: thin;
    scrollbar-color: var(--scroll-thumb) var(--scroll-track);
  }

  *::-webkit-scrollbar { width: 10px; height: 10px; }
  *::-webkit-scrollbar-track { background: var(--scroll-track); }
  *::-webkit-scrollbar-thumb {
    background: var(--scroll-thumb);
    border-radius: 999px;
    border: 2px solid transparent;
    background-clip: content-box;
  }
  *::-webkit-scrollbar-thumb:hover {
    background: var(--scroll-thumb-hover);
    background-clip: content-box;
  }

  html, body {
    margin: 0;
    height: 100%;
    background: var(--bg);
    color: var(--fg);
    font: 14px/1.4 system-ui, Segoe UI, Roboto, Inter, sans-serif;
    -webkit-tap-highlight-color: transparent;
    overflow-wrap: anywhere;
    word-break: break-word;
    overscroll-behavior: contain;
  }

  main {
    padding: 14px;
    display: grid;
    gap: 12px;
    grid-template-columns: 1fr;
  }

  .card {
    background: var(--card);
    border: 1px solid var(--line);
    border-radius: 14px;
    overflow: hidden;
    box-shadow: 0 10px 28px rgba(13, 55, 109, 0.12);
  }

  .card h2 {
    margin: 0;
    font-size: 14px;
    padding: 0;
    border-bottom: 1px solid var(--line);
  }

  .card .body {
    padding: 12px 14px;
    display: grid;
    gap: 10px;
  }

  .card h2 .card-toggle {
    width: 100%;
    background: transparent;
    border: 0;
    color: inherit;
    font: inherit;
    padding: 14px 16px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    cursor: pointer;
    min-height: 44px;
    text-align: left;
    touch-action: manipulation;
    border-radius: 12px;
  }

  .card h2 .card-toggle:focus-visible {
    outline: 2px solid var(--mut);
    outline-offset: 2px;
    border-radius: 12px;
  }

  .card h2 .card-toggle-label { flex: 1; font-weight: 600; }

  .card h2 .card-toggle-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    border-radius: 999px;
    border: 1px solid #264775;
    background: #154274;
    color: #e9f1fb;
    transition: background 0.2s ease, border-color 0.2s ease;
  }

  .card h2 .card-toggle-icon::before {
    content: "";
    display: inline-block;
    width: 8px;
    height: 8px;
    border-right: 2px solid currentColor;
    border-bottom: 2px solid currentColor;
    transform: rotate(45deg);
    transition: transform 0.2s ease;
  }

  .collapsible-card:not(.collapsed) .card-toggle-icon {
    background: rgba(35, 133, 63, 0.18);
    border-color: rgba(35, 133, 63, 0.5);
  }

  .collapsible-card:not(.collapsed) .card-toggle-icon::before { transform: rotate(-135deg); }

  @media (hover: hover) {
    .card h2 .card-toggle:hover { background: rgba(255, 255, 255, 0.02); }
  }

  .collapsible-card.collapsed > .body { display: none; }
  .collapsible-card > .body[hidden] { display: none !important; }

  .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .row > label { display: flex; align-items: center; gap: 8px; flex: 1 1 180px; }

  input, button, textarea, select {
    background: #fff;
    color: var(--fg);
    border: 1px solid var(--line);
    border-radius: 10px;
    padding: 8px 10px;
    font: inherit;
    max-width: 100%;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
  }

  input[type="text"], input:not([type]) { width: clamp(140px, 100%, 280px); }

  textarea {
    width: 100%;
    min-height: 100px;
    resize: vertical;
    border-radius: 12px;
    white-space: pre-wrap;
    overflow-wrap: anywhere;
    word-break: break-word;
  }

  button { cursor: pointer; }

  code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

  .inline {
    display: block;
    max-width: 100%;
    overflow: auto;
    white-space: pre-wrap;
    overflow-wrap: anywhere;
    word-break: break-word;
    padding: 8px 10px;
    background: #0f1620;
    color: #eaf1fb;
    border: 1px solid #1f3148;
    border-radius: 10px;
  }

  .kv { display: grid; grid-template-columns: minmax(90px, 160px) 1fr; gap: 6px; align-items: center; }

  .pill {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 2px 8px;
    border: 1px solid var(--line);
    border-radius: 999px;
    color: var(--mut);
    font-size: 12px;
  }

  .ok { color: var(--ok); }
  .err { color: var(--err); }

  .grid { display: grid; gap: 8px; }
  .caps { display: flex; flex-wrap: wrap; gap: 6px; }
  .mut { color: var(--mut); }

  .sse a { color: inherit; text-decoration: underline dotted; word-break: break-all; }

  .spacer { flex: 1; }

  :root {
    --page-bg: #e5ecf9;
    --panel-top: #d2e1f8;
    --panel-bottom: #f0f5ff;
    --accent: #1a6adf;
    --accent-strong: #0f56c3;
    --accent-soft: rgba(26, 106, 223, 0.18);
    --border-strong: #b7cbea;
    --shadow-soft: 0 14px 34px rgba(13, 55, 109, 0.16);
  }

  body { margin: 0; background: linear-gradient(180deg, var(--panel-top), var(--panel-bottom)); }
  header {
    position: sticky;
    top: 0;
    z-index: 20;
    padding: 1rem 1.5rem 1.25rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    background: linear-gradient(135deg, #f2f6ff, #deebff 45%, #cddfff);
    color: var(--fg);
    border-bottom: 1px solid var(--border-strong);
    box-shadow: var(--shadow-soft);
  }
  .header-bar { display: flex; justify-content: space-between; align-items: flex-start; gap: 1rem; flex-wrap: wrap; }
  .title-stack { display: flex; flex-direction: column; gap: 0.15rem; }
  .subline { display: flex; align-items: center; gap: 0.5rem; color: var(--mut); font-size: 0.95rem; }
  .connection-note { padding: 0.15rem 0.55rem; border: 1px solid var(--line); border-radius: 999px; font-size: 0.9rem; color: var(--mut); }

  .card-head { display: flex; align-items: flex-start; justify-content: space-between; gap: 10px; flex-wrap: wrap; }
  .card-title-group { display: flex; flex-direction: column; gap: 4px; min-width: 0; }
  .card-title-row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
  .card-subtitle { display: flex; align-items: center; gap: 6px; color: var(--mut); font-size: 14px; }
  .card-actions { display: flex; flex-direction: column; gap: 8px; align-items: flex-end; }
  .badge { display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; border-radius: 999px; border: 1px solid var(--border-strong); background: #e6eeff; color: var(--fg); font-size: 13px; line-height: 1; }
  .badge.status-badge { color: var(--fg); border-color: #afc4e7; background: #d9e7ff; }
  .card-summary { display: none; color: var(--mut); font-size: 14px; padding: 4px 0; }
  .card.card-collapsed .card-summary { display: block; }
  .card.card-collapsed .card-collapsible { display: none; }
  .card-collapsible[hidden] { display: none !important; }
  .toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .toolbar .button, .toolbar button, .toolbar select { min-height: 36px; }
  .toolbar.primary .button, .toolbar.primary button { min-width: 160px; }
  .toolbar .spacer { flex: 1; }
  .optional-card .card-actions { justify-content: flex-end; }
  .optional-card.card-collapsed .card-collapsible { display: none; }
  .button.primary { background: linear-gradient(135deg, var(--accent), var(--accent-strong)); color: #fff; border-color: var(--accent-strong); box-shadow: 0 8px 18px rgba(14,76,149,0.24); }
  .button.primary:hover { background: linear-gradient(135deg, #2a7ff0, #1b6dd8); border-color: #1b6dd8; }
  .button.ghost { background: #f6f9ff; color: var(--fg); border-color: var(--border-strong); }
  .button.ghost:hover { border-color: #9dbbea; background: #eaf1fb; }
  .button.danger { background: rgba(192,57,43,0.12); color: var(--err); border-color: var(--err); }
  .button.danger:hover { background: rgba(192,57,43,0.22); color: #fff; }
  main { padding: 1.5rem; }
  .tabs { display: flex; flex-direction: column; gap: 0.5rem; padding: 0; border-bottom: 1px solid var(--border-strong); }
  .tabs .tab-row { display: flex; column-gap: 0.5rem; row-gap: 0.35rem; flex-wrap: wrap; align-items: center; }
  .tabs button { border: 1px solid var(--border-strong); background: #f6f9ff; color: inherit; padding: 0.5rem 1rem; border-radius: 999px; cursor: pointer; transition: background 120ms ease, border-color 120ms ease, box-shadow 120ms ease; box-shadow: 0 6px 14px rgba(14,76,149,0.08); }
  .tabs button:hover { background: #e7f0ff; border-color: #adc8f0; }
  .tabs button:focus-visible { outline: none; border-color: #9dbbea; box-shadow: 0 0 0 2px rgba(29,115,232,0.2); }
  .tabs button.slot-primary { border: 1px solid var(--ok); color: var(--ok); background: rgba(46,155,75,0.12); box-shadow: 0 0 0 1px rgba(46,155,75,0.2); }
  .tabs button.slot-primary.active { background: var(--accent-strong); color: #fff; box-shadow: none; border-color: var(--accent-strong); }
  .status-pill { background: #e4edff; border: 1px solid var(--border-strong); border-radius: 999px; padding: 0.35rem 0.75rem; font-size: 0.9rem; box-shadow: 0 6px 14px rgba(14,76,149,0.12); }
  .runtime-status-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; align-items: start; }
  .runtime-scan { display: grid; gap: 8px; align-items: start; }
  .runtime-scan .button { justify-content: flex-start; }
  .runtime-pill-stack { display: grid; gap: 6px; }
  .runtime-pill-stack .status-pill { width: 100%; justify-content: flex-start; }
  .runtime-node-block { display: grid; gap: 8px; border: 1px dashed var(--line); border-radius: 12px; padding: 0.85rem 1rem; background: linear-gradient(135deg, rgba(15, 108, 209, 0.06), rgba(15, 108, 209, 0.02)); box-shadow: 0 6px 16px rgba(14, 76, 149, 0.08); }
  .runtime-node-head { display: flex; align-items: center; justify-content: space-between; gap: 0.5rem; flex-wrap: wrap; }
  .runtime-node-title { font-weight: 700; }
  .runtime-node-note { color: var(--mut); font-size: 13px; }
  .tab-panel { display: none; flex-direction: column; gap: 1.5rem; }
  .tab-panel.active { display: flex; }
  :root { --card-pad: 1.1rem 1.25rem; }
  .card h2, .card h3 { margin: 0 0 0.25rem; }
  .card-head, .card-summary, .card > .body { padding: var(--card-pad); }
  .slot-layout { display: grid; gap: 1.5rem; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); }
  .slot-card .body { display: flex; flex-direction: column; gap: 0.75rem; }
  .slot-card > h2,
  .slot-node-card > h3 {
    padding: var(--card-pad);
    border-bottom: 1px solid var(--line);
  }
  .slot-summary-block { display: flex; flex-direction: column; gap: 0.5rem; }
  .slot-summary-head { display: flex; align-items: center; justify-content: space-between; gap: 0.75rem; flex-wrap: wrap; }
  .slot-summary-title { display: flex; align-items: center; gap: 0.4rem; font-size: 1.05rem; }
  .slot-summary-title strong { font-size: 1.1rem; }
  .slot-meta-inline { display: flex; align-items: center; gap: 0.4rem; flex-wrap: wrap; }
  .slot-meta-inline .badge { background: #edf3ff; border-color: var(--border-strong); }
  .slot-meta-inline .badge.critical { border-color: var(--err); color: var(--err); }
  .slot-line { color: var(--mut); }
  .slot-line strong { font-size: 1.05rem; color: var(--fg); }
  .slot-actions { display: flex; flex-direction: column; gap: 0.75rem; border: 1px solid var(--line); border-radius: 12px; padding: 0.75rem; background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(241,246,255,0.9)); box-shadow: 0 8px 18px rgba(14, 76, 149, 0.1); }
  .slot-action-switch { display: inline-flex; align-items: stretch; border: 1px solid var(--line); border-radius: 10px; overflow: hidden; }
  .slot-action-switch button { border: none; background: transparent; color: var(--mut); padding: 0.45rem 0.9rem; cursor: pointer; transition: background 120ms ease, color 120ms ease; font-weight: 600; flex: 1; text-align: center; }
  .slot-action-switch button + button { border-left: 1px solid var(--line); }
  .slot-action-switch button.active { background: rgba(26, 106, 223, 0.12); color: var(--fg); }
  .slot-action-switch button:disabled { cursor: not-allowed; color: rgba(20, 32, 51, 0.35); background: rgba(26, 106, 223, 0.06); }
  .slot-action-panels { width: 100%; }
  .slot-action-panel { display: none; }
  .slot-action-panel.active { display: block; }
  .slot-actions-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 0.75rem 1rem; align-items: end; }
  .slot-actions-grid label { display: flex; flex-direction: column; gap: 0.25rem; font-size: 0.95rem; }
  .slot-actions-grid select { min-height: 38px; }
  .slot-action-row { display: flex; flex-direction: column; gap: 0.35rem; align-items: flex-start; }
  .slot-action-row .mut { line-height: 1.4; }
  .slot-waiting .mut { color: var(--mut); }
  .slot-node-card .body { padding: var(--card-pad); display: flex; flex-direction: column; gap: 0.75rem; }
  .slot-node-empty {
    border: 1px dashed var(--border-strong);
    background: linear-gradient(135deg, rgba(26, 106, 223, 0.12), rgba(26, 106, 223, 0.05));
    border-radius: 12px;
    padding: 0.95rem 1.1rem;
    color: var(--fg);
    display: flex;
    align-items: center;
    gap: 0.6rem;
    box-shadow: 0 8px 18px rgba(14, 76, 149, 0.12);
  }
  .slot-node-empty.loading::before {
    content: '';
    width: 10px;
    height: 10px;
    border-radius: 999px;
    border: 2px solid rgba(26, 115, 232, 0.3);
    border-top-color: transparent;
    display: inline-block;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
  .node-controls { gap: 1rem; }
  .node-help { display: grid; gap: 0.75rem; }
  .node-help-status { color: var(--mut); font-size: 13px; }
  .node-help-menu { display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; }
  .node-help-menu select { min-width: 220px; }
  .node-help-menu button { min-width: 110px; }
  .node-help-advanced { display: flex; align-items: center; gap: 0.5rem; color: var(--mut); font-size: 13px; }
  .node-help-advanced .toggle { margin-left: -4px; }
  .node-help-endpoints { display: flex; flex-wrap: wrap; gap: 6px; font-size: 12px; color: var(--mut); }
  .node-help-endpoints .pill { background: rgba(26, 106, 223, 0.08); border-color: rgba(26, 106, 223, 0.35); }
  .node-help-commands { display: grid; gap: 0.75rem; }
  .node-settings { display: grid; gap: 0.5rem; }
  .node-setting { border: 1px solid var(--line); border-radius: 12px; padding: 0.75rem; display: grid; gap: 0.5rem; background: linear-gradient(135deg, rgba(255,255,255,0.93), rgba(246,250,255,0.9)); }
  .node-setting-head { display: flex; justify-content: space-between; gap: 0.5rem; align-items: flex-start; }
  .node-setting-name { font-weight: 700; }
  .node-setting-desc { color: var(--mut); font-size: 13px; }
  .node-setting-actions { display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; }
  .node-setting-status { font-size: 12px; color: var(--mut); }
  .node-command { border: 1px solid var(--line); border-radius: 12px; padding: 0.75rem; display: grid; gap: 0.5rem; background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(241,246,255,0.9)); }
  .node-command-head { display: flex; justify-content: space-between; gap: 0.5rem; align-items: flex-start; }
  .node-command-name { font-weight: 700; }
  .node-command-path { font-size: 12px; color: var(--mut); word-break: break-all; }
  .node-arg { display: grid; gap: 0.35rem; font-size: 0.95rem; }
  .node-arg small { color: var(--mut); line-height: 1.3; }
  .node-arg-meta { display: flex; gap: 0.5rem; align-items: center; font-size: 12px; color: var(--mut); flex-wrap: wrap; }
  .node-arg-meta .pill { font-size: 11px; }
  .node-command-actions { display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; }
  .node-command-status { font-size: 12px; color: var(--mut); }
  .node-help-output { width: 100%; min-height: 120px; }
  .node-slider { display: grid; gap: 0.35rem; }
  .node-slider-value { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; color: var(--mut); }
  .node-setting-auto { font-size: 12px; color: var(--mut); }
  .toggle {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    user-select: none;
    position: relative;
  }
  .toggle-input {
    position: absolute;
    opacity: 0;
    width: 1px;
    height: 1px;
  }
  .toggle-track {
    width: 46px;
    height: 26px;
    background: linear-gradient(180deg, #dfe8f5, #ccd9ed);
    border-radius: 999px;
    border: 1px solid var(--line);
    position: relative;
    transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.7);
  }
  .toggle-thumb {
    position: absolute;
    top: 3px;
    left: 3px;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #fff;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
  }
  .toggle-input:checked + .toggle-track {
    background: linear-gradient(135deg, rgba(28,132,247,0.15), rgba(35,133,63,0.18));
    border-color: rgba(35, 133, 63, 0.6);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.8);
  }
  .toggle-input:checked + .toggle-track .toggle-thumb {
    transform: translateX(20px);
    background: #2b8540;
    box-shadow: 0 2px 6px rgba(43,133,64,0.35);
  }
  .toggle-input:focus-visible + .toggle-track {
    outline: 2px solid var(--mut);
    outline-offset: 2px;
  }
  textarea { font-family: "SFMono-Regular", Consolas, "Liberation Mono", monospace; }

  /* Inline VRX styles */
  .joy-row { align-items: center; }
  .joy-row .mut { font-size: 12px; }
  #joystickEndpoint { word-break: break-all; }
  .joy-grid { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); justify-items: stretch; }
  .joy-item { background: #0f1620; color: #e6effb; border: 1px solid #1f3148; border-radius: 12px; padding: 12px; display: grid; gap: 10px; justify-items: center; transition: border-color 0.2s ease, box-shadow 0.2s ease; min-width: 0; box-shadow: 0 8px 18px rgba(7, 24, 48, 0.4); }
  .joy-item .joy-idx { color: #b7c6df; font-size: 12px; letter-spacing: 0.08em; text-transform: uppercase; text-align: center; }
  .joy-bar { position: relative; width: 20px; height: 120px; border-radius: 10px; border: 1px solid rgba(154, 161, 166, 0.35); background: linear-gradient(180deg, rgba(54, 194, 117, 0.08), rgba(54, 194, 117, 0.02)); overflow: hidden; }
  .joy-bar::after { content: ""; position: absolute; inset: 0; border-radius: 10px; border: 1px solid rgba(11, 13, 16, 0.45); pointer-events: none; }
  .joy-bar-fill { position: absolute; left: 0; right: 0; bottom: 0; height: 0%; background: linear-gradient(180deg, var(--ok), #1a7d45); transition: height 0.2s ease; }
  .joy-values { display: grid; gap: 2px; justify-items: center; width: 100%; text-align: center; font-size: 12px; }
  .joy-values > div { display: flex; align-items: center; justify-content: center; width: 100%; white-space: nowrap; }
  .joy-item .joy-val { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-weight: 600; font-size: 12px; font-variant-numeric: tabular-nums; }
  .joy-item .joy-raw { color: #b7c6df; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 10px; font-variant-numeric: tabular-nums; }
  .joy-item.joy-bump { border-color: rgba(54, 194, 117, 0.45); box-shadow: 0 0 0 1px rgba(54, 194, 117, 0.25); }
  .joy-meta { display: grid; gap: 4px; justify-items: center; width: 100%; text-align: center; font-size: 11px; color: #c6d2e8; margin-top: 4px; }
  .joy-meta-map { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-weight: 600; font-size: 12px; color: #f0f4fb; }
  .joy-meta-map.joy-meta-map-unmapped { color: var(--err); }
  .joy-meta-tags { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; }
  .joy-meta-tag { font-size: 10px; cursor: pointer; transition: color 0.2s ease, border-color 0.2s ease, background 0.2s ease; }
  .joy-meta-tag[aria-disabled="true"] { cursor: not-allowed; opacity: 0.55; }
  .joy-meta-tag-normal { color: #c6d2e8; border-color: #2b4160; background: rgba(255, 255, 255, 0.05); }
  .joy-meta-tag-invert { color: var(--err); border-color: rgba(255, 107, 107, 0.45); background: rgba(255, 107, 107, 0.15); }
  .joy-meta-dead { font-size: 11px; color: #b7c6df; }
  .joy-meta-dead.joy-meta-dead-active { color: #f0f4fb; }
  .joy-controls { display: grid; gap: 6px; justify-items: center; width: 100%; }
  .joy-move { display: flex; gap: 6px; }
  .joy-move-btn { padding: 4px 8px; font-size: 11px; line-height: 1; border-radius: 999px; background: rgba(255, 255, 255, 0.02); border: 1px solid var(--line); color: var(--fg); min-width: 0; }
  .joy-move-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .joy-move-btn:not(:disabled):hover { background: rgba(255, 255, 255, 0.05); }
  .joy-deadband-control { display: grid; gap: 4px; width: 100%; font-size: 10px; color: var(--mut); justify-items: center; }
  .joy-deadband-slider { width: 100%; }
  .joy-item.joy-item-inverted { border-color: rgba(255, 107, 107, 0.35); }
  .joy-item.joy-item-unmapped .joy-meta-map { color: var(--err); }

  .dvr-body { display: grid; grid-template-rows: auto 1fr; gap: 10px; height: 360px; min-height: 0; }
  .dvr-scroll { display: grid; gap: 6px; overflow: auto; padding-right: 4px; min-height: 0; }
  .dvr-list { display: grid; gap: 6px; }
  .dvr-item {
    display: grid;
    gap: 4px;
    padding: 12px 14px;
    border: 1px solid var(--line);
    border-radius: 12px;
    background: linear-gradient(135deg, rgba(15, 108, 209, 0.06), rgba(15, 108, 209, 0.02));
    box-shadow: 0 6px 16px rgba(14, 76, 149, 0.08);
  }
  .dvr-item a { color: inherit; text-decoration: none; font-weight: 600; word-break: break-all; }
  .dvr-item a:hover { text-decoration: underline; }
  .dvr-meta { color: var(--mut); font-size: 12px; }
  .dvr-message { font-size: 12px; }
  .dvr-message.ok { color: var(--ok); }
  .dvr-message.err { color: var(--err); }
  .dvr-empty {
    color: var(--mut);
    font-size: 12px;
    padding: 10px 12px;
    border: 1px dashed var(--line);
    border-radius: 10px;
    background: linear-gradient(135deg, rgba(15, 108, 209, 0.04), rgba(15, 108, 209, 0.015));
  }

  .logs-body { display: grid; gap: 10px; }
  .logs-toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .logs-toolbar label { display: flex; flex-direction: column; gap: 4px; min-width: 220px; }
  .logs-toolbar select { min-height: 38px; }
  .logs-view { display: grid; gap: 10px; border: 1px solid var(--line); border-radius: 12px; padding: 12px 14px; background: linear-gradient(135deg, rgba(15, 108, 209, 0.05), rgba(15, 108, 209, 0.015)); box-shadow: 0 6px 16px rgba(14, 76, 149, 0.08); max-height: 320px; overflow: auto; }
  .logs-list { display: grid; gap: 8px; }
  .logs-empty { color: var(--mut); font-size: 12px; }
  .log-entry { display: grid; gap: 6px; padding: 10px 12px; border: 1px solid var(--line); border-radius: 10px; background: linear-gradient(135deg, rgba(15, 108, 209, 0.06), rgba(15, 108, 209, 0.02)); box-shadow: 0 4px 12px rgba(14, 76, 149, 0.08); }
  .log-meta { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; font-size: 12px; color: var(--mut); }
  .log-meta .pill { font-size: 11px; }
  .log-text { margin: 0; background: #0f1620; color: #eaf1fb; border: 1px solid #1f3148; border-radius: 8px; padding: 8px 10px; white-space: pre-wrap; word-break: break-word; }

  .nodes-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap: 10px; }
  .node {
    border: 1px solid var(--line);
    background: linear-gradient(145deg, rgba(15, 108, 209, 0.05), rgba(15, 108, 209, 0.02));
    border-radius: 12px;
    padding: 12px 14px;
    display: grid;
    gap: 8px;
    box-shadow: 0 6px 16px rgba(14, 76, 149, 0.08);
  }
  .node .top { display: flex; align-items: center; justify-content: space-between; gap: 6px; }
  .node .ip { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color: var(--mut); }
  .node .meta { font-size: 12px; color: var(--mut); }
  .node .role { border-color: #2d333b; }
  .node-head { cursor: pointer; display: grid; gap: 6px; position: relative; padding-right: 16px; }
  .node-head::after { content: '\25B8'; position: absolute; right: 0; top: 12px; font-size: 12px; color: var(--mut); transition: transform 0.2s ease; }
  .node.expanded .node-head::after { transform: rotate(90deg); }
  .node-head:focus-visible { outline: 2px solid var(--mut); outline-offset: 2px; border-radius: 10px; }
  .node-controls { display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--line); gap: 10px; }
  .node.expanded .node-controls { display: grid; }
  .node-control-toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .node-control-toolbar .spacer { flex: 1; }
  .node-control-stats { font-size: 12px; color: var(--mut); }
  .node-target { font-size: 12px; color: var(--mut); }
  .progress { height: 10px; border: 1px solid var(--line); border-radius: 999px; overflow: hidden; background: rgba(15, 108, 209, 0.06); }
  .progress > div { height: 100%; background: linear-gradient(90deg, var(--ok), #64d38f); width: 0%; }
  .nodes-toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .nodes-toolbar .mut { font-size: 12px; }
  .nodes-stats { display: flex; flex-wrap: wrap; gap: 8px; font-size: 12px; color: var(--mut); }

  .mini-rk-body { display: grid; gap: 12px; }
  .mini-rk-section {
    display: grid;
    gap: 10px;
    padding: 12px 14px;
    border: 1px solid var(--line);
    border-radius: 12px;
    background: linear-gradient(145deg, rgba(15, 108, 209, 0.06), rgba(15, 108, 209, 0.02));
    box-shadow: 0 6px 16px rgba(14, 76, 149, 0.08);
  }
  .mini-rk-section-head { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
  .mini-rk-section-title { font-weight: 700; }
  .mini-rk-section-note { font-size: 12px; color: var(--mut); }
  .mini-rk-button-stack { display: grid; gap: 8px; }
  .mini-rk-button-stack button { width: 100%; justify-content: center; }
  .mini-rk-gamma-grid { display: grid; gap: 8px; }
  .mini-rk-field { display: grid; gap: 4px; font-weight: 600; font-size: 13px; color: var(--fg); }
  .mini-rk-field select { margin-top: 2px; width: 100%; }
  .mini-rk-gamma-actions { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .mini-rk-gamma-actions .mut { flex: 1 1 100%; }

  .ctl {
    display: grid;
    gap: 8px;
    padding: 12px 14px;
    border: 1px solid var(--line);
    border-radius: 12px;
    background: linear-gradient(145deg, rgba(15, 108, 209, 0.05), rgba(15, 108, 209, 0.02));
    box-shadow: 0 6px 16px rgba(14, 76, 149, 0.08);
  }
  .ctl .lbl { display: flex; justify-content: space-between; gap: 8px; align-items: center; }
  .ctl .lbl .name { font-weight: 600; }
  .ctl .lbl .val { color: var(--mut); font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; transition: color 0.35s ease; }
  .ctl .desc { color: var(--mut); font-size: 12px; }
  .ctl .errtxt { color: var(--err); font-size: 12px; }
  .switch { position: relative; width: 46px; height: 26px; }
  .switch input { appearance: none; width: 46px; height: 26px; background: #12161a; border: 1px solid var(--line); border-radius: 999px; outline: none; transition: 0.15s; display: block; }
  .switch input:checked { background: #1b2d22; border-color: #254a35; }
  .switch input::after { content: ""; position: absolute; top: 3px; left: 3px; width: 20px; height: 20px; border-radius: 50%; background: #cfd6dd; transition: 0.15s; }
  .switch input:checked::after { left: 23px; background: #e8f6ee; }

  .embed-wrap { border: 1px solid var(--line); border-radius: 12px; overflow: hidden; background: #0f1317; min-height: 320px; display: grid; gap: 0; }
  .embed-frame { width: 100%; min-height: 320px; border: 0; background: #0f1317; }
  .embed-note { padding: 10px 12px; font-size: 12px; }

  .mini-status { display: flex; justify-content: flex-end; align-items: center; min-height: 26px; }
  .status-indicator { display: inline-flex; align-items: center; gap: 6px; font-size: 12px; padding: 2px 10px; border-radius: 999px; border: 1px solid var(--line); color: var(--mut); background: #0f1317; transition: color 0.3s ease, border-color 0.3s ease, background 0.3s ease; }
  .status-indicator::before { content: ""; width: 8px; height: 8px; border-radius: 50%; background: var(--mut); transition: background 0.3s ease; }
  .status-indicator.running { color: var(--mut); }
  .status-indicator.running::before { background: var(--mut); }
  .status-indicator.ok { color: var(--ok); border-color: rgba(54, 194, 117, 0.4); background: rgba(54, 194, 117, 0.08); }
  .status-indicator.ok::before { background: var(--ok); }
  .status-indicator.err { color: var(--err); border-color: rgba(255, 107, 107, 0.4); background: rgba(255, 107, 107, 0.08); }
  .status-indicator.err::before { background: var(--err); }
  .status-indicator.flash { animation: statusBlink 0.7s ease-out; }
  .status-indicator.err.flash { animation: statusBlinkErr 0.7s ease-out; }
  @keyframes statusBlink { 0% { box-shadow: 0 0 0 0 rgba(54, 194, 117, 0.35); } 100% { box-shadow: 0 0 0 10px rgba(54, 194, 117, 0); } }
  @keyframes statusBlinkErr { 0% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.35); } 100% { box-shadow: 0 0 0 10px rgba(255, 107, 107, 0); } }
  @media (prefers-reduced-motion: reduce) {
    .status-indicator.flash, .status-indicator.err.flash { animation: none; }
  }
  .ctl.flash-ok { border-color: rgba(54, 194, 117, 0.4); box-shadow: 0 0 0 1px rgba(54, 194, 117, 0.3); }
  .ctl.flash-err { border-color: rgba(255, 107, 107, 0.45); box-shadow: 0 0 0 1px rgba(255, 107, 107, 0.3); }

  .udp-viewport { display: grid; gap: 6px; }
  .udp-screen { position: relative; width: 100%; aspect-ratio: 16/9; border: 1px solid var(--line); border-radius: 12px; overflow: hidden; cursor: crosshair; }
  .udp-screen-image { position: absolute; inset: 0; background-color: #0f1317; pointer-events: none; overflow: hidden; }
  .udp-screen-image::after { content: ""; position: absolute; inset: 0; background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0)); pointer-events: none; }
  .udp-screen-image img { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity 0.25s ease; }
  .udp-screen-image img[data-active="true"] { opacity: 1; }
  .udp-screen::after { content: ""; position: absolute; inset: 0; border: 1px dashed rgba(154, 161, 166, 0.25); pointer-events: none; }
  .udp-roi { position: absolute; border: 2px solid rgba(54, 194, 117, 0.8); background: rgba(54, 194, 117, 0.18); border-radius: 10px; box-shadow: 0 0 0 1px rgba(54, 194, 117, 0.45); min-width: 0; min-height: 0; transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease; }
  .udp-screen-hint { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); padding: 8px 12px; border-radius: 999px; border: 1px solid var(--line); background: rgba(15, 19, 23, 0.8); font-size: 12px; color: var(--mut); pointer-events: none; transition: opacity 0.2s ease, visibility 0.2s ease; }
  .udp-screen-hint.hidden { opacity: 0; visibility: hidden; }
  .udp-roi-meta { display: grid; gap: 4px; font-size: 12px; color: var(--mut); }
  .udp-roi-meta strong { color: var(--fg); }
  .udp-roi-meta .udp-value { color: var(--fg); font-weight: 600; }

  :root { --udp-embed-height: 800px; }
  #card-udp-relay #udpRelayEmbedContainer.embed-wrap { height: auto; min-height: 0; }
  #card-udp-relay #udpRelayEmbedContainer .embed-frame { display: block; width: 100%; height: var(--udp-embed-height) !important; border: 0; }
  #card-udp-relay .embed-note { margin-top: 8px; }

  .sync-body { gap: 12px; }
  .sync-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 10px; }
  .sync-slot { border: 1px solid var(--line); border-radius: 12px; padding: 12px; background: #0f1317; display: grid; gap: 8px; }
  .sync-slot-head { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; justify-content: space-between; }
  .sync-slot-title { font-weight: 600; }
  .sync-slot-label { font-size: 12px; color: var(--mut); }
  .sync-slot-gen { font-size: 12px; color: var(--mut); }
  .sync-slot-id { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-weight: 600; word-break: break-all; }
  .sync-slot-meta { font-size: 12px; color: var(--mut); }
  .sync-slot-last { font-size: 12px; color: var(--mut); }
  .sync-slot-actions { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .sync-slot-empty { color: var(--mut); font-size: 12px; }
  .sync-slot-prefer { font-size: 12px; color: var(--mut); margin-top: 4px; }
  .sync-slot-prefer[data-status="matched"] { color: #34d399; }
  .sync-slot-prefer[data-status="waiting"] { color: #f97316; }
  .sync-slot-prefer[data-status="open"] { color: #93c5fd; }
  .sync-move-select { min-width: 140px; }
  .sync-slot-replay { font-size: 12px; padding: 4px 8px; }
  .sync-delete-btn { font-size: 12px; padding: 4px 8px; background: #2a1717; color: #fff; border: 1px solid rgba(255, 107, 107, 0.4); border-radius: 6px; }
  .sync-delete-btn:disabled { opacity: 0.6; }
  .sync-waiting { display: grid; gap: 8px; }
  .sync-waiting-entry { border: 1px dashed var(--line); border-radius: 10px; padding: 10px; display: grid; gap: 6px; }
  .sync-pending { border: 1px solid var(--line); border-radius: 10px; padding: 10px; display: grid; gap: 6px; }
  .sync-pending ul { list-style: none; margin: 0; padding: 0; display: grid; gap: 4px; font-size: 12px; }
  .sync-pending li { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
  .sync-remove-pending { font-size: 11px; padding: 2px 6px; }

  @media (max-width: 960px){
    header { flex-direction: column; align-items: stretch; gap: 0.75rem; padding: 1rem 1rem 1.25rem; }
    .tab-row { width: 100%; }
    .tabs { padding: 0; }
    .tabs .tab-row { flex-direction: column; align-items: stretch; }
    .tabs button { width: 100%; text-align: center; }
    .slot-actions, .slot-waiting { flex-direction: column; align-items: stretch; }
    .slot-actions button, .slot-waiting button, .slot-actions select, .slot-waiting select { width: 100%; }
    .slot-actions label, .slot-waiting label { width: 100%; }
    .slot-action-switch { width: 100%; }
    .slot-action-switch button { flex: 1; justify-content: center; }
    .slot-actions-grid { grid-template-columns: 1fr; }
    .node-help-menu { flex-direction: column; align-items: stretch; }
    .node-help-menu select, .node-help-menu button { width: 100%; }
    header { padding-bottom: 0.5rem; }
  }
</style>

<header>
  <div class="header-bar">
    <div class="title-stack">
      <div class="title">autod — ESP32 console</div>
      <div class="subline">
        <span class="sub" id="subtitle">nodes + sync overview</span>
        <span class="connection-note" id="headerStatus">Waiting for /caps…</span>
      </div>
    </div>
  </div>
  <div class="tabs" role="tablist">
    <div class="tab-row">
      <button class="active" data-tab="groundstation" aria-controls="panel-groundstation" title="Groundstation overview">Groundstation</button>
      <button data-tab="slot1" aria-controls="panel-slot1" class="slot-primary" title="Slot 1 slave assignment">Slot 1</button>
      <button data-tab="slot2" aria-controls="panel-slot2" title="Slot 2 slave assignment">Slot 2</button>
      <button data-tab="slot3" aria-controls="panel-slot3" title="Slot 3 slave assignment">Slot 3</button>
      <button data-tab="slot4" aria-controls="panel-slot4" title="Slot 4 slave assignment">Slot 4</button>
    </div>
  </div>
</header>

<main>
  <section class="tab-panel active" data-panel="groundstation" id="panel-groundstation">
    <section class="card" id="capsCard">
      <div class="card-head">
        <div class="card-title-group">
          <div class="card-title-row">
            <h2>Device & runtime</h2>
          </div>
          <div class="card-subtitle">
            <span>Runtime status</span>
            <span class="badge" id="capsStatus">waiting…</span>
          </div>
        </div>
        <div class="card-actions">
          <div class="toolbar primary">
            <button class="button primary" id="capsRefreshBtn">Refresh /caps</button>
          </div>
        </div>
      </div>
      <div class="body grid">
        <div class="runtime-status-grid">
          <div class="runtime-scan">
            <button class="button danger" id="nodesScanBtn">POST /nodes (scan)</button>
            <div class="runtime-pill-stack">
              <div class="status-pill" id="nodesSummary">Nodes: waiting…</div>
              <div class="status-pill" id="syncSummary">Sync: waiting…</div>
            </div>
          </div>
        </div>
        <div class="kv"><div class="mut">Device</div><div id="dev_device">—</div></div>
        <div class="kv"><div class="mut">Role</div><div id="dev_role">—</div></div>
        <div class="kv"><div class="mut">Version</div><div id="dev_version">—</div></div>
        <div class="kv"><div class="mut">Interfaces</div><div id="dev_if">—</div></div>
        <div class="kv"><div class="mut">Uptime</div><div id="dev_uptime">—</div></div>
        <div class="kv"><div class="mut">Loadavg</div><div id="dev_load">—</div></div>
        <div class="kv"><div class="mut">Capabilities</div><div class="caps" id="dev_caps">—</div></div>
        <div class="kv"><div class="mut">SSE</div><div class="sse" id="dev_sse">—</div></div>
        <div class="runtime-node-block">
          <div class="runtime-node-head">
            <div class="runtime-node-title">Browser node</div>
            <div class="runtime-node-note">Browse /sys help directly from this UI</div>
          </div>
          <div class="nodes-grid" id="browserNodeContainer">
            <div class="slot-node-empty">Waiting for /caps…</div>
          </div>
        </div>
        <div class="toolbar" id="deviceRuntimeActions" style="display:none">
          <button id="pixelpilotMiniRkRebootBtn">Reboot device</button>
          <button id="pixelpilotMiniRkShutdownBtn">Shutdown device</button>
        </div>
      </div>
    </section>

    <section class="card card-collapsed optional-card" id="logsCard">
      <div class="card-head">
        <div class="card-title-group">
          <div class="card-title-row">
            <h2>Logs</h2>
          </div>
          <div class="card-subtitle">
            <span>Live SSE feed</span>
            <span class="badge" id="logsStatus">waiting…</span>
          </div>
        </div>
        <div class="card-actions">
          <div class="toolbar">
            <button class="button ghost" type="button" id="logsToggle" data-card-toggle aria-expanded="false">Show details</button>
            <button class="button primary" id="logsConnectBtn">Connect</button>
            <button class="button ghost" id="logsDisconnectBtn">Disconnect</button>
          </div>
        </div>
      </div>
      <div class="card-summary" id="logsSummary" data-card-summary>Waiting for /caps…</div>
      <div class="body logs-body card-collapsible" data-card-body hidden>
        <div class="logs-toolbar">
          <label>Endpoint
            <select id="logsEndpointSelect" aria-label="SSE endpoint"></select>
          </label>
          <div class="spacer"></div>
        </div>
        <div class="logs-view" aria-live="polite">
          <div id="logsEmptyState" class="logs-empty">Select an endpoint and connect to stream logs.</div>
          <div id="logsList" class="logs-list"></div>
        </div>
      </div>
    </section>

    <section class="card card-collapsed optional-card" id="pixelpilotMiniRkCard">
      <div class="card-head">
        <div class="card-title-group">
          <div class="card-title-row">
            <h2>Pixelpilot Mini RK</h2>
          </div>
          <div class="card-subtitle">
            <span>Service status</span>
            <span class="badge status-badge status-indicator" id="pixelpilotMiniRkStatus" aria-live="polite">waiting…</span>
          </div>
        </div>
        <div class="card-actions">
          <div class="toolbar">
            <button class="button ghost" type="button" id="pixelpilotMiniRkToggle" data-card-toggle aria-expanded="false">Show details</button>
            <button class="button primary" id="pixelpilotMiniRkToggleRecordingBtn">Toggle Recording</button>
          </div>
        </div>
      </div>
      <div class="card-summary" id="pixelpilotMiniRkSummary" data-card-summary>Waiting for capabilities…</div>
      <div class="body mini-rk-body card-collapsible" data-card-body hidden>
        <div class="mini-rk-section">
          <div class="mini-rk-section-head">
            <div class="mini-rk-section-title">Service controls</div>
            <div class="mini-rk-section-note">Manage overlay and service state.</div>
          </div>
          <div class="mini-rk-button-stack" id="pixelpilotMiniRkActions">
            <button id="pixelpilotMiniRkToggleOsdBtn">Toggle OSD</button>
            <button id="pixelpilotMiniRkRestartServiceBtn">Restart pixelpilot_mini_rk</button>
            <button id="pixelpilotMiniRkStopServiceBtn">Stop pixelpilot_mini_rk</button>
            <button id="pixelpilotMiniRkStartServiceBtn">Start pixelpilot_mini_rk</button>
          </div>
        </div>
        <div class="mini-rk-section mini-rk-gamma-section">
          <div class="mini-rk-section-head">
            <div class="mini-rk-section-title">Gamma preset</div>
            <div class="mini-rk-section-note mut" id="pixelpilotMiniRkGammaNotice">Loading presets…</div>
          </div>
          <div class="mini-rk-gamma-grid">
            <label class="mini-rk-field" for="pixelpilotMiniRkGammaSelect">Select preset
              <select id="pixelpilotMiniRkGammaSelect" disabled>
                <option>Loading presets…</option>
              </select>
            </label>
            <div class="mini-rk-gamma-actions">
              <button id="pixelpilotMiniRkApplyGammaBtn" type="button" disabled>Apply preset</button>
              <button id="pixelpilotMiniRkReloadGammaBtn" type="button">Reload presets</button>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="card card-collapsed optional-card" id="dvrCard">
      <div class="card-head">
        <div class="card-title-group">
          <div class="card-title-row">
            <h2>DVR recordings</h2>
          </div>
          <div class="card-subtitle">
            <span>Recording status</span>
            <span class="badge" id="dvrStatus">waiting…</span>
          </div>
        </div>
        <div class="card-actions">
          <div class="toolbar">
            <button class="button ghost" type="button" id="dvrToggle" data-card-toggle aria-expanded="false">Show details</button>
            <button class="button primary" id="dvrRefreshBtn">Refresh list</button>
          </div>
        </div>
      </div>
      <div class="card-summary" id="dvrSummary" data-card-summary>Waiting for capabilities…</div>
      <div class="body grid dvr-body card-collapsible" data-card-body hidden>
        <div class="toolbar">
          <button id="dvrDeleteAllBtn">Delete all</button>
          <div class="spacer"></div>
        </div>
        <div class="dvr-scroll">
          <div id="dvrMessage" class="dvr-message" style="display:none"></div>
          <div id="dvrEmptyState" class="dvr-empty" style="display:none">No recordings found.</div>
          <div id="dvrList" class="dvr-list"></div>
        </div>
      </div>
    </section>
  </section>

  <section class="tab-panel" data-panel="slot1" id="panel-slot1">
    <div class="slot-layout" data-slot="1">
      <section class="card slot-card">
        <h2>Slot 1</h2>
        <div class="body">
          <div class="slot-summary-block">
            <div class="slot-summary-head">
              <div class="slot-summary-title">
                <strong id="slot1Summary">No slave assigned.</strong>
              </div>
              <div class="slot-meta-inline">
                <span class="badge" id="slot1LastSeen">Last seen —</span>
              </div>
            </div>
            <div class="slot-line" id="slot1Meta">—</div>
            <div class="slot-line" id="slot1SlotMeta">Slot config: —</div>
          </div>
          <div class="slot-actions" data-slot="1">
            <div class="slot-action-switch" role="group" aria-label="Slot 1 actions">
              <button type="button" class="active" data-slot-action="assign">Assign</button>
              <button type="button" data-slot-action="move">Move</button>
              <button type="button" data-slot-action="replay">Replay</button>
            </div>
            <div class="slot-action-panels">
              <div class="slot-action-panel slot-waiting active" data-slot-panel="assign">
                <div class="slot-actions-grid">
                  <label>Assign waiting slave
                    <select id="slot1AssignSelect" class="slot-assign-select"></select>
                  </label>
                  <div class="slot-action-row">
                    <button type="button" class="slot-assign-btn" data-slot="1">Assign to slot 1</button>
                    <div class="mut" id="slot1WaitingSummary">Waiting: —</div>
                  </div>
                </div>
              </div>
              <div class="slot-action-panel" data-slot-panel="move">
                <div class="slot-actions-grid">
                  <label>Move assignment
                    <select id="slot1MoveSelect" class="slot-move-select"></select>
                  </label>
                  <div class="slot-action-row">
                    <button type="button" class="slot-move-btn" data-slot="1">Send move</button>
                    <div class="mut">Move or unassign the current slave.</div>
                  </div>
                </div>
              </div>
              <div class="slot-action-panel" data-slot-panel="replay">
                <div class="slot-actions-grid">
                  <div class="slot-action-row">
                    <button type="button" class="slot-replay-btn" data-slot="1">Replay commands</button>
                    <div class="mut">Re-send the latest slot commands to this slave.</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
      <section class="card slot-node-card">
        <h3>Node & relay</h3>
        <div class="body" id="slot1NodeContainer">
          <div class="slot-node-empty">Waiting for slot assignment.</div>
        </div>
      </section>
    </div>
  </section>

  <section class="tab-panel" data-panel="slot2" id="panel-slot2">
    <div class="slot-layout" data-slot="2">
      <section class="card slot-card">
        <h2>Slot 2</h2>
        <div class="body">
          <div class="slot-summary-block">
            <div class="slot-summary-head">
              <div class="slot-summary-title">
                <strong id="slot2Summary">No slave assigned.</strong>
              </div>
              <div class="slot-meta-inline">
                <span class="badge" id="slot2LastSeen">Last seen —</span>
              </div>
            </div>
            <div class="slot-line" id="slot2Meta">—</div>
            <div class="slot-line" id="slot2SlotMeta">Slot config: —</div>
          </div>
          <div class="slot-actions" data-slot="2">
            <div class="slot-action-switch" role="group" aria-label="Slot 2 actions">
              <button type="button" class="active" data-slot-action="assign">Assign</button>
              <button type="button" data-slot-action="move">Move</button>
              <button type="button" data-slot-action="replay">Replay</button>
            </div>
            <div class="slot-action-panels">
              <div class="slot-action-panel slot-waiting active" data-slot-panel="assign">
                <div class="slot-actions-grid">
                  <label>Assign waiting slave
                    <select id="slot2AssignSelect" class="slot-assign-select"></select>
                  </label>
                  <div class="slot-action-row">
                    <button type="button" class="slot-assign-btn" data-slot="2">Assign to slot 2</button>
                    <div class="mut" id="slot2WaitingSummary">Waiting: —</div>
                  </div>
                </div>
              </div>
              <div class="slot-action-panel" data-slot-panel="move">
                <div class="slot-actions-grid">
                  <label>Move assignment
                    <select id="slot2MoveSelect" class="slot-move-select"></select>
                  </label>
                  <div class="slot-action-row">
                    <button type="button" class="slot-move-btn" data-slot="2">Send move</button>
                    <div class="mut">Move or unassign the current slave.</div>
                  </div>
                </div>
              </div>
              <div class="slot-action-panel" data-slot-panel="replay">
                <div class="slot-actions-grid">
                  <div class="slot-action-row">
                    <button type="button" class="slot-replay-btn" data-slot="2">Replay commands</button>
                    <div class="mut">Re-send the latest slot commands to this slave.</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
      <section class="card slot-node-card">
        <h3>Node & relay</h3>
        <div class="body" id="slot2NodeContainer">
          <div class="slot-node-empty">Waiting for slot assignment.</div>
        </div>
      </section>
    </div>
  </section>

  <section class="tab-panel" data-panel="slot3" id="panel-slot3">
    <div class="slot-layout" data-slot="3">
      <section class="card slot-card">
        <h2>Slot 3</h2>
        <div class="body">
          <div class="slot-summary-block">
            <div class="slot-summary-head">
              <div class="slot-summary-title">
                <strong id="slot3Summary">No slave assigned.</strong>
              </div>
              <div class="slot-meta-inline">
                <span class="badge" id="slot3LastSeen">Last seen —</span>
              </div>
            </div>
            <div class="slot-line" id="slot3Meta">—</div>
            <div class="slot-line" id="slot3SlotMeta">Slot config: —</div>
          </div>
          <div class="slot-actions" data-slot="3">
            <div class="slot-action-switch" role="group" aria-label="Slot 3 actions">
              <button type="button" class="active" data-slot-action="assign">Assign</button>
              <button type="button" data-slot-action="move">Move</button>
              <button type="button" data-slot-action="replay">Replay</button>
            </div>
            <div class="slot-action-panels">
              <div class="slot-action-panel slot-waiting active" data-slot-panel="assign">
                <div class="slot-actions-grid">
                  <label>Assign waiting slave
                    <select id="slot3AssignSelect" class="slot-assign-select"></select>
                  </label>
                  <div class="slot-action-row">
                    <button type="button" class="slot-assign-btn" data-slot="3">Assign to slot 3</button>
                    <div class="mut" id="slot3WaitingSummary">Waiting: —</div>
                  </div>
                </div>
              </div>
              <div class="slot-action-panel" data-slot-panel="move">
                <div class="slot-actions-grid">
                  <label>Move assignment
                    <select id="slot3MoveSelect" class="slot-move-select"></select>
                  </label>
                  <div class="slot-action-row">
                    <button type="button" class="slot-move-btn" data-slot="3">Send move</button>
                    <div class="mut">Move or unassign the current slave.</div>
                  </div>
                </div>
              </div>
              <div class="slot-action-panel" data-slot-panel="replay">
                <div class="slot-actions-grid">
                  <div class="slot-action-row">
                    <button type="button" class="slot-replay-btn" data-slot="3">Replay commands</button>
                    <div class="mut">Re-send the latest slot commands to this slave.</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
      <section class="card slot-node-card">
        <h3>Node & relay</h3>
        <div class="body" id="slot3NodeContainer">
          <div class="slot-node-empty">Waiting for slot assignment.</div>
        </div>
      </section>
    </div>
  </section>

  <section class="tab-panel" data-panel="slot4" id="panel-slot4">
    <div class="slot-layout" data-slot="4">
      <section class="card slot-card">
        <h2>Slot 4</h2>
        <div class="body">
          <div class="slot-summary-block">
            <div class="slot-summary-head">
              <div class="slot-summary-title">
                <strong id="slot4Summary">No slave assigned.</strong>
              </div>
              <div class="slot-meta-inline">
                <span class="badge" id="slot4LastSeen">Last seen —</span>
              </div>
            </div>
            <div class="slot-line" id="slot4Meta">—</div>
            <div class="slot-line" id="slot4SlotMeta">Slot config: —</div>
          </div>
          <div class="slot-actions" data-slot="4">
            <div class="slot-action-switch" role="group" aria-label="Slot 4 actions">
              <button type="button" class="active" data-slot-action="assign">Assign</button>
              <button type="button" data-slot-action="move">Move</button>
              <button type="button" data-slot-action="replay">Replay</button>
            </div>
            <div class="slot-action-panels">
              <div class="slot-action-panel slot-waiting active" data-slot-panel="assign">
                <div class="slot-actions-grid">
                  <label>Assign waiting slave
                    <select id="slot4AssignSelect" class="slot-assign-select"></select>
                  </label>
                  <div class="slot-action-row">
                    <button type="button" class="slot-assign-btn" data-slot="4">Assign to slot 4</button>
                    <div class="mut" id="slot4WaitingSummary">Waiting: —</div>
                  </div>
                </div>
              </div>
              <div class="slot-action-panel" data-slot-panel="move">
                <div class="slot-actions-grid">
                  <label>Move assignment
                    <select id="slot4MoveSelect" class="slot-move-select"></select>
                  </label>
                  <div class="slot-action-row">
                    <button type="button" class="slot-move-btn" data-slot="4">Send move</button>
                    <div class="mut">Move or unassign the current slave.</div>
                  </div>
                </div>
              </div>
              <div class="slot-action-panel" data-slot-panel="replay">
                <div class="slot-actions-grid">
                  <div class="slot-action-row">
                    <button type="button" class="slot-replay-btn" data-slot="4">Replay commands</button>
                    <div class="mut">Re-send the latest slot commands to this slave.</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
      <section class="card slot-node-card">
        <h3>Node & relay</h3>
        <div class="body" id="slot4NodeContainer">
          <div class="slot-node-empty">Waiting for slot assignment.</div>
        </div>
      </section>
    </div>
  </section>
</main>

<script type="module">
const $ = (sel, root = document) => root.querySelector(sel);
function normalizeNodeRecord(node){
  if (!node || typeof node !== 'object') return null;
  const ip = (node.ip || node.host || '').trim();
  const port = Number.isFinite(node.port) ? Number(node.port) : null;
  return {
    id: node.id ?? null,
    name: node.name ?? null,
    ip,
    port,
    device: node.device ?? null,
    role: node.role ?? null,
    version: node.version ?? null
  };
}
const nodesState = {
  expanded: new Set(),
  pollTimer: null,
  loading: false,
  list: [],
  listSignature: '',
  version: 0,
  scanning: false,
  pendingRefresh: false
};
const nodeHelpState = new Map();
const NODES_POLL_MS = 7000;
const NODES_SCAN_POLL_MS = 1000;
const MAX_SYNC_SLOTS = 4;
const syncState = { slots: Array.from({ length: MAX_SYNC_SLOTS }, () => null), meta: new Map(), waiting: [], refMs: 0, signature: '' };
const syncUiState = { busy: false, pollTimer: null, loading: false, pendingRefresh: false };
const SYNC_POLL_MS = 7000;
const slotActionState = new Map();
const tabState = { active: 'groundstation' };
const DEFAULT_CMD_TIMEOUT_MS = 6000;
const MAX_LOG_ENTRIES = 20;
const LOGS_RECONNECT_DELAY_MS = 1000;
const capsState = { capList: new Set(), hasExec: false, latest: null };
const browserNodeState = { signature: '' };
const dvrState = { initialized: false, hasExec: false, loading: false, enabled: false };
const miniRkState = { initialized: false, gamma: { presets: [], loading: false } };
const logsState = {
  initialized: false,
  endpoints: [],
  source: null,
  controller: null,
  connected: false,
  connecting: false,
  entries: [],
  selectedUrl: '',
  session: 0,
  lastDisconnectAt: 0
};
const slotRenderCache = new Map();

function cardElements(cardId){
  const card = document.getElementById(cardId);
  if (!card) return {};
  return {
    card,
    body: card.querySelector('[data-card-body]'),
    summary: card.querySelector('[data-card-summary]'),
    toggle: card.querySelector('[data-card-toggle]')
  };
}

function setCardCollapsed(cardId, collapsed){
  const { card, body, toggle } = cardElements(cardId);
  if (!card || !body || !toggle) return;
  card.classList.toggle('card-collapsed', collapsed);
  body.hidden = collapsed;
  toggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
  toggle.textContent = collapsed ? 'Show details' : 'Hide details';
}

function setOptionalCardState(cardId, options = {}){
  const { card, summary } = cardElements(cardId);
  if (!card) return;
  const enabled = !!options.enabled;
  card.dataset.enabled = enabled ? 'true' : 'false';
  if (summary && typeof options.summary === 'string') summary.textContent = options.summary;
  setCardCollapsed(cardId, !enabled);
  card.classList.toggle('optional-inactive', !enabled);
}

function initCardToggle(cardId){
  const { card, toggle } = cardElements(cardId);
  if (!card || !toggle) return;
  toggle.addEventListener('click', () => {
    const next = !card.classList.contains('card-collapsed');
    setCardCollapsed(cardId, next);
  });
}

function secsToHhMmSs(value){
  const sec = Number(value);
  if (!Number.isFinite(sec) || sec < 0) return '—';
  const hours = Math.floor(sec / 3600);
  const minutes = Math.floor((sec % 3600) / 60);
  const seconds = Math.floor(sec % 60);
  const pad = num => String(num).padStart(2, '0');
  return `${hours}:${pad(minutes)}:${pad(seconds)}`;
}

function formatInterfaces(list){
  if (!Array.isArray(list) || !list.length) return '—';
  return list.map(entry => `${entry.if || entry.name || 'if'}:${entry.ip || entry.addr || '—'}`).join('  ');
}

function formatLoadavg(list){
  if (!Array.isArray(list) || !list.length) return '—';
  return list.join(' ');
}

function renderCapsList(list){
  const el = document.getElementById('dev_caps');
  if (!el) return;
  el.innerHTML = '';
  if (!Array.isArray(list) || !list.length){
    el.textContent = '—';
    return;
  }
  list.forEach(cap => {
    const pill = document.createElement('span');
    pill.className = 'pill';
    pill.textContent = cap;
    el.appendChild(pill);
  });
}

function renderSseList(entries){
  const el = document.getElementById('dev_sse');
  if (!el) return;
  el.innerHTML = '';
  if (!Array.isArray(entries) || !entries.length){
    el.textContent = '—';
    return;
  }
  const frag = document.createDocumentFragment();
  entries.forEach(item => {
    if (!item || !item.url) return;
    const link = document.createElement('a');
    link.href = item.url;
    link.target = '_blank';
    link.rel = 'noreferrer';
    link.textContent = item.name || item.url;
    frag.appendChild(link);
    frag.appendChild(document.createTextNode(' '));
  });
  el.appendChild(frag);
}

function normalizeSseEntries(entries){
  if (!Array.isArray(entries)) return [];
  return entries.map(item => {
    const url = typeof item === 'string' ? item : item?.url;
    if (!url) return null;
    const name = typeof item?.name === 'string' && item.name ? item.name : url;
    return { name, url };
  }).filter(Boolean);
}

function formatLogTimestamp(ts){
  const date = ts instanceof Date ? ts : new Date(ts);
  if (Number.isNaN(date.getTime())) return '—';
  return `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
}

function setLogsStatus(text){
  const el = document.getElementById('logsStatus');
  if (el) el.textContent = text || '—';
}

function setLogsSummary(text){
  const el = document.getElementById('logsSummary');
  if (el) el.textContent = text || '—';
}

function renderLogEndpointOptions(endpoints){
  const select = document.getElementById('logsEndpointSelect');
  if (!select) return;
  select.innerHTML = '';
  if (!Array.isArray(endpoints) || !endpoints.length){
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = 'No SSE endpoints available';
    opt.disabled = true;
    opt.selected = true;
    select.appendChild(opt);
    return;
  }
  endpoints.forEach(entry => {
    const opt = document.createElement('option');
    opt.value = entry.url;
    opt.textContent = entry.name || entry.url;
    opt.title = entry.url;
    select.appendChild(opt);
  });
  const match = endpoints.find(entry => entry.url === logsState.selectedUrl) || endpoints[0];
  select.value = match.url;
  logsState.selectedUrl = match.url;
}

function renderLogEntries(){
  const listEl = document.getElementById('logsList');
  const emptyEl = document.getElementById('logsEmptyState');
  if (!listEl || !emptyEl) return;
  listEl.innerHTML = '';
  if (!Array.isArray(logsState.entries) || !logsState.entries.length){
    emptyEl.style.display = '';
    return;
  }
  emptyEl.style.display = 'none';
  const frag = document.createDocumentFragment();
  logsState.entries.forEach(entry => {
    const item = document.createElement('div');
    item.className = 'log-entry';
    const meta = document.createElement('div');
    meta.className = 'log-meta';
    const time = document.createElement('span');
    time.textContent = formatLogTimestamp(entry.ts);
    meta.appendChild(time);
    if (entry.type){
      const pill = document.createElement('span');
      pill.className = 'pill';
      pill.textContent = entry.type;
      meta.appendChild(pill);
    }
    item.appendChild(meta);
    const body = document.createElement('pre');
    body.className = 'log-text';
    body.textContent = entry.text || '';
    item.appendChild(body);
    frag.appendChild(item);
  });
  listEl.appendChild(frag);
}

function appendLogEntry(payload, type){
  const ts = typeof payload?.ts === 'number' && Number.isFinite(payload.ts) ? payload.ts : Date.now();
  const body = (() => {
    if (typeof payload === 'string') return payload;
    if (!payload || typeof payload !== 'object') return String(payload ?? '');
    if (typeof payload.line === 'string'){
      const prefix = payload.stream ? `[${payload.stream}] ` : '';
      return `${prefix}${payload.line}`;
    }
    if (typeof payload.data === 'string') return payload.data;
    if (typeof payload.text === 'string') return payload.text;
    return JSON.stringify(payload);
  })();
  logsState.entries = [{ ts, type: type || payload?.type || 'message', text: body }, ...logsState.entries].slice(0, MAX_LOG_ENTRIES);
  renderLogEntries();
}

function handleLogEvent(ev){
  if (!ev) return;
  if (ev.type === 'open') return;
  const type = ev?.type || 'message';
  let payload = ev && typeof ev === 'object' && 'data' in ev ? ev.data : ev;
  if (typeof payload === 'string'){
    try {
      const parsed = JSON.parse(payload);
      payload = parsed;
    } catch { /* best effort */ }
  }
  appendLogEntry(payload, type);
}

function updateLogsControls(){
  const hasEndpoints = Array.isArray(logsState.endpoints) && logsState.endpoints.length > 0;
  const connectBtn = document.getElementById('logsConnectBtn');
  const disconnectBtn = document.getElementById('logsDisconnectBtn');
  const select = document.getElementById('logsEndpointSelect');
  const isBusy = logsState.connecting;
  if (connectBtn) connectBtn.disabled = !hasEndpoints || isBusy;
  if (disconnectBtn) disconnectBtn.disabled = !logsState.connected && !logsState.connecting;
  if (select) select.disabled = !hasEndpoints || isBusy;
}

function disconnectLogStream(silent = false){
  if (logsState.source){
    try { logsState.source.close(); } catch { /* noop */ }
  }
  if (logsState.controller){
    try { logsState.controller.abort(); } catch { /* noop */ }
  }
  logsState.source = null;
  logsState.controller = null;
  logsState.connected = false;
  logsState.connecting = false;
  logsState.lastDisconnectAt = Date.now();
  updateLogsControls();
  if (!silent){
    setLogsStatus('Disconnected');
    setLogsSummary('Disconnected from SSE endpoint');
  }
}

function waitForCooldown(startMs){
  return new Promise(resolve => setTimeout(resolve, Math.max(0, startMs)));
}

async function connectLogStream(){
  if (!Array.isArray(logsState.endpoints) || !logsState.endpoints.length) return;
  const select = document.getElementById('logsEndpointSelect');
  if (!select || !select.value) return;
  const url = select.value;
  const session = logsState.session + 1;
  logsState.session = session;
  disconnectLogStream(true);
  logsState.entries = [];
  renderLogEntries();
  logsState.selectedUrl = url;
  logsState.connecting = true;
  setLogsStatus('Connecting…');
  setLogsSummary('Connecting to selected SSE endpoint…');
  updateLogsControls();
  const cooldown = Math.max(0, LOGS_RECONNECT_DELAY_MS - (Date.now() - logsState.lastDisconnectAt));
  if (cooldown > 0){
    await waitForCooldown(cooldown);
    if (session !== logsState.session) return;
  }
  try {
    const controller = new AbortController();
    logsState.controller = controller;
    const res = await fetch(url, { cache: 'no-store', signal: controller.signal, headers: { Accept: 'text/event-stream' } });
    if (!res.ok || !res.body){
      throw new Error(`${res.status} ${res.statusText}`);
    }
    if (session !== logsState.session || controller.signal.aborted) return;
    logsState.source = res;
    logsState.connected = true;
    logsState.connecting = false;
    setLogsStatus('Connected');
    setLogsSummary('Streaming logs');
    updateLogsControls();
    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    while (true){
      const { value, done } = await reader.read();
      if (controller.signal.aborted || session !== logsState.session) return;
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      let sepIndex = buffer.indexOf('\n\n');
      while (sepIndex !== -1){
        const chunk = buffer.slice(0, sepIndex);
        buffer = buffer.slice(sepIndex + 2);
        const eventObj = parseSseChunk(chunk);
        if (eventObj) handleLogEvent(eventObj);
        sepIndex = buffer.indexOf('\n\n');
      }
    }
  } catch (err) {
    if ((logsState.controller && logsState.controller.signal.aborted) || session !== logsState.session) return;
    appendLogEntry(`Stream error: ${err?.message || err}`, 'error');
    setLogsStatus('Disconnected');
    setLogsSummary('Disconnected from SSE endpoint');
  } finally {
    if (session !== logsState.session) return;
    logsState.connecting = false;
    disconnectLogStream(true);
  }
}

function parseSseChunk(chunk){
  if (!chunk) return null;
  const lines = chunk.split(/\r?\n/);
  let type = 'message';
  let dataLines = [];
  lines.forEach(line => {
    if (line.startsWith('event:')){
      type = line.slice(6).trim() || 'message';
    } else if (line.startsWith('data:')){
      dataLines.push(line.slice(5).trimStart());
    }
  });
  const data = dataLines.join('\n');
  if (!data && !type) return null;
  return { type, data, ts: Date.now() };
}

function applyLogEndpoints(entries){
  logsState.endpoints = normalizeSseEntries(entries);
  const hasEndpoints = logsState.endpoints.length > 0;
  const selectedValid = hasEndpoints && logsState.selectedUrl
    ? logsState.endpoints.some(entry => entry.url === logsState.selectedUrl)
    : false;
  renderLogEndpointOptions(logsState.endpoints);
  setOptionalCardState('logsCard', {
    enabled: hasEndpoints,
    summary: hasEndpoints ? 'Select an SSE endpoint to stream logs' : 'No SSE endpoints exposed — collapsed'
  });
  if ((!hasEndpoints || !selectedValid) && logsState.connected){
    disconnectLogStream();
  }
  if (!hasEndpoints){
    setLogsStatus('Unavailable');
    setLogsSummary('Waiting for /caps…');
  } else if (logsState.connected){
    setLogsStatus('Connected');
    setLogsSummary('Streaming logs');
  } else {
    setLogsStatus('Ready');
    setLogsSummary('Choose an endpoint to connect.');
  }
  updateLogsControls();
}

function ensureLogsHandlers(){
  if (logsState.initialized) return;
  const connectBtn = document.getElementById('logsConnectBtn');
  const disconnectBtn = document.getElementById('logsDisconnectBtn');
  const select = document.getElementById('logsEndpointSelect');
  if (connectBtn) connectBtn.addEventListener('click', () => { connectLogStream(); });
  if (disconnectBtn) disconnectBtn.addEventListener('click', () => { disconnectLogStream(); setLogsStatus('Disconnected'); });
  if (select) select.addEventListener('change', () => { logsState.selectedUrl = select.value; });
  logsState.initialized = true;
  updateLogsControls();
}

function formatBytes(bytes){
  const value = Number(bytes);
  if (!Number.isFinite(value) || value < 0) return '—';
  if (value >= 1024 * 1024) return `${(value / (1024 * 1024)).toFixed(1)} MB`;
  if (value >= 1024) return `${(value / 1024).toFixed(1)} KB`;
  return `${value} B`;
}

function formatLocalDate(ts){
  const value = Number(ts);
  if (!Number.isFinite(value) || value <= 0) return '—';
  return new Date(value * 1000).toLocaleString();
}

function formatAgoFromSeconds(ts){
  if (!ts) return '—';
  const sec = Number(ts);
  if (!Number.isFinite(sec)) return '—';
  const now = Math.floor(Date.now() / 1000);
  const delta = Math.max(0, now - sec);
  if (delta < 60) return `${delta}s ago`;
  if (delta < 3600) return `${Math.floor(delta / 60)}m ago`;
  if (delta < 86400) return `${Math.floor(delta / 3600)}h ago`;
  return `${Math.floor(delta / 86400)}d ago`;
}

function formatAgoMs(ms, refMs){
  const value = Number(ms);
  const ref = Number(refMs);
  if (!Number.isFinite(value)) return '—';
  let delta = Number.isFinite(ref) ? Math.max(0, ref - value) : 0;
  if (!Number.isFinite(ref)) delta = Math.max(0, Date.now() - value);
  const sec = Math.round(delta / 1000);
  if (sec < 60) return `${sec}s ago`;
  const min = Math.round(sec / 60);
  if (min < 60) return `${min}m ago`;
  const hr = Math.round(min / 60);
  if (hr < 48) return `${hr}h ago`;
  return `${Math.round(hr / 24)}d ago`;
}

function decodeBase64ToUtf8(b64){
  if (!b64) return '';
  try {
    const bin = atob(b64);
    const bytes = Uint8Array.from(bin, ch => ch.charCodeAt(0));
    const dec = new TextDecoder('utf-8', { fatal: false });
    return dec.decode(bytes);
  } catch (err) {
    console.warn('Failed to decode relay body', err);
    try { return atob(b64); } catch { return ''; }
  }
}

function initTabs(){
  const buttons = document.querySelectorAll('.tabs button[data-tab]');
  const panels = document.querySelectorAll('.tab-panel');
  const setActive = name => {
    if (!name) return;
    tabState.active = name;
    buttons.forEach(btn => {
      const match = btn.dataset.tab === name;
      btn.classList.toggle('active', match);
      btn.setAttribute('aria-selected', match ? 'true' : 'false');
    });
    panels.forEach(panel => {
      const match = panel.dataset.panel === name;
      panel.classList.toggle('active', match);
      panel.setAttribute('aria-hidden', match ? 'false' : 'true');
    });
  };
  buttons.forEach(btn => {
    btn.setAttribute('role', 'tab');
    btn.addEventListener('click', () => setActive(btn.dataset.tab));
  });
  panels.forEach(panel => panel.setAttribute('role', 'tabpanel'));
  setActive(tabState.active);
}

function setSyncSummary(text){
  const el = document.getElementById('syncSummary');
  if (el) el.textContent = text;
}

function setSyncBusy(flag){
  syncUiState.busy = !!flag;
  updateSlotPanels();
}

function formatSlaveMeta(rec){
  if (!rec) return '—';
  const parts = [];
  if (rec.device) parts.push(rec.device);
  if (rec.role) parts.push(rec.role);
  if (rec.version) parts.push(`v${rec.version}`);
  if (rec.remote_ip) parts.push(rec.remote_ip);
  if (rec.address && rec.address !== rec.remote_ip) parts.push(rec.address);
  return parts.join(' • ') || '—';
}

function formatSlotConfig(meta){
  if (!meta) return '—';
  const parts = [];
  if (meta.label) parts.push(meta.label);
  if (meta.prefer_id) parts.push(`prefer ${meta.prefer_id}`);
  if (meta.assigned_id) parts.push(`assigned ${meta.assigned_id}`);
  return parts.join(' • ') || '—';
}

function normalizeSlaveRecord(rec){
  if (!rec) return null;
  return {
    id: rec.id ?? null,
    device: rec.device ?? null,
    role: rec.role ?? null,
    version: rec.version ?? null,
    remote_ip: rec.remote_ip ?? rec.address ?? null,
    remote_port: Number.isFinite(rec.remote_port) ? rec.remote_port : null,
    slot: Number.isFinite(rec.slot) ? Number(rec.slot) : null,
    last_seen_ms: Number.isFinite(rec.last_seen_ms) ? Number(rec.last_seen_ms) : null,
    slot_generation: Number.isFinite(rec.slot_generation) ? Number(rec.slot_generation) : null,
    last_ack_generation: Number.isFinite(rec.last_ack_generation) ? Number(rec.last_ack_generation) : null
  };
}

function normalizeSlaveSignature(rec){
  const base = normalizeSlaveRecord(rec);
  if (!base) return null;
  const { last_seen_ms, ...rest } = base;
  return rest;
}

function buildSlotSignature(slotNumber, rec){
  const normalizedRec = normalizeSlaveSignature(rec);
  const slotMeta = syncState.meta.get(slotNumber) || null;
  const waiting = syncState.waiting.map(normalizeSlaveSignature).filter(Boolean);
  const node = rec ? findNodeForSlave(rec) : null;
  const nodeSignature = node
    ? { key: nodeKey(node, slotNumber), data: normalizeNodeRecord(node) }
    : { missing: true, target: rec ? (rec.remote_ip || rec.address || 'unknown') : null, loading: nodesState.loading };
  return JSON.stringify({
    rec: normalizedRec,
    slotMeta,
    waiting,
    busy: syncUiState.busy,
    nodesVersion: nodesState.version,
    nodeSignature
  });
}

function syncSelectOptions(select, items, preserveValue = true){
  if (!select) return;
  const prevValue = preserveValue ? select.value : null;
  let changed = select.options.length !== items.length;
  if (!changed){
    for (let i = 0; i < items.length; i += 1){
      const opt = select.options[i];
      const item = items[i];
      if (!opt || opt.value !== item.value || opt.textContent !== item.label || opt.disabled !== !!item.disabled){
        changed = true;
        break;
      }
    }
  }
  if (!changed) return;
  select.innerHTML = '';
  items.forEach(item => {
    const opt = document.createElement('option');
    opt.value = item.value ?? '';
    opt.textContent = item.label ?? '';
    opt.disabled = !!item.disabled;
    if (item.selected) opt.selected = true;
    select.append(opt);
  });
  if (preserveValue && prevValue){
    const match = Array.from(select.options).find(opt => opt.value === prevValue && !opt.disabled);
    if (match) select.value = prevValue;
  }
  if (!select.value && items.some(item => item.selected)){
    const selectedItem = items.find(item => item.selected);
    if (selectedItem) select.value = selectedItem.value ?? '';
  }
}

function slotActionSection(slotNumber){
  return document.querySelector(`.slot-actions[data-slot="${slotNumber}"]`);
}

function setSlotActionActive(slotNumber, action){
  const section = slotActionSection(slotNumber);
  if (!section || !action) return;
  const buttons = section.querySelectorAll('[data-slot-action]');
  const panels = section.querySelectorAll('[data-slot-panel]');
  buttons.forEach(btn => {
    const match = btn.dataset.slotAction === action;
    btn.classList.toggle('active', match);
    btn.setAttribute('aria-pressed', match ? 'true' : 'false');
  });
  panels.forEach(panel => {
    const match = panel.dataset.slotPanel === action;
    panel.classList.toggle('active', match);
    panel.hidden = !match;
  });
  slotActionState.set(slotNumber, action);
}

function syncSlotActionSelection(slotNumber){
  const section = slotActionSection(slotNumber);
  if (!section) return;
  const buttons = Array.from(section.querySelectorAll('[data-slot-action]'));
  const desired = slotActionState.get(slotNumber);
  const candidate = buttons.find(btn => !btn.disabled && btn.dataset.slotAction === desired)
    || buttons.find(btn => !btn.disabled)
    || buttons[0];
  if (candidate){
    setSlotActionActive(slotNumber, candidate.dataset.slotAction);
  }
}

function initSlotActionSegments(){
  document.querySelectorAll('.slot-actions').forEach(section => {
    const slot = Number(section.dataset.slot);
    if (!Number.isFinite(slot)) return;
    section.querySelectorAll('[data-slot-action]').forEach(btn => {
      btn.addEventListener('click', () => {
        if (btn.disabled) return;
        setSlotActionActive(slot, btn.dataset.slotAction);
      });
    });
    syncSlotActionSelection(slot);
  });
}

function buildSlotPlaceholder(text, className = ''){
  const wrapper = document.createElement('div');
  wrapper.className = `slot-node-empty${className ? ` ${className}` : ''}`;
  wrapper.textContent = text;
  return wrapper;
}

function findNodeForSlave(rec){
  if (!rec) return null;
  const list = Array.isArray(nodesState.list) ? nodesState.list : [];
  const id = (rec.id || '').trim();
  const ip = (rec.remote_ip || rec.address || '').trim();
  const remotePort = Number(rec.remote_port);
  for (const node of list){
    if (!node || typeof node !== 'object') continue;
    if (id && (node.id === id || node.name === id)) return node;
    const nodeIp = (node.ip || node.host || '').trim();
    if (ip && nodeIp === ip){
      if (!Number.isFinite(remotePort)) return node;
      const nodePort = Number(node.port);
      if (!Number.isFinite(nodePort) || nodePort === remotePort) return node;
    }
  }
  return null;
}

function renderSlotNode(slotNumber, rec){
  const container = document.getElementById(`slot${slotNumber}NodeContainer`);
  if (!container) return;
  container.innerHTML = '';
  if (syncUiState.busy && !rec){
    container.append(buildSlotPlaceholder('Syncing slot updates…', 'loading'));
    return;
  }
  if (!rec){
    container.append(buildSlotPlaceholder('Waiting for slot assignment.'));
    return;
  }
  const node = findNodeForSlave(rec);
  if (node){
    container.append(buildNodeCard(node, slotNumber));
    return;
  }
  if (nodesState.loading){
    container.append(buildSlotPlaceholder('Loading node details…', 'loading'));
    return;
  }
  const targetIp = rec.remote_ip || rec.address || 'unknown';
  container.append(buildSlotPlaceholder(`No /nodes entry for ${targetIp}. Refresh nodes to discover relay details.`));
}

function updateSlotSummary(slotNumber, rec){
  const summaryEl = document.getElementById(`slot${slotNumber}Summary`);
  const metaEl = document.getElementById(`slot${slotNumber}Meta`);
  const lastSeenEl = document.getElementById(`slot${slotNumber}LastSeen`);
  const slotMetaEl = document.getElementById(`slot${slotNumber}SlotMeta`);
  const slotMeta = syncState.meta.get(slotNumber) || null;
  if (summaryEl){
    summaryEl.textContent = rec ? (rec.id || rec.remote_ip || 'unnamed') : 'No slave assigned.';
  }
  if (metaEl){
    metaEl.textContent = rec ? formatSlaveMeta(rec) : '—';
  }
  if (lastSeenEl){
    lastSeenEl.textContent = rec ? `Last seen ${formatAgoMs(rec.last_seen_ms, syncState.refMs)}` : 'Last seen —';
  }
  if (slotMetaEl){
    slotMetaEl.textContent = `Slot config: ${formatSlotConfig(slotMeta)}`;
  }
}

function describeWaiting(waiting){
  if (!waiting.length) return 'Waiting: None';
  const names = waiting.map(rec => rec?.id || rec?.remote_ip || 'unknown');
  return `Waiting: ${waiting.length} (${names.join(', ')})`;
}

function updateSlotWaiting(slotNumber){
  const waitingEl = document.getElementById(`slot${slotNumber}WaitingSummary`);
  if (waitingEl) waitingEl.textContent = describeWaiting(syncState.waiting);
}

function populateWaitingSelect(select){
  if (!select) return;
  const waiting = syncState.waiting.filter(item => item && item.id);
  const items = waiting.length
    ? [
        { value: '', label: 'Select slave…', selected: true },
        ...waiting.map(rec => ({
          value: rec.id,
          label: `${rec.id} (${formatAgoMs(rec.last_seen_ms, syncState.refMs)})`
        }))
      ]
    : [{ value: '', label: 'No waiting slaves', selected: true }];
  syncSelectOptions(select, items, true);
  select.disabled = syncUiState.busy || !waiting.length;
}

function updateSlotControls(slotNumber, rec){
  const moveSelect = document.getElementById(`slot${slotNumber}MoveSelect`);
  const moveBtn = document.querySelector(`.slot-move-btn[data-slot="${slotNumber}"]`);
  const actionSection = slotActionSection(slotNumber);
  const hasWaiting = syncState.waiting.some(entry => entry && entry.id);
  if (moveSelect){
    const items = !rec
      ? [{ value: '', label: 'No assigned slave', selected: true }]
      : [
          { value: '', label: 'Select target…', selected: true },
          ...Array.from({ length: MAX_SYNC_SLOTS }, (_v, i) => i + 1)
            .filter(slot => slot !== slotNumber)
            .map(slot => ({ value: String(slot), label: `Slot ${slot}` })),
          { value: '__unassign__', label: 'Unassign' }
        ];
    syncSelectOptions(moveSelect, items, true);
    moveSelect.disabled = syncUiState.busy || !rec;
  }
  if (moveBtn){
    moveBtn.disabled = syncUiState.busy || !rec;
  }
  const replayBtn = document.querySelector(`.slot-replay-btn[data-slot="${slotNumber}"]`);
  if (replayBtn){
    replayBtn.disabled = syncUiState.busy || !rec;
  }
  const assignSelect = document.getElementById(`slot${slotNumber}AssignSelect`);
  if (assignSelect){
    populateWaitingSelect(assignSelect);
  }
  const assignBtn = document.querySelector(`.slot-assign-btn[data-slot="${slotNumber}"]`);
  if (assignBtn){
    assignBtn.disabled = syncUiState.busy || !hasWaiting;
  }
  if (actionSection){
    const assignToggle = actionSection.querySelector('[data-slot-action="assign"]');
    const moveToggle = actionSection.querySelector('[data-slot-action="move"]');
    const replayToggle = actionSection.querySelector('[data-slot-action="replay"]');
    if (assignToggle) assignToggle.disabled = syncUiState.busy || !hasWaiting;
    if (moveToggle) moveToggle.disabled = syncUiState.busy || !rec;
    if (replayToggle) replayToggle.disabled = syncUiState.busy || !rec;
  }
  syncSlotActionSelection(slotNumber);
}

function updateSlotPanels(){
  for (let slot = 1; slot <= MAX_SYNC_SLOTS; slot += 1){
    const rec = syncState.slots[slot - 1] || null;
    const signature = buildSlotSignature(slot, rec);
    const cached = slotRenderCache.get(slot);
    if (cached && cached.signature === signature) continue;
    slotRenderCache.set(slot, { signature });
    updateSlotSummary(slot, rec);
    renderSlotNode(slot, rec);
    updateSlotControls(slot, rec);
    updateSlotWaiting(slot);
  }
}

async function postExec(payload, timeoutMs = DEFAULT_CMD_TIMEOUT_MS){
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch('/exec', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
      signal: controller.signal
    });
    const data = await res.json().catch(() => null);
    if (!res.ok){
      const message = data?.error || data?.stderr || data?.stdout || `HTTP ${res.status}`;
      throw new Error(message);
    }
    return data || {};
  } finally {
    clearTimeout(timer);
  }
}

function setCapsStatus(text){
  const statusEl = document.getElementById('capsStatus');
  if (statusEl) statusEl.textContent = text;
  setHeaderStatus(text);
}

function setHeaderStatus(text){
  const headerStatus = document.getElementById('headerStatus');
  if (headerStatus) headerStatus.textContent = text;
}

function buildBrowserNodeRecord(caps){
  const host = window.location.hostname || 'browser';
  const parsedPort = Number(window.location.port);
  return {
    id: 'browser',
    name: 'browser',
    ip: host,
    host,
    port: Number.isFinite(parsedPort) ? parsedPort : null,
    device: caps?.device || 'Browser',
    role: caps?.role || 'browser',
    version: caps?.version || '',
    last_seen: Math.floor(Date.now() / 1000),
    local: true
  };
}

function browserNodeSignature(node){
  return JSON.stringify({
    device: node?.device || '',
    role: node?.role || '',
    version: node?.version || '',
    host: node?.host || node?.ip || '',
    port: Number.isFinite(node?.port) ? node.port : ''
  });
}

function renderBrowserNode(caps){
  const container = document.getElementById('browserNodeContainer');
  if (!container) return;
  if (!caps){
    browserNodeState.signature = '';
    container.innerHTML = '';
    container.append(buildSlotPlaceholder('Load /caps to browse browser commands.'));
    return;
  }
  if (!capsState.hasExec){
    browserNodeState.signature = 'no-exec';
    container.innerHTML = '';
    container.append(buildSlotPlaceholder('Exec capability required to browse browser commands.'));
    return;
  }
  const node = buildBrowserNodeRecord(caps);
  const signature = browserNodeSignature(node);
  if (browserNodeState.signature === signature && container.childElementCount){
    return;
  }
  browserNodeState.signature = signature;
  container.innerHTML = '';
  container.append(buildNodeCard(node, 'browser'));
}

function applyCapabilityToggles(capList){
  const list = Array.isArray(capList) ? capList : [];
  capsState.capList = new Set(list);
  capsState.hasExec = capsState.capList.has('exec');
  const hasMiniRk = capsState.capList.has('pixelpilot_mini_rk');
  const hasDvr = capsState.capList.has('dvr');

  const deviceActionsRow = document.getElementById('deviceRuntimeActions');
  if (deviceActionsRow) deviceActionsRow.style.display = hasMiniRk ? '' : 'none';

  const pixelpilotCard = document.getElementById('pixelpilotMiniRkCard');
  const miniRkToggle = document.getElementById('pixelpilotMiniRkToggle');
  const miniRkPrimary = document.getElementById('pixelpilotMiniRkToggleRecordingBtn');
  if (pixelpilotCard){
    setOptionalCardState('pixelpilotMiniRkCard', {
      enabled: hasMiniRk,
      summary: hasMiniRk ? 'Pixelpilot Mini RK ready' : 'Capability missing — controls hidden'
    });
    pixelpilotCard.querySelectorAll('button').forEach(btn => {
      if (btn.id === 'pixelpilotMiniRkToggle') return;
      btn.disabled = !hasMiniRk;
    });
    if (miniRkToggle) miniRkToggle.disabled = false;
    if (miniRkPrimary) miniRkPrimary.disabled = !hasMiniRk;
    if (hasMiniRk){
      ensureMiniRkCard();
      setMiniRkStatusIdle('Idle');
    } else {
      setMiniRkStatusIdle('cap missing');
    }
  }

  ensureDvrHandlers();
  dvrState.hasExec = capsState.hasExec;
  dvrState.enabled = hasDvr;
  updateDvrControls();
  const dvrCard = document.getElementById('dvrCard');
  const dvrToggle = document.getElementById('dvrToggle');
  const dvrRefreshBtn = document.getElementById('dvrRefreshBtn');
  if (dvrCard){
    setOptionalCardState('dvrCard', {
      enabled: hasDvr,
      summary: hasDvr ? 'Recording list available' : 'Capability missing — collapsed'
    });
    if (dvrToggle) dvrToggle.disabled = false;
    if (dvrRefreshBtn) dvrRefreshBtn.disabled = !hasDvr;
    if (hasDvr){
      refreshDvrList();
    } else {
      clearDvrCard();
    }
  }
}

function renderCaps(caps){
  capsState.latest = caps || null;
  document.getElementById('dev_device').textContent = caps?.device || '—';
  document.getElementById('dev_role').textContent = caps?.role || '—';
  document.getElementById('dev_version').textContent = caps?.version || '—';
  document.getElementById('dev_if').textContent = formatInterfaces(caps?.ifaddrs);
  document.getElementById('dev_uptime').textContent = secsToHhMmSs(caps?.uptime_s);
  document.getElementById('dev_load').textContent = formatLoadavg(caps?.loadavg);
  renderCapsList(caps?.caps);
  renderSseList(caps?.sse);
  ensureLogsHandlers();
  applyLogEndpoints(caps?.sse);
  const subtitle = document.getElementById('subtitle');
  if (subtitle){
    const label = [caps?.device || 'device', caps?.version ? `v${caps.version}` : ''].filter(Boolean).join(' ');
    subtitle.textContent = label || 'Device summary';
  }
  setCapsStatus(`Updated ${new Date().toLocaleTimeString()}`);
  applyCapabilityToggles(Array.isArray(caps?.caps) ? caps.caps : []);
  renderBrowserNode(caps);
}

async function fetchCaps(){
  setCapsStatus('Loading /caps…');
  try {
    const res = await fetch('/caps', { cache: 'no-store' });
    if (!res.ok){
      const txt = await res.text().catch(() => '');
      throw new Error(`${res.status} ${txt.trim()}`);
    }
    const data = await res.json();
    renderCaps(data);
  } catch (err) {
    setCapsStatus(`Failed (${err.message})`);
    renderBrowserNode(null);
  }
}

function ensureDvrHandlers(){
  if (dvrState.initialized) return;
  const refreshBtn = document.getElementById('dvrRefreshBtn');
  const deleteBtn = document.getElementById('dvrDeleteAllBtn');
  if (refreshBtn) refreshBtn.addEventListener('click', () => { void refreshDvrList(); });
  if (deleteBtn) deleteBtn.addEventListener('click', () => { void deleteAllDvrRecordings(); });
  dvrState.initialized = true;
}

function updateDvrControls(){
  const deleteBtn = document.getElementById('dvrDeleteAllBtn');
  if (deleteBtn){
    const hasAccess = dvrState.enabled && dvrState.hasExec;
    deleteBtn.disabled = !hasAccess;
    deleteBtn.title = hasAccess ? '' : (dvrState.enabled ? 'Requires exec capability' : 'Requires DVR capability');
  }
}

function showDvrMessage(text, type){
  const msgEl = document.getElementById('dvrMessage');
  if (!msgEl) return;
  msgEl.classList.remove('ok', 'err');
  if (!text){
    msgEl.style.display = 'none';
    msgEl.textContent = '';
    return;
  }
  msgEl.textContent = text;
  if (type) msgEl.classList.add(type);
  msgEl.style.display = 'block';
}

function clearDvrCard(){
  const listEl = document.getElementById('dvrList');
  const emptyEl = document.getElementById('dvrEmptyState');
  const statusEl = document.getElementById('dvrStatus');
  showDvrMessage('', '');
  if (listEl) listEl.innerHTML = '';
  if (emptyEl) emptyEl.style.display = 'none';
  if (statusEl) statusEl.textContent = 'cap missing';
}

function renderDvrEntries(entries){
  const listEl = document.getElementById('dvrList');
  const emptyEl = document.getElementById('dvrEmptyState');
  if (!listEl || !emptyEl) return;
  listEl.innerHTML = '';
  if (!Array.isArray(entries) || !entries.length){
    emptyEl.style.display = 'block';
    return;
  }
  emptyEl.style.display = 'none';
  const frag = document.createDocumentFragment();
  entries.forEach(entry => {
    if (!entry || typeof entry.name !== 'string') return;
    const item = document.createElement('div');
    item.className = 'dvr-item';
    const link = document.createElement('a');
    link.href = `/media/${encodeURIComponent(entry.name)}`;
    link.textContent = entry.name;
    link.download = entry.name;
    item.appendChild(link);
    const meta = document.createElement('div');
    meta.className = 'dvr-meta';
    const sizeText = formatBytes(entry.sizeBytes);
    const timeText = formatLocalDate(entry.mtimeSec);
    meta.textContent = (sizeText === '—' && timeText === '—') ? '—' : `${sizeText} • ${timeText}`;
    item.appendChild(meta);
    frag.appendChild(item);
  });
  listEl.appendChild(frag);
}

function parseDvrListFromHtml(html){
  if (typeof DOMParser !== 'function') return [];
  try {
    const doc = new DOMParser().parseFromString(html, 'text/html');
    return Array.from(doc.querySelectorAll('a')).map(a => a.getAttribute('href') || '')
      .map(raw => raw.split('#')[0].split('?')[0].replace(/^\/+|\/+$/g, ''))
      .filter(Boolean)
      .filter(name => name !== '..' && name.toLowerCase().endsWith('.mp4'));
  } catch {
    return [];
  }
}

async function refreshDvrList(){
  const card = document.getElementById('dvrCard');
  if (!card || card.dataset.enabled !== 'true') return;
  if (dvrState.loading) return;
  const statusEl = document.getElementById('dvrStatus');
  const listEl = document.getElementById('dvrList');
  const emptyEl = document.getElementById('dvrEmptyState');
  if (!statusEl || !listEl || !emptyEl) return;
  dvrState.loading = true;
  statusEl.textContent = 'Loading…';
  listEl.innerHTML = '';
  emptyEl.style.display = 'none';
  showDvrMessage('', '');
  try {
    let entries = [];
    if (dvrState.hasExec){
      const res = await postExec({ path: '/sys/dvr/list', args: [] });
      const ok = typeof res?.rc === 'number' ? res.rc === 0 : true;
      const stdout = String(res?.stdout ?? '');
      if (!ok){
        const errMsg = (res?.stderr || stdout || 'failed to list recordings').trim();
        throw new Error(errMsg || 'failed to list recordings');
      }
      entries = stdout.split(/\r?\n/).map(line => {
        const trimmed = line.trim();
        if (!trimmed) return null;
        const parts = trimmed.split('\t');
        const name = parts[0]?.trim();
        if (!name) return null;
        const size = parts.length > 1 ? Number(parts[1]) : NaN;
        const mtime = parts.length > 2 ? Number(parts[2]) : NaN;
        return {
          name,
          sizeBytes: Number.isFinite(size) && size >= 0 ? size : null,
          mtimeSec: Number.isFinite(mtime) && mtime > 0 ? Math.floor(mtime) : null
        };
      }).filter(Boolean);
    } else {
      const resp = await fetch('/media/', { cache: 'no-store' });
      if (!resp.ok){
        throw new Error(`/media/ responded with ${resp.status}`);
      }
      const html = await resp.text();
      const names = parseDvrListFromHtml(html);
      entries = names.map(name => ({ name }));
    }
    entries.sort((a, b) => {
      const aTs = Number.isFinite(a?.mtimeSec) ? a.mtimeSec : 0;
      const bTs = Number.isFinite(b?.mtimeSec) ? b.mtimeSec : 0;
      if (bTs !== aTs) return bTs - aTs;
      return (a?.name || '').localeCompare(b?.name || '', 'en', { numeric: true, sensitivity: 'base' });
    });
    renderDvrEntries(entries);
    statusEl.textContent = `${entries.length} recording${entries.length === 1 ? '' : 's'} • ${new Date().toLocaleTimeString()}`;
  } catch (err) {
    statusEl.textContent = 'Failed';
    showDvrMessage(err.message || 'failed to load recordings', 'err');
  } finally {
    dvrState.loading = false;
  }
}

async function deleteAllDvrRecordings(){
  if (!dvrState.hasExec || !dvrState.enabled) return;
  if (!confirm('Delete all DVR recordings?')) return;
  const deleteBtn = document.getElementById('dvrDeleteAllBtn');
  const statusEl = document.getElementById('dvrStatus');
  if (deleteBtn) deleteBtn.disabled = true;
  showDvrMessage('', '');
  if (statusEl) statusEl.textContent = 'Deleting…';
  try {
    const res = await postExec({ path: '/sys/dvr/delete_all', args: [] });
    const ok = typeof res?.rc === 'number' ? res.rc === 0 : true;
    const detail = (res?.stderr || res?.stdout || (ok ? 'Deleted recordings' : 'Delete failed')).trim();
    showDvrMessage(detail || (ok ? 'Deleted recordings' : 'Delete failed'), ok ? 'ok' : 'err');
  } catch (err) {
    showDvrMessage(err.message || 'Delete failed', 'err');
  } finally {
    if (deleteBtn) deleteBtn.disabled = !dvrState.hasExec;
    await refreshDvrList();
  }
}

function miniRkStatusEl(){
  return document.getElementById('pixelpilotMiniRkStatus');
}

function setMiniRkStatusIdle(text = 'Idle'){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('running', 'ok', 'err', 'flash');
  el.textContent = text;
  el.title = '';
}

function setMiniRkStatusRunning(){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('ok', 'err', 'flash');
  el.classList.add('running');
  el.textContent = 'Running…';
  el.title = '';
}

function setMiniRkStatusResult(ok, detail = ''){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('running', 'ok', 'err', 'flash');
  el.classList.add(ok ? 'ok' : 'err');
  el.textContent = `${ok ? 'Success' : 'Error'} • ${new Date().toLocaleTimeString()}`;
  el.title = detail || '';
  void el.offsetWidth;
  el.classList.add('flash');
}

async function runMiniRkCommand(command, btnEl){
  const payload = typeof command === 'string'
    ? { path: command, args: [] }
    : {
        path: command?.path || '',
        args: Array.isArray(command?.args) ? command.args : []
      };
  if (!payload.path){
    setMiniRkStatusResult(false, 'invalid command');
    return;
  }
  setMiniRkStatusRunning();
  if (btnEl) btnEl.disabled = true;
  try {
    const res = await postExec(payload);
    const ok = typeof res?.rc === 'number' ? res.rc === 0 : true;
    const stdout = (res?.stdout || '').trim();
    const stderr = (res?.stderr || '').trim();
    const detail = ok ? (stdout.split('\n')[0] || '') : (stderr || stdout || 'command failed');
    setMiniRkStatusResult(ok, detail);
  } catch (err) {
    setMiniRkStatusResult(false, err.message || 'command failed');
  } finally {
    if (btnEl) btnEl.disabled = false;
  }
}

function parseMiniRkGammaPresets(stdout){
  const out = [];
  const seen = new Set();
  String(stdout || '').split(/\r?\n/).forEach(rawLine => {
    const line = rawLine.trim();
    if (!line || /^available presets/i.test(line) || seen.has(line)) return;
    seen.add(line);
    out.push(line);
  });
  return out;
}

function renderMiniRkGammaPresets(presets){
  const select = document.getElementById('pixelpilotMiniRkGammaSelect');
  const applyBtn = document.getElementById('pixelpilotMiniRkApplyGammaBtn');
  if (!select || !applyBtn) return;
  select.innerHTML = '';
  const items = Array.isArray(presets) ? presets : [];
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.disabled = true;
  placeholder.selected = true;
  placeholder.textContent = items.length ? 'Select preset…' : 'No presets available';
  select.appendChild(placeholder);
  items.forEach(preset => {
    const option = document.createElement('option');
    option.value = preset;
    option.textContent = preset;
    select.appendChild(option);
  });
  select.disabled = items.length === 0;
  applyBtn.disabled = true;
}

async function loadMiniRkGammaPresets(){
  const select = document.getElementById('pixelpilotMiniRkGammaSelect');
  const applyBtn = document.getElementById('pixelpilotMiniRkApplyGammaBtn');
  const reloadBtn = document.getElementById('pixelpilotMiniRkReloadGammaBtn');
  const noticeEl = document.getElementById('pixelpilotMiniRkGammaNotice');
  if (!select || !applyBtn) return;
  if (miniRkState.gamma.loading) return;
  miniRkState.gamma.loading = true;
  select.disabled = true;
  applyBtn.disabled = true;
  if (reloadBtn) reloadBtn.disabled = true;
  if (noticeEl) noticeEl.textContent = 'Loading presets…';
  try {
    const res = await postExec({ path: '/sys/pixelpilot_mini_rk/gamma', args: ['--list'] });
    const presets = parseMiniRkGammaPresets(res?.stdout || '');
    miniRkState.gamma.presets = presets;
    renderMiniRkGammaPresets(presets);
    if (noticeEl){
      noticeEl.textContent = presets.length ? `Loaded ${presets.length} preset${presets.length === 1 ? '' : 's'}` : 'No presets reported';
    }
  } catch (err) {
    miniRkState.gamma.presets = [];
    renderMiniRkGammaPresets([]);
    if (noticeEl) noticeEl.textContent = err.message || 'Failed to load presets';
  } finally {
    if (reloadBtn) reloadBtn.disabled = false;
    miniRkState.gamma.loading = false;
  }
}

function initMiniRkGammaControls(){
  const select = document.getElementById('pixelpilotMiniRkGammaSelect');
  const applyBtn = document.getElementById('pixelpilotMiniRkApplyGammaBtn');
  const reloadBtn = document.getElementById('pixelpilotMiniRkReloadGammaBtn');
  if (!select || !applyBtn) return;
  select.addEventListener('change', () => {
    applyBtn.disabled = !select.value;
  });
  applyBtn.addEventListener('click', () => {
    const preset = select.value.trim();
    if (!preset) return;
    runMiniRkCommand({ path: '/sys/pixelpilot_mini_rk/gamma', args: [preset] }, applyBtn);
  });
  if (reloadBtn){
    reloadBtn.addEventListener('click', () => { void loadMiniRkGammaPresets(); });
  }
  void loadMiniRkGammaPresets();
}

function ensureMiniRkCard(){
  if (miniRkState.initialized) return;
  setMiniRkStatusIdle('Idle');
  const mapping = [
    { selector: '#pixelpilotMiniRkToggleOsdBtn', command: { path: '/sys/pixelpilot_mini_rk/toggle_osd' } },
    { selector: '#pixelpilotMiniRkToggleRecordingBtn', command: { path: '/sys/pixelpilot_mini_rk/toggle_recording' } },
    { selector: '#pixelpilotMiniRkRestartServiceBtn', command: { path: '/sys/pixelpilot_mini_rk/restart' } },
    { selector: '#pixelpilotMiniRkStopServiceBtn', command: { path: '/sys/pixelpilot_mini_rk/stop' } },
    { selector: '#pixelpilotMiniRkStartServiceBtn', command: { path: '/sys/pixelpilot_mini_rk/start' } },
    { selector: '#pixelpilotMiniRkRebootBtn', command: { path: '/sys/reboot' } },
    { selector: '#pixelpilotMiniRkShutdownBtn', command: { path: '/sys/shutdown' } }
  ];
  mapping.forEach(entry => {
    const btn = document.querySelector(entry.selector);
    if (btn) btn.addEventListener('click', () => { void runMiniRkCommand(entry.command, btn); });
  });
  initMiniRkGammaControls();
  miniRkState.initialized = true;
}

function nodeKey(node, idx){
  const ip = (node?.ip || node?.host || '').trim();
  const port = node?.port;
  if (ip && (port || port === 0)) return `${ip}:${port}`;
  if (ip) return ip;
  return `node-${idx}`;
}

function setNodesSummary(text){
  const summary = document.getElementById('nodesSummary');
  if (summary) summary.textContent = text;
}

  function getNodeHelpStore(key){
    if (!nodeHelpState.has(key)){
      nodeHelpState.set(key, {
        cache: new Map(),
        endpoints: new Map([['/sys/help', { description: 'System help & discovery' }]]),
        activePath: '/sys/help',
        loadingPath: null,
        advanced: false,
        error: '',
        lastOutput: ''
      });
    }
    const store = nodeHelpState.get(key);
    if (store.advanced === undefined) store.advanced = false;
    return store;
  }

  function describeEndpoint(path, meta, help){
    if (meta?.description) return meta.description;
    if (help?.cap) return help.cap;
    return path || 'help';
  }

  function normalizeHelpEndpoint(entry){
    if (!entry) return null;
    if (typeof entry === 'string') return { path: entry, description: '' };
    if (typeof entry === 'object' && entry.path) return { path: entry.path, description: entry.description || '' };
    return null;
  }

  function deriveCommandPath(helpPath, command){
    if (!command) return helpPath || '/sys';
    const base = (helpPath || '').replace(/\/+$/, '').replace(/\/help$/i, '');
    if (!base) return `/${command}`;
    return `${base}/${command}`;
  }

  function findCommand(commands, name){
    if (!name) return null;
    const target = String(name).toLowerCase();
    return (Array.isArray(commands) ? commands : []).find(cmd => (cmd?.name || '').toLowerCase() === target) || null;
  }

  function makePill(text){
    const span = document.createElement('span');
    span.className = 'pill';
    span.textContent = text || '';
    return span;
  }

  function delay(ms){
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async function relayExecToNode(node, path, args, timeoutMs = DEFAULT_CMD_TIMEOUT_MS){
    if (node?.local){
      const exec = await postExec({ path, args: Array.isArray(args) ? args : [] }, timeoutMs);
      return { relay: { local: true }, exec };
    }
    const ip = node?.ip || node?.host;
    if (!ip) throw new Error('missing node ip');
    const payload = {
      node_ip: ip,
      method: 'POST',
      path: '/exec',
      timeout_ms: timeoutMs,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path, args: Array.isArray(args) ? args : [] })
    };
    const res = await fetch('/http', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const data = await res.json().catch(() => null);
    if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`);
    if (!data || data.error) throw new Error(data?.error || 'relay_failed');
    const execText = decodeBase64ToUtf8(data.body_base64);
    let exec;
    try {
      exec = JSON.parse(execText);
    } catch (err) {
      throw new Error('invalid /exec response');
    }
    return { relay: data, exec };
  }

  function summarizeExec(path, exec){
    const lines = [];
    const rc = typeof exec?.rc === 'number' ? exec.rc : null;
    lines.push(`${path} → rc ${rc ?? '?'}`);
    if (exec?.stdout) lines.push(`stdout: ${String(exec.stdout).trim()}`);
    if (exec?.stderr) lines.push(`stderr: ${String(exec.stderr).trim()}`);
    if (Number.isFinite(exec?.elapsed_ms)) lines.push(`elapsed_ms: ${exec.elapsed_ms}`);
    return lines.filter(Boolean).join('\n');
  }

  async function fetchNodeHelp(node, key, path, ui, forceReload = false){
    const store = getNodeHelpStore(key);
    const helpPath = path || '/sys/help';
    if (!forceReload && store.cache.has(helpPath)){
      store.activePath = helpPath;
      renderNodeHelp(node, key, ui);
      return;
    }
    store.activePath = helpPath;
    store.loadingPath = helpPath;
    store.error = '';
    renderNodeHelp(node, key, ui);
    try {
      const { exec } = await relayExecToNode(node, helpPath, []);
      const rcOk = typeof exec?.rc === 'number' ? exec.rc === 0 : true;
      if (!rcOk) throw new Error(exec?.stderr || exec?.stdout || 'exec failed');
      const stdout = String(exec?.stdout || '').trim();
      const help = stdout ? JSON.parse(stdout) : null;
      if (!help) throw new Error('empty help payload');
      store.cache.set(helpPath, help);
      const meta = store.endpoints.get(helpPath) || {};
      store.endpoints.set(helpPath, { description: describeEndpoint(helpPath, meta, help) });
      (Array.isArray(help.help_endpoints) ? help.help_endpoints : []).forEach(raw => {
        const ep = normalizeHelpEndpoint(raw);
        if (!ep?.path) return;
        const prev = store.endpoints.get(ep.path) || {};
        store.endpoints.set(ep.path, { description: ep.description || prev.description || '' });
      });
    } catch (err) {
      store.error = err.message || 'Failed to load help';
    } finally {
      store.loadingPath = null;
      renderNodeHelp(node, key, ui);
    }
  }

  function createNodeHelpElements(){
    const wrapper = document.createElement('div');
    wrapper.className = 'node-help';

    const status = document.createElement('div');
    status.className = 'node-help-status';

    const advancedRow = document.createElement('div');
    advancedRow.className = 'node-help-advanced';
    const advancedLabel = document.createElement('label');
    advancedLabel.className = 'toggle';
    const advancedInput = document.createElement('input');
    advancedInput.type = 'checkbox';
    advancedInput.className = 'toggle-input';
    const advancedTrack = document.createElement('span');
    advancedTrack.className = 'toggle-track';
    const advancedThumb = document.createElement('span');
    advancedThumb.className = 'toggle-thumb';
    advancedTrack.append(advancedThumb);
    advancedLabel.append(advancedInput, advancedTrack);
    const advancedText = document.createElement('span');
    advancedText.textContent = 'Advanced controls';
    advancedRow.append(advancedLabel, advancedText);

    const menuRow = document.createElement('div');
    menuRow.className = 'node-help-menu';
    const menuLabel = document.createElement('label');
    menuLabel.textContent = 'Help menu ';
    const menuSelect = document.createElement('select');
    menuLabel.append(menuSelect);
    const refreshBtn = document.createElement('button');
    refreshBtn.type = 'button';
    refreshBtn.textContent = 'Reload help';
    menuRow.append(menuLabel, refreshBtn);

    const endpointsRow = document.createElement('div');
    endpointsRow.className = 'node-help-endpoints';

    const settings = document.createElement('div');
    settings.className = 'node-settings';

    const commands = document.createElement('div');
    commands.className = 'node-help-commands';

    const output = document.createElement('textarea');
    output.className = 'node-help-output';
    output.placeholder = 'Command output will appear here';
    output.readOnly = true;

    wrapper.append(status, advancedRow, menuRow, endpointsRow, settings, commands, output);
    return { wrapper, status, advancedInput, menuSelect, refreshBtn, endpointsRow, settings, commands, output };
  }

  function buildArgControl(arg){
    const wrapper = document.createElement('div');
    wrapper.className = 'node-arg';
    const metaLine = document.createElement('div');
    metaLine.className = 'node-arg-meta';
    metaLine.append(makePill(arg?.key || 'arg'));
    if (arg?.type) metaLine.append(makePill(arg.type));
    if (arg?.required) metaLine.append(makePill('required'));
    wrapper.append(metaLine);
    if (arg?.description){
      const desc = document.createElement('small');
      desc.textContent = arg.description;
      wrapper.append(desc);
    }

    const control = arg?.control || {};
    const options = Array.isArray(control.options) ? control.options : Array.isArray(arg?.options) ? arg.options : [];
    const numericType = (arg?.type || '').toLowerCase();
    const isNumeric = numericType === 'int' || numericType === 'float' || numericType === 'number';

    const resolvedKind = (() => {
      if (control.kind) return control.kind;
      if (options.length) return 'select';
      if (control.kind === undefined && (Number.isFinite(control.min) || Number.isFinite(control.max))) return 'range';
      if (isNumeric && (Number.isFinite(control.min) || Number.isFinite(control.max))) return 'range';
      if (numericType === 'bool') return 'toggle';
      return isNumeric ? 'number' : 'text';
    })();

    const setKindMeta = (el) => {
      if (!el) return;
      el.dataset.kind = resolvedKind;
      el.dataset.argKey = arg?.key || '';
    };

    const makeSelect = () => {
      const select = document.createElement('select');
      if (control.multi) select.multiple = true;
      options.forEach(opt => {
        const optEl = document.createElement('option');
        optEl.value = String(opt);
        optEl.textContent = String(opt);
        select.append(optEl);
      });
      if (arg?.default !== undefined){
        if (Array.isArray(arg.default) && select.multiple){
          Array.from(select.options).forEach(optEl => { optEl.selected = arg.default.map(String).includes(optEl.value); });
        } else {
          select.value = String(arg.default);
        }
      }
      setKindMeta(select);
      return select;
    };

    const makeRange = () => {
      const sliderWrap = document.createElement('div');
      sliderWrap.className = 'node-slider';
      const slider = document.createElement('input');
      slider.type = 'range';
      if (Number.isFinite(control.min)) slider.min = String(control.min);
      if (Number.isFinite(control.max)) slider.max = String(control.max);
      if (Number.isFinite(control.step)) slider.step = String(control.step);
      if (arg?.default !== undefined) slider.value = String(arg.default);
      const valueLabel = document.createElement('div');
      valueLabel.className = 'node-slider-value';
      const unit = control.unit ? ` ${control.unit}` : '';
      valueLabel.textContent = slider.value ? `${slider.value}${unit}` : String(arg?.default ?? '');
      slider.addEventListener('input', () => { valueLabel.textContent = `${slider.value}${unit}`; });
      sliderWrap.append(slider, valueLabel);
      wrapper.append(sliderWrap);
      slider.dataset.unit = unit;
      slider._valueLabel = valueLabel;
      setKindMeta(slider);
      return slider;
    };

    let input;
    if (resolvedKind === 'toggle'){
      const toggle = document.createElement('label');
      toggle.className = 'toggle';
      input = document.createElement('input');
      input.type = 'checkbox';
      input.className = 'toggle-input';
      input.checked = arg?.default === true;
      setKindMeta(input);
      const track = document.createElement('span');
      track.className = 'toggle-track';
      const thumb = document.createElement('span');
      thumb.className = 'toggle-thumb';
      track.append(thumb);
      toggle.append(input, track);
      wrapper.append(toggle);
    } else if (resolvedKind === 'select'){
      input = makeSelect();
    } else if (resolvedKind === 'range'){
      input = makeRange();
      return { wrapper, input };
    } else {
      input = document.createElement('input');
      input.type = resolvedKind === 'number' ? 'number' : 'text';
      if (control.placeholder) input.placeholder = control.placeholder;
      if (arg?.default !== undefined) input.value = String(arg.default);
      setKindMeta(input);
    }
    if (input && !wrapper.contains(input)) wrapper.append(input);
    return { wrapper, input, kind: resolvedKind };
  }

  function allowEmptyValue(arg){
    const control = arg?.control || {};
    if (control.allow_empty || arg?.allow_empty) return true;
    const opts = Array.isArray(control.options) ? control.options : Array.isArray(arg?.options) ? arg.options : [];
    return opts.some(opt => String(opt) === '');
  }

  function readArgValue(input, arg){
    if (!input) return '';
    const allowEmpty = allowEmptyValue(arg);
    if (input.type === 'checkbox') return input.checked ? 'true' : 'false';
    if (input.tagName === 'SELECT' && input.multiple){
      const vals = Array.from(input.selectedOptions).map(opt => opt.value);
      if (!vals.length) return allowEmpty ? '' : (arg?.required ? '' : null);
      return vals;
    }
    const value = (input.value || '').trim();
    if (!value) return allowEmpty ? '' : (arg?.required ? '' : null);
    return value;
  }

  function parseSettingValueFromExec(exec, setting){
    const stdout = String(exec?.stdout ?? '').trim();
    if (!stdout) return undefined;
    try {
      const data = JSON.parse(stdout);
      if (data && typeof data === 'object'){
        if (setting?.key && data.hasOwnProperty(setting.key)) return data[setting.key];
        if (data.hasOwnProperty('value')) return data.value;
      }
    } catch (err) {
      /* ignore parse errors */
    }
    if (setting?.key){
      const match = stdout.match(new RegExp(`${setting.key}\\s*=\\s*([^\\n]+)`));
      if (match) return match[1].trim();
    }
    const lines = stdout.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    if (lines.length === 1) return lines[0];
    return undefined;
  }

  function applyValueToControl(input, arg, value){
    if (!input) return;
    const kind = input.dataset.kind || input.type;
    if (kind === 'toggle' || input.type === 'checkbox'){
      const truthy = value === true || value === 'true' || value === '1' || value === 1 || String(value).toLowerCase() === 'on';
      input.checked = !!truthy;
      return;
    }
    if (kind === 'select' && input.tagName === 'SELECT'){
      const allowEmpty = allowEmptyValue(arg);
      let vals = Array.isArray(value)
        ? value.map(v => String(v))
        : String(value ?? '').split(',').map(v => v.trim());
      if (!allowEmpty) vals = vals.filter(v => v);
      Array.from(input.options).forEach(opt => { opt.selected = vals.includes(opt.value); });
      if (!input.multiple){
        input.value = vals[0] !== undefined ? vals[0] : '';
      }
      return;
    }
    const strVal = Array.isArray(value) ? value[0] : value;
    if (kind === 'range'){
      if (strVal === undefined || strVal === null) return;
      input.value = String(strVal);
      if (input._valueLabel){
        const unit = input.dataset.unit || '';
        input._valueLabel.textContent = `${input.value}${unit}`;
      }
      return;
    }
    input.value = strVal === undefined || strVal === null ? '' : String(strVal);
  }

  function renderHelpEndpoints(ui, help){
    ui.endpointsRow.innerHTML = '';
    const endpoints = Array.isArray(help?.help_endpoints) ? help.help_endpoints : [];
    if (!endpoints.length){
      const empty = document.createElement('div');
      empty.className = 'mut';
      empty.textContent = 'No nested help endpoints advertised.';
      ui.endpointsRow.append(empty);
      return;
    }
    endpoints.forEach(raw => {
      const ep = normalizeHelpEndpoint(raw);
      if (!ep?.path) return;
      const pill = makePill(ep.path || 'help');
      if (ep?.description) pill.title = ep.description;
      pill.addEventListener('click', () => {
        ui.menuSelect.value = ep.path || '/sys/help';
        ui.menuSelect.dispatchEvent(new Event('change'));
      });
      ui.endpointsRow.append(pill);
    });
  }

  function renderNodeSettings(node, key, ui, help){
    ui.settings.innerHTML = '';
    const settings = Array.isArray(help?.settings) ? help.settings : [];
    const commands = Array.isArray(help?.commands) ? help.commands : [];
    const setCmd = findCommand(commands, 'set');
    if (!settings.length || !setCmd){
      ui.settings.style.display = 'none';
      return;
    }
    const getCmd = findCommand(commands, 'get');
    ui.settings.style.display = 'grid';
    const store = getNodeHelpStore(key);
    const setPath = deriveCommandPath(store.activePath, setCmd.name);
    const getPath = getCmd ? deriveCommandPath(store.activePath, getCmd.name) : null;
    const refreshTasks = [];

    settings.forEach(setting => {
      const card = document.createElement('div');
      card.className = 'node-setting';

      const head = document.createElement('div');
      head.className = 'node-setting-head';
      const left = document.createElement('div');
      const name = document.createElement('div');
      name.className = 'node-setting-name';
      name.textContent = setting?.key || 'setting';
      left.append(name);
      if (setting?.description){
        const desc = document.createElement('div');
        desc.className = 'node-setting-desc';
        desc.textContent = setting.description;
        left.append(desc);
      }
      const pathEl = document.createElement('div');
      pathEl.className = 'node-command-path';
      pathEl.textContent = setPath;
      head.append(left, pathEl);
      card.append(head);

      const { wrapper, input } = buildArgControl({ ...setting, key: setting?.key || 'setting' });
      card.append(wrapper);

      const actions = document.createElement('div');
      actions.className = 'node-setting-actions';
      const status = document.createElement('div');
      status.className = 'node-setting-status';
      const hint = document.createElement('div');
      hint.className = 'node-setting-auto';
      const isTextControl = input?.dataset?.kind === 'text';
      status.textContent = isTextControl ? 'Edit then apply' : 'Changes auto-apply';
      hint.textContent = isTextControl ? 'Press Apply to send text values' : 'Changes auto-apply (250ms debounce)';
      let setTimer = null;
      let suppressSet = false;
      let inFlight = false;
      let applyBtn = null;

      const runGet = async () => {
        if (!getCmd || !getPath || !input) return;
        const args = [];
        if (Array.isArray(getCmd.args) && getCmd.args.length) args.push(String(setting?.key || ''));
        status.textContent = `Fetching ${getPath}…`;
        try {
          const { exec } = await relayExecToNode(node, getPath, args);
          const ok = typeof exec?.rc === 'number' ? exec.rc === 0 : true;
          const summary = summarizeExec(getPath, exec);
          ui.output.value = summary;
          getNodeHelpStore(key).lastOutput = summary;
          const parsed = parseSettingValueFromExec(exec, setting);
          if (parsed !== undefined){
            suppressSet = true;
            applyValueToControl(input, setting, parsed);
            suppressSet = false;
            status.textContent = ok ? `Updated to ${parsed}` : 'Completed with errors';
          } else {
            status.textContent = ok ? 'Get completed' : 'Completed with errors';
          }
        } catch (err) {
          const msg = err.message || 'Command failed';
          ui.output.value = `${getPath}\n${msg}`;
          getNodeHelpStore(key).lastOutput = ui.output.value;
          status.textContent = msg;
        }
      };

      const runSet = () => {
        if (!input) return;
        if (inFlight){
          if (!setTimer) setTimer = setTimeout(() => { setTimer = null; runSet(); }, 250);
          return;
        }
        const allowEmpty = allowEmptyValue(setting);
        const val = readArgValue(input, setting);
        if (val === '' && !allowEmpty && setting?.required){
          status.textContent = `${setting?.key || 'value'} is required`;
          return;
        }
        if (val === null || val === undefined || (val === '' && !allowEmpty)){
          status.textContent = 'No value selected';
          return;
        }
        const normalized = Array.isArray(val) ? val.join(',') : val;
        inFlight = true;
        status.textContent = `Applying ${setPath}…`;
        relayExecToNode(node, setPath, [`${setting?.key || 'value'}=${normalized}`]).then(({ exec }) => {
          const ok = typeof exec?.rc === 'number' ? exec.rc === 0 : true;
          const summary = summarizeExec(setPath, exec);
          ui.output.value = summary;
          getNodeHelpStore(key).lastOutput = summary;
          status.textContent = ok ? 'Set applied' : 'Completed with errors';
        }).catch(err => {
          const msg = err.message || 'Command failed';
          ui.output.value = `${setPath}\n${msg}`;
          getNodeHelpStore(key).lastOutput = ui.output.value;
          status.textContent = msg;
        }).finally(() => {
          inFlight = false;
        });
      };

      const scheduleSet = () => {
        if (suppressSet) return;
        if (setTimer) clearTimeout(setTimer);
        setTimer = setTimeout(() => {
          setTimer = null;
          runSet();
        }, 250);
      };

      if (getCmd && getPath) refreshTasks.push(runGet);
      if (isTextControl){
        applyBtn = document.createElement('button');
        applyBtn.type = 'button';
        applyBtn.textContent = 'Apply';
        applyBtn.addEventListener('click', ev => { ev.stopPropagation(); runSet(); });
        if (input){
          input.addEventListener('keydown', ev => {
            if (ev.key === 'Enter'){
              ev.preventDefault();
              runSet();
            }
          });
        }
      } else {
        const eventName = input?.type === 'range' ? 'input' : (input?.tagName === 'SELECT' || input?.type === 'checkbox' ? 'change' : 'input');
        if (input) input.addEventListener(eventName, () => scheduleSet());
      }

      if (applyBtn) actions.append(applyBtn);
      actions.append(hint, status);
      card.append(actions);
      ui.settings.append(card);
    });

    if (refreshTasks.length){
      (async () => {
        for (const task of refreshTasks){
          await task();
          await delay(200);
        }
      })();
    }
  }

  function renderNodeCommands(node, key, ui, help){
    const store = getNodeHelpStore(key);
    if (!store.advanced){
      ui.commands.innerHTML = '';
      ui.commands.hidden = true;
      ui.commands.style.display = 'none';
      return;
    }
    ui.commands.hidden = false;
    ui.commands.style.display = 'grid';
    ui.commands.innerHTML = '';
    const commands = Array.isArray(help?.commands) ? help.commands : [];
    if (!commands.length){
      const empty = document.createElement('div');
      empty.className = 'mut';
      empty.textContent = help ? 'No commands advertised.' : 'Load a help endpoint to view commands.';
      ui.commands.append(empty);
      return;
    }
    commands.forEach(cmd => {
      const card = document.createElement('div');
      card.className = 'node-command';
      const head = document.createElement('div');
      head.className = 'node-command-head';
      const left = document.createElement('div');
      const name = document.createElement('div');
      name.className = 'node-command-name';
      name.textContent = cmd?.name || 'command';
      const desc = document.createElement('div');
      desc.className = 'mut';
      desc.textContent = cmd?.description || '';
      left.append(name, desc);
      const pathEl = document.createElement('div');
      pathEl.className = 'node-command-path';
      const fullPath = deriveCommandPath(store.activePath, cmd?.name || '');
      pathEl.textContent = fullPath;
      head.append(left, pathEl);
      card.append(head);

      const argsWrap = document.createElement('div');
      const inputs = [];
      if (Array.isArray(cmd?.args) && cmd.args.length){
        cmd.args.forEach(arg => {
          const { wrapper, input } = buildArgControl(arg);
          inputs.push({ arg, input });
          argsWrap.append(wrapper);
        });
      } else {
        const none = document.createElement('div');
        none.className = 'mut';
        none.textContent = 'No arguments';
        argsWrap.append(none);
      }
      card.append(argsWrap);

      const actions = document.createElement('div');
      actions.className = 'node-command-actions';
      const runBtn = document.createElement('button');
      runBtn.type = 'button';
      runBtn.textContent = 'Run';
      const status = document.createElement('div');
      status.className = 'node-command-status';
      status.textContent = 'Idle';
      actions.append(runBtn, status);
      card.append(actions);

      runBtn.addEventListener('click', ev => {
        ev.stopPropagation();
        const args = [];
        for (const entry of inputs){
          const val = readArgValue(entry.input, entry.arg);
          if (val === ''){
            status.textContent = `${entry.arg?.key || 'arg'} is required`;
            return;
          }
          if (val === null || val === undefined) continue;
          if (Array.isArray(val)) args.push(...val.map(v => String(v)));
          else args.push(String(val));
        }
        runBtn.disabled = true;
        status.textContent = `Running ${fullPath}…`;
        relayExecToNode(node, fullPath, args).then(({ exec }) => {
          const ok = typeof exec?.rc === 'number' ? exec.rc === 0 : true;
          const summary = summarizeExec(fullPath, exec);
          ui.output.value = summary;
          getNodeHelpStore(key).lastOutput = summary;
          status.textContent = ok ? 'Success' : 'Completed with errors';
        }).catch(err => {
          const msg = err.message || 'Command failed';
          ui.output.value = `${fullPath}\n${msg}`;
          getNodeHelpStore(key).lastOutput = ui.output.value;
          status.textContent = msg;
        }).finally(() => {
          runBtn.disabled = false;
        });
      });

      ui.commands.append(card);
    });
  }

  function syncNodeHelpMenu(ui, store){
    const entries = Array.from(store.endpoints.entries()).map(([path, meta]) => ({
      path,
      description: meta?.description || path
    }));
    entries.sort((a, b) => a.path.localeCompare(b.path));
    const prevValue = ui.menuSelect.value;
    ui.menuSelect.innerHTML = '';
    entries.forEach(entry => {
      const opt = document.createElement('option');
      opt.value = entry.path;
      opt.textContent = `${entry.path} — ${entry.description}`.trim();
      if (entry.path === store.activePath) opt.selected = true;
      ui.menuSelect.append(opt);
    });
    if (prevValue) ui.menuSelect.value = store.activePath || prevValue;
  }

  function renderNodeHelp(node, key, ui){
    const store = getNodeHelpStore(key);
    const help = store.cache.get(store.activePath) || null;
    if (ui.advancedInput) ui.advancedInput.checked = !!store.advanced;
    syncNodeHelpMenu(ui, store);
    renderHelpEndpoints(ui, help);
    const statusParts = [];
    if (store.loadingPath) statusParts.push(`Loading ${store.loadingPath}…`);
    if (store.error) statusParts.push(`Error: ${store.error}`);
    if (!store.loadingPath && !store.error && help){
      const cap = help.cap ? `${help.cap}${help.contract_version ? ` v${help.contract_version}` : ''}` : 'help';
      statusParts.push(`Loaded ${store.activePath} • ${cap}`);
    }
    if (!store.advanced) statusParts.push('Advanced commands hidden');
    if (!statusParts.length) statusParts.push('Select a help endpoint to view commands.');
    ui.status.textContent = statusParts.join(' ');
    renderNodeSettings(node, key, ui, help);
    renderNodeCommands(node, key, ui, help);
    if (store.lastOutput) ui.output.value = store.lastOutput;
  }

function buildNodeCard(node, idx){
  const key = nodeKey(node, idx);
  const expanded = nodesState.expanded.has(key);
  const nodeDiv = document.createElement('div');
  nodeDiv.className = 'node' + (expanded ? ' expanded' : '');

  const head = document.createElement('div');
  head.className = 'node-head';
  head.tabIndex = 0;
  head.setAttribute('role', 'button');
  head.setAttribute('aria-expanded', expanded ? 'true' : 'false');

  const top = document.createElement('div');
  top.className = 'top';
  const roleSpan = document.createElement('span');
  roleSpan.className = 'pill role';
  roleSpan.textContent = node.role || '—';
  const ipSpan = document.createElement('span');
  ipSpan.className = 'ip';
  const portValue = node.port;
  const hasPort = portValue !== null && portValue !== undefined && portValue !== '';
  const portText = hasPort ? portValue : '';
  ipSpan.textContent = hasPort ? `${node.ip || '—'}:${portText}` : (node.ip || '—');
  top.append(roleSpan, ipSpan);

  const deviceLine = document.createElement('div');
  const strong = document.createElement('strong');
  strong.textContent = node.device || '—';
  const meta = document.createElement('span');
  meta.className = 'meta version';
  meta.textContent = node.version ? `v${node.version}` : '';
  deviceLine.append(strong, document.createTextNode(' '), meta);

  const lastSeen = document.createElement('div');
  lastSeen.className = 'meta last-seen';
  lastSeen.textContent = `last seen ${formatAgoFromSeconds(node.last_seen)}`;

  head.append(top, deviceLine, lastSeen);
  nodeDiv.append(head);
  nodeDiv.dataset.nodeKey = key;

  const controls = document.createElement('div');
  controls.className = 'node-controls';
  controls.style.display = expanded ? 'grid' : 'none';

  const helpUi = createNodeHelpElements();
  const store = getNodeHelpStore(key);
  if (helpUi.advancedInput){
    helpUi.advancedInput.checked = !!store.advanced;
    helpUi.advancedInput.addEventListener('change', ev => {
      ev.stopPropagation();
      const current = getNodeHelpStore(key);
      current.advanced = !!helpUi.advancedInput.checked;
      renderNodeHelp(node, key, helpUi);
    });
  }
  controls.append(helpUi.wrapper);
  nodeDiv.append(controls);

  const loadHelp = (path, force = false) => {
    const desired = path || getNodeHelpStore(key).activePath || '/sys/help';
    void fetchNodeHelp(node, key, desired, helpUi, force);
  };

  helpUi.menuSelect.addEventListener('change', ev => {
    ev.stopPropagation();
    loadHelp(helpUi.menuSelect.value || '/sys/help', false);
  });
  helpUi.refreshBtn.addEventListener('click', ev => {
    ev.stopPropagation();
    loadHelp(getNodeHelpStore(key).activePath || helpUi.menuSelect.value || '/sys/help', true);
  });
  if (expanded){
    renderNodeHelp(node, key, helpUi);
    loadHelp(getNodeHelpStore(key).activePath, false);
  }

  const toggle = () => {
    const isOpen = nodesState.expanded.has(key);
    if (isOpen){
      nodesState.expanded.delete(key);
      controls.style.display = 'none';
      nodeDiv.classList.remove('expanded');
      head.setAttribute('aria-expanded', 'false');
    } else {
      nodesState.expanded.add(key);
      controls.style.display = 'grid';
      nodeDiv.classList.add('expanded');
      head.setAttribute('aria-expanded', 'true');
      renderNodeHelp(node, key, helpUi);
      loadHelp(getNodeHelpStore(key).activePath, false);
    }
  };

  head.addEventListener('click', toggle);
  head.addEventListener('keydown', ev => {
    if (ev.key === 'Enter' || ev.key === ' '){
      ev.preventDefault();
      toggle();
    }
  });

  return nodeDiv;
}

function renderNodes(data){
  const nodes = Array.isArray(data?.nodes) ? data.nodes : [];
  const normalizedNodes = nodes.map(normalizeNodeRecord).filter(Boolean);
  const nextListSignature = JSON.stringify(normalizedNodes);
  const listChanged = nodesState.listSignature !== nextListSignature;
  nodesState.list = nodes;
  if (listChanged){
    nodesState.listSignature = nextListSignature;
    nodesState.version += 1;
  }
  nodesState.scanning = !!data?.scanning;
  const scanEnabled = data?.scan_feature_enabled !== false;
  const parts = [];
  parts.push(`${nodes.length} node${nodes.length === 1 ? '' : 's'}`);
  if (nodesState.scanning){
    const pct = typeof data?.progress_pct === 'number'
      ? Math.max(0, Math.min(100, Math.round(data.progress_pct)))
      : null;
    parts.push(pct === null ? 'scanning…' : `scanning ${pct}%`);
  } else {
    parts.push(scanEnabled ? 'scan idle' : 'scan disabled');
  }
  setNodesSummary(`Nodes: ${parts.filter(Boolean).join(' • ')}`);
  const scanBtn = document.getElementById('nodesScanBtn');
  if (scanBtn) scanBtn.disabled = !scanEnabled || !!data?.scanning;
  if (listChanged) updateSlotPanels();
  if (!listChanged){
    nodes.forEach((node, idx) => {
      const key = nodeKey(node, idx);
      const card = document.querySelector(`.node[data-node-key="${key}"] .meta.last-seen`);
      if (card) card.textContent = `last seen ${formatAgoFromSeconds(node.last_seen)}`;
    });
  }
}

async function fetchNodes(){
  if (nodesState.loading){
    nodesState.pendingRefresh = true;
    return;
  }
  nodesState.loading = true;
  try {
    const res = await fetch('/nodes', { cache: 'no-store' });
    if (!res.ok){
      const detail = await res.text().catch(() => '');
      setNodesSummary(`Nodes: Failed (${res.status} ${detail.trim()})`);
      const wasEmpty = nodesState.listSignature === '[]';
      nodesState.list = [];
      nodesState.listSignature = '[]';
      if (!wasEmpty) nodesState.version += 1;
      nodesState.scanning = false;
      if (!wasEmpty) updateSlotPanels();
    } else {
      const data = await res.json();
      renderNodes(data);
    }
  } catch (err) {
    setNodesSummary(`Nodes: Failed (${err.message})`);
    const wasEmpty = nodesState.listSignature === '[]';
    nodesState.list = [];
    nodesState.listSignature = '[]';
    if (!wasEmpty) nodesState.version += 1;
    nodesState.scanning = false;
    if (!wasEmpty) updateSlotPanels();
  } finally {
    nodesState.loading = false;
    if (nodesState.pendingRefresh){
      nodesState.pendingRefresh = false;
      fetchNodes();
      return;
    }
    scheduleNodesPoll();
  }
}

function scheduleNodesPoll(){
  if (nodesState.pollTimer){
    clearTimeout(nodesState.pollTimer);
    nodesState.pollTimer = null;
  }
  const delay = nodesState.scanning ? NODES_SCAN_POLL_MS : NODES_POLL_MS;
  nodesState.pollTimer = setTimeout(() => { nodesState.pollTimer = null; fetchNodes(); }, delay);
}

async function triggerNodesScan(){
  $('#nodesScanBtn').disabled = true;
  try {
    await fetch('/nodes', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: '{}' });
  } catch (err) {
    setNodesSummary(`Nodes: Scan failed (${err.message})`);
  } finally {
    fetchNodes();
  }
}

function renderSync(data){
  if (!data){
    syncState.slots = Array.from({ length: MAX_SYNC_SLOTS }, () => null);
    syncState.meta = new Map();
    syncState.waiting = [];
    syncState.refMs = 0;
    const signature = JSON.stringify({ slots: [], waiting: [], meta: [], refMs: 0 });
    const changed = syncState.signature !== signature;
    syncState.signature = signature;
    setSyncSummary('Sync: No data');
    if (changed) updateSlotPanels();
    return;
  }
  const slotsMeta = new Map();
  (Array.isArray(data.slots) ? data.slots : []).forEach(entry => {
    const slotNum = Number(entry?.slot);
    if (Number.isFinite(slotNum) && slotNum >= 1 && slotNum <= MAX_SYNC_SLOTS){
      slotsMeta.set(slotNum, entry);
    }
  });
  const slots = Array.from({ length: MAX_SYNC_SLOTS }, () => null);
  const waiting = [];
  let refMs = 0;
  (Array.isArray(data.slaves) ? data.slaves : []).forEach(rec => {
    if (!rec || typeof rec !== 'object') return;
    if (Number.isFinite(rec.last_seen_ms) && rec.last_seen_ms > refMs) refMs = rec.last_seen_ms;
    const slotNum = Number(rec.slot);
    if (Number.isFinite(slotNum) && slotNum >= 1 && slotNum <= MAX_SYNC_SLOTS){
      slots[slotNum - 1] = rec;
    } else {
      waiting.push(rec);
    }
  });
  syncState.slots = slots;
  syncState.meta = slotsMeta;
  syncState.waiting = waiting;
  syncState.refMs = refMs;
  const signature = JSON.stringify({
    slots: slots.map(normalizeSlaveSignature),
    waiting: waiting.map(normalizeSlaveSignature).filter(Boolean),
    meta: Array.from(slotsMeta.entries()),
    refMs
  });
  const changed = syncState.signature !== signature;
  syncState.signature = signature;
  setSyncSummary(`Sync: Updated ${new Date().toLocaleTimeString()} • ${ (data.slaves?.length) || 0 } known`);
  if (changed){
    updateSlotPanels();
  } else {
    for (let slot = 1; slot <= MAX_SYNC_SLOTS; slot += 1){
      const rec = syncState.slots[slot - 1] || null;
      updateSlotSummary(slot, rec);
      updateSlotWaiting(slot);
    }
  }
}

async function sendMoveRequest(slaveId, slotTarget){
  if (!slaveId) return;
  if (slotTarget !== null && !Number.isFinite(slotTarget)) return;
  const label = slotTarget === null ? `unassign ${slaveId}` : `move ${slaveId} → slot ${slotTarget}`;
  setSyncBusy(true);
  setSyncSummary(`Sync: Requesting ${label}…`);
  try {
    const res = await fetch('/sync/push', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ moves: [{ slave_id: slaveId, slot: slotTarget }] })
    });
    if (!res.ok){
      const txt = await res.text().catch(() => '');
      throw new Error(`${res.status} ${txt.trim()}`.trim());
    }
    setSyncSummary(`Sync: Move queued for ${slaveId}`);
    await fetchSync();
  } catch (err) {
    setSyncSummary(`Sync: Move failed (${err.message})`);
  } finally {
    setSyncBusy(false);
  }
}

async function fetchSync(){
  if (syncUiState.loading){
    syncUiState.pendingRefresh = true;
    return;
  }
  syncUiState.loading = true;
  setSyncSummary('Sync: Loading /sync/slaves…');
  try {
    const res = await fetch('/sync/slaves', { cache: 'no-store' });
    if (!res.ok){
      const text = await res.text().catch(() => '');
      setSyncSummary(`Sync: Failed (${res.status} ${text.trim()})`);
      syncState.slots = Array.from({ length: MAX_SYNC_SLOTS }, () => null);
      syncState.meta = new Map();
      syncState.waiting = [];
      const signature = JSON.stringify({ slots: [], waiting: [], meta: [], refMs: 0 });
      const changed = syncState.signature !== signature;
      syncState.signature = signature;
      if (changed) updateSlotPanels();
      return;
    }
    const data = await res.json();
    renderSync(data);
  } catch (err) {
    setSyncSummary(`Sync: Failed (${err.message})`);
    syncState.slots = Array.from({ length: MAX_SYNC_SLOTS }, () => null);
    syncState.meta = new Map();
    syncState.waiting = [];
    const signature = JSON.stringify({ slots: [], waiting: [], meta: [], refMs: 0 });
    const changed = syncState.signature !== signature;
    syncState.signature = signature;
    if (changed) updateSlotPanels();
  } finally {
    syncUiState.loading = false;
    if (syncUiState.pendingRefresh){
      syncUiState.pendingRefresh = false;
      fetchSync();
      return;
    }
    scheduleSyncPoll();
  }
}

function scheduleSyncPoll(){
  if (syncUiState.pollTimer){
    clearTimeout(syncUiState.pollTimer);
    syncUiState.pollTimer = null;
  }
  syncUiState.pollTimer = setTimeout(() => { syncUiState.pollTimer = null; fetchSync(); }, SYNC_POLL_MS);
}

async function requestReplay(slotNumber){
  if (!Number.isFinite(slotNumber)) return;
  setSyncBusy(true);
  setSyncSummary(`Sync: Requesting replay for slot ${slotNumber}…`);
  try {
    const res = await fetch('/sync/push', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ replay_slots: [slotNumber] })
    });
    if (!res.ok){
      const txt = await res.text().catch(() => '');
      throw new Error(`${res.status} ${txt.trim()}`.trim());
    }
    setSyncSummary(`Sync: Replay requested for slot ${slotNumber}`);
    await fetchSync();
  } catch (err) {
    setSyncSummary(`Sync: Replay failed (${err.message})`);
  } finally {
    setSyncBusy(false);
  }
}

function attachSlotHandlers(){
  document.querySelectorAll('.slot-replay-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const slot = Number(btn.dataset.slot);
      if (!Number.isFinite(slot)) return;
      void requestReplay(slot);
    });
  });
  document.querySelectorAll('.slot-move-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const slot = Number(btn.dataset.slot);
      if (!Number.isFinite(slot)) return;
      const select = document.getElementById(`slot${slot}MoveSelect`);
      if (!select) return;
      const value = select.value;
      if (!value) return;
      const rec = syncState.slots[slot - 1];
      if (!rec || !rec.id) return;
      let target = null;
      if (value !== '__unassign__'){
        target = Number(value);
        if (!Number.isFinite(target)) return;
      }
      select.selectedIndex = 0;
      void sendMoveRequest(rec.id, target);
    });
  });
  document.querySelectorAll('.slot-assign-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const slot = Number(btn.dataset.slot);
      if (!Number.isFinite(slot)) return;
      const select = document.getElementById(`slot${slot}AssignSelect`);
      if (!select || !select.value) return;
      const slaveId = select.value;
      select.selectedIndex = 0;
      void sendMoveRequest(slaveId, slot);
    });
  });
}

initCardToggle('logsCard');
initCardToggle('pixelpilotMiniRkCard');
initCardToggle('dvrCard');
const capsRefreshBtn = document.getElementById('capsRefreshBtn');
if (capsRefreshBtn) capsRefreshBtn.addEventListener('click', () => { void fetchCaps(); });
ensureLogsHandlers();
ensureDvrHandlers();
initTabs();
attachSlotHandlers();
initSlotActionSegments();
$('#nodesScanBtn').addEventListener('click', triggerNodesScan);
void fetchCaps();
fetchNodes();
fetchSync();
</script>
