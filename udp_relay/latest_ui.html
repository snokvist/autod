<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>UDP Relay Manager · Compact UI</title>
<style>
:root{
  --bg:#0f1116; --panel:#151823; --muted:#8a93a5; --text:#e8ecf1;
  --accent:#7bd389; --warn:#e7b75f; --err:#ff7a7a;
  --green:#13391f; --green-b:#1f6b43;
  --blue:#0f2a45;  --blue-b:#2366a2;
  --yellow:#3b2e13;--yellow-b:#a68124;
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
body{margin:0;font:15px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text)}
header{display:flex;gap:.75rem;flex-wrap:wrap;align-items:center;padding:14px 16px;background:#0c0f17;position:sticky;top:0;z-index:2;border-bottom:1px solid #1e2231}
h1{font-size:18px;margin:0 auto 0 0;letter-spacing:.2px}
button,input{font:inherit}
button{cursor:pointer;min-height:44px;border-radius:14px;padding:10px 14px;border:1px solid #242b3d;background:var(--panel);color:var(--text)}
button.primary{background:linear-gradient(180deg,#1f6b43,#165538);border-color:#1f6b43}
button.warn{background:#3b2e13;border-color:#5c4723;color:#ffd990}
.pill{border-radius:999px;padding:8px 12px}
main{max-width:1200px;margin:16px auto;padding:0 12px;display:grid;grid-template-columns:1.1fr .9fr;gap:14px}
@media(max-width:980px){main{grid-template-columns:1fr;gap:12px}}
section{background:var(--panel);border:1px solid #20273a;border-radius:18px;overflow:hidden}
section h2{margin:0;padding:10px 12px;border-bottom:1px solid #20273a;font-size:14px;color:#aab3c7;background:#121626;letter-spacing:.3px}
.pad{padding:12px}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace}
.muted{color:var(--muted)}
.chips{display:flex;flex-wrap:wrap;gap:10px}
.chip{border:2px dashed #2a3247;border-radius:22px;padding:10px 14px;display:flex;gap:10px;align-items:center;user-select:none;min-height:44px;min-width:120px;touch-action:none}
.chip[draggable=true]{cursor:grab}
.chip.selected{outline:3px solid #4ea2ff}
.chip .tag{opacity:.7;font-size:12px}
.chip .x{margin-left:8px;border:none;background:transparent;color:#ffb3b3;font-weight:700;cursor:pointer;padding:2px 6px;border-radius:8px;min-height:0}
.chip .x:hover{background:#2a0f0f}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:12px}
.card{border:1px solid #252d40;border-radius:16px;padding:12px;display:flex;flex-direction:column;gap:10px}
.card.g{background:var(--green);border-color:var(--green-b)}
.card.b{background:var(--blue);border-color:var(--blue-b)}
.card.y{background:var(--yellow);border-color:var(--yellow-b)}
.drop{min-height:70px;border:2px dashed rgba(255,255,255,.15);border-radius:12px;padding:10px;display:flex;align-items:center;justify-content:center}
.drop.drag-over{outline:3px solid rgba(255,255,255,.2)}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.small{font-size:12px}
.log{height:140px;overflow:auto;background:#0c0f17;border:1px solid #1e2231;border-radius:12px;padding:10px}
.ok{color:var(--accent)} .warn{color:var(--warn)} .err{color:var(--err)}
hr.sep{border:none;border-top:1px solid #2a3247;margin:6px 0}
.card .head{display:flex;justify-content:space-between;gap:8px;align-items:center}
.bindlist{display:flex;flex-wrap:wrap;gap:8px}
.bindpill{background:rgba(0,0,0,.2);border:1px solid rgba(255,255,255,.2);padding:6px 10px;border-radius:999px;display:flex;align-items:center;gap:8px}
.bindpill .rm{border:none;background:transparent;color:#ffd0d0;font-weight:700;cursor:pointer;padding:0 4px;border-radius:6px}
.bindpill .rm:hover{background:#2a0f0f}
</style>
</head>
<body>
<header>
  <h1>UDP Relay Manager · Compact UI</h1>
  <button class="primary pill" id="refresh">Refresh</button>
  <button class="warn pill" id="clearAll">Clear ALL</button>
</header>

<main>
  <section>
    <h2>Sources (Binds) — drag or tap-then-tap onto a target</h2>
    <div class="pad">
      <div id="bindChips" class="chips"></div>
      <div class="small muted" style="margin-top:6px">
        Green = 1→1 (exclusive), Blue = many→1, Yellow = 1→many (group)
      </div>
    </div>
  </section>

  <section>
    <h2>Targets (Destinations & Groups)</h2>
    <div class="pad">
      <div class="muted small" style="margin-bottom:8px">
        Drop a bind onto a card. Each card shows its currently mapped binds below it.
      </div>
      <div id="gridG" class="grid" style="margin-bottom:12px"></div>
      <div id="gridB" class="grid" style="margin-bottom:12px"></div>
      <div id="gridY" class="grid"></div>
    </div>
  </section>

  <section>
    <h2>Unmapped Binds</h2>
    <div class="pad">
      <div id="unmapped" class="chips"></div>
    </div>
  </section>

  <section>
    <h2>Log</h2>
    <div class="pad"><div id="log" class="log mono"></div></div>
  </section>
</main>

<script>
(function(){
  const $ = s => document.querySelector(s);
  const log = (m,c='')=>{
    const el = $('#log');
    const d = document.createElement('div');
    if(c) d.className=c;
    d.textContent = `[${new Date().toLocaleTimeString()}] ${m}`;
    el.prepend(d);
  };

  const GET  = p => fetch(p).then(r=>{if(!r.ok) throw new Error(r.statusText); return p.includes('/status')?r.json():r.text()});
  const POST = (p,b)=> fetch(p,{method:'POST',headers:{'Content-Type':'application/json'},body:b})
                        .then(async r=>{if(!r.ok) throw new Error(await r.text()); try{return await r.json()}catch{return await r.text()}});
  const action = (v,o)=>POST(`/api/v1/action/${v}`, JSON.stringify(o||{}));

  const state = {
    status:null,
    cfgText:'',
    greens:[],              // ["ip:port", ...]
    blues:[],               // ["ip:port", ...]
    groups:[],              // [{name, members:["ip:port", ...]}]
    selected:null           // selected bind port
  };

  /* ---------- Config parsing (read-only) ---------- */
  const normDest = (s)=>{
    s = String(s||'').trim();
    const m = s.match(/^([^:\s]+):(\d{1,5})$/);
    return m ? `${m[1]}:${m[2]}` : null;
  };

  function parseConfig(txt){
    const greens = [];
    const blues  = [];
    const groups = [];
    for(const raw of String(txt||'').replace(/\r/g,'').split(/\n/)){
      const ln = raw.replace(/[;#].*$/,'').trim(); // strip comments
      if(!ln) continue;
      let m;
      if((m = ln.match(/^\s*dest_green\s*=\s*(\S+)\s*$/))){
        const d = normDest(m[1]); if(d && !greens.includes(d)) greens.push(d);
        continue;
      }
      if((m = ln.match(/^\s*dest_blue\s*=\s*(\S+)\s*$/))){
        const d = normDest(m[1]); if(d && !blues.includes(d)) blues.push(d);
        continue;
      }
      if((m = ln.match(/^\s*group_yellow\s*=\s*([^|]+)\|(.+)\s*$/))){
        const name = m[1].trim();
        const members = [];
        for(const t of m[2].split(',')){
          const d = normDest(t);
          if(d && !members.includes(d)) members.push(d);
        }
        if(name && members.length) groups.push({name, members});
        continue;
      }
    }
    return {greens,blues,groups};
  }

  /* ---------- Status helpers ---------- */
  const relays = ()=> (state.status && Array.isArray(state.status.relays)) ? state.status.relays : [];
  const listTokens = r => (r.dests||[]).map(d=>`${d.ip}:${d.port}`);

  function buildDestIndex(){
    // Map dest token -> array of {port, pkts}
    const idx = new Map();
    for(const r of relays()){
      const tokens = listTokens(r);
      for(const d of (r.dests||[])){
        const token = `${d.ip}:${d.port}`;
        if(!idx.has(token)) idx.set(token, []);
        idx.get(token).push({port:r.port, pkts:d.pkts||0, in:r.pkts_in||0});
      }
    }
    return idx;
  }
  function buildGroupIndex(groups){
    // Map group name -> array of {port, in, outSum} for binds whose dest set equals group set
    const gidx = new Map();
    for(const g of groups) gidx.set(g.name, []);
    for(const r of relays()){
      const tokens = listTokens(r).sort();
      for(const g of groups){
        const gm = [...g.members].sort();
        if(tokens.length === gm.length && tokens.every((t,i)=>t===gm[i])){
          // sum pkts for those tokens
          let outSum = 0;
          for(const d of (r.dests||[])){
            if(g.members.includes(`${d.ip}:${d.port}`)) outSum += (d.pkts||0);
          }
          gidx.get(g.name).push({port:r.port, in:r.pkts_in||0, out:outSum});
          break;
        }
      }
    }
    return gidx;
  }

  /* ---------- Actions ---------- */
  async function removeDestFromPort(port, dest){
    await action('clear_to', {port, dest});
  }
  async function clearDestinationEverywhere(dest){
    for(const r of relays()){
      if(listTokens(r).includes(dest)) await removeDestFromPort(r.port, dest);
    }
  }
  async function clearGroupFromPort(port, members){
    for(const d of members) await removeDestFromPort(port, d);
  }
  async function clearGroupEverywhere(members){
    for(const r of relays()){
      const tokens = listTokens(r);
      let hasAny = members.some(d=>tokens.includes(d));
      if(hasAny){
        for(const d of members) await removeDestFromPort(r.port, d);
      }
    }
  }
  async function clearAll(){
    for(const r of relays()) await action('clear',{port:r.port});
  }

  async function dropGreen(srcPort, dest){
    // Exclusive: evict from others, then set
    await clearDestinationEverywhere(dest);
    await action('set', {port:srcPort, dests:[dest]});
    log(`bind ${srcPort} → ${dest} (exclusive)`,'ok');
    await refresh();
  }
  async function dropBlue(srcPort, dest){
    // Append only if not present
    const r = relays().find(x=>x.port===srcPort);
    if(!r) return;
    if(!listTokens(r).includes(dest)){
      await action('append',{port:srcPort, dests:[dest]});
      log(`bind ${srcPort} +→ ${dest}`,'ok');
      await refresh();
    } else {
      log(`bind ${srcPort} already has ${dest}`,'warn');
    }
  }
  async function dropYellow(srcPort, groupMembers){
    // Replace with the group's members
    await action('set', {port:srcPort, dests:[...groupMembers]});
    log(`bind ${srcPort} → [${groupMembers.join(', ')}] (group)`, 'ok');
    await refresh();
  }

  /* ---------- Drag/tap helpers ---------- */
  function wireDrop(el, type, payload){
    // type: 'green' with token, 'blue' with token, 'yellow' with members[]
    const onDo = async (srcPort)=>{
      try{
        if(type==='green') await dropGreen(srcPort, payload);
        else if(type==='blue') await dropBlue(srcPort, payload);
        else await dropYellow(srcPort, payload); // yellow
      }catch(e){ log(e,'err'); }
    };
    const allow = e => { e.preventDefault(); e.stopPropagation(); };
    el.addEventListener('dragenter', allow);
    el.addEventListener('dragover', e=>{ allow(e); el.classList.add('drag-over'); });
    el.addEventListener('dragleave', ()=> el.classList.remove('drag-over'));
    el.addEventListener('drop', e=>{
      allow(e); el.classList.remove('drag-over');
      const txt = e.dataTransfer.getData('text/plain'); const p = parseInt(txt,10);
      if(p) onDo(p);
    });
    el.addEventListener('click', ()=>{
      if(state.selected) onDo(state.selected);
    });
  }

  /* ---------- Rendering ---------- */
  function renderBinds(){
    const wrap = $('#bindChips');
    const sel = state.selected;
    wrap.innerHTML = '';
    for(const r of relays()){
      const el = document.createElement('div');
      el.className = 'chip';
      el.draggable = true;
      el.dataset.port = String(r.port);
      el.innerHTML = `<strong>bind ${r.port}</strong> <span class="tag">in:${r.pkts_in||0}</span>`;
      el.addEventListener('dragstart', e=>{
        e.dataTransfer.setData('text/plain', String(r.port));
        e.dataTransfer.effectAllowed='copy';
      });
      el.addEventListener('click', ()=>{
        if(state.selected===r.port){ state.selected=null; el.classList.remove('selected'); }
        else {
          state.selected=r.port;
          document.querySelectorAll('.chip').forEach(c=>c.classList.remove('selected'));
          el.classList.add('selected');
        }
      });
      if(sel===r.port) el.classList.add('selected');
      wrap.appendChild(el);
    }
  }

  function mkBindPill(port, info, remover){
    const p = document.createElement('span');
    p.className = 'bindpill small mono';
    const pk = (info && typeof info.pkts!=='undefined') ? ` · pkts:${info.pkts}` : '';
    const inpk = (info && typeof info.in!=='undefined') ? ` · in:${info.in}` : '';
    p.innerHTML = `bind ${port}<span class="muted">${inpk}${pk}</span>`;
    const x = document.createElement('button');
    x.className = 'rm';
    x.title = 'Remove mapping';
    x.textContent = '×';
    x.onclick = remover;
    p.appendChild(x);
    return p;
  }

  function renderTargets(){
    const gridG = $('#gridG'), gridB = $('#gridB'), gridY = $('#gridY');
    gridG.innerHTML = ''; gridB.innerHTML = ''; gridY.innerHTML = '';

    const dIdx = buildDestIndex();
    const gIdx = buildGroupIndex(state.groups);

    // Greens
    for(const d of state.greens){
      const card = document.createElement('div');
      card.className = 'card g';
      card.innerHTML = `
        <div class="head">
          <div><strong>GREEN</strong> <span class="mono">${d}</span></div>
          <div class="row">
            <button class="small" data-clear="1">Clear this dest</button>
          </div>
        </div>
        <div class="drop small muted">Drop a bind here (exclusive 1→1)</div>
        <hr class="sep"/>
        <div class="small muted">Mapped binds:</div>
        <div class="bindlist"></div>
      `;
      const drop = card.querySelector('.drop');
      wireDrop(drop, 'green', d);

      // Binds under this dest
      const list = card.querySelector('.bindlist');
      const arr = dIdx.get(d)||[];
      if(arr.length===0){
        const m = document.createElement('div');
        m.className='muted small';
        m.textContent='(none)';
        list.appendChild(m);
      }else{
        for(const it of arr){
          const pill = mkBindPill(it.port, {pkts:it.pkts, in:it.in}, async ()=>{
            try{
              await removeDestFromPort(it.port, d);
              log(`Removed bind ${it.port} → ${d}`,'ok');
              await refresh();
            }catch(e){ log(e,'err'); }
          });
          list.appendChild(pill);
        }
      }

      card.querySelector('[data-clear]')?.addEventListener('click', async ()=>{
        try{
          await clearDestinationEverywhere(d);
          log(`Cleared all binds from ${d}`,'ok');
          await refresh();
        }catch(e){ log(e,'err'); }
      });

      gridG.appendChild(card);
    }

    // Blues
    for(const d of state.blues){
      const card = document.createElement('div');
      card.className = 'card b';
      card.innerHTML = `
        <div class="head">
          <div><strong>BLUE</strong> <span class="mono">${d}</span></div>
          <div class="row">
            <button class="small" data-clear="1">Clear this dest</button>
          </div>
        </div>
        <div class="drop small muted">Drop a bind here (append many→1)</div>
        <hr class="sep"/>
        <div class="small muted">Mapped binds:</div>
        <div class="bindlist"></div>
      `;
      const drop = card.querySelector('.drop');
      wireDrop(drop, 'blue', d);

      const list = card.querySelector('.bindlist');
      const arr = dIdx.get(d)||[];
      if(arr.length===0){
        const m = document.createElement('div');
        m.className='muted small';
        m.textContent='(none)';
        list.appendChild(m);
      }else{
        for(const it of arr){
          const pill = mkBindPill(it.port, {pkts:it.pkts, in:it.in}, async ()=>{
            try{
              await removeDestFromPort(it.port, d);
              log(`Removed bind ${it.port} → ${d}`,'ok');
              await refresh();
            }catch(e){ log(e,'err'); }
          });
          list.appendChild(pill);
        }
      }

      card.querySelector('[data-clear]')?.addEventListener('click', async ()=>{
        try{
          await clearDestinationEverywhere(d);
          log(`Cleared all binds from ${d}`,'ok');
          await refresh();
        }catch(e){ log(e,'err'); }
      });

      gridB.appendChild(card);
    }

    // Yellows (groups)
    for(const g of state.groups){
      const card = document.createElement('div');
      card.className = 'card y';
      const members = g.members.join(', ');
      card.innerHTML = `
        <div class="head">
          <div><strong>YELLOW</strong> <span class="mono">${g.name}</span></div>
          <div class="row">
            <button class="small" data-clear="1">Clear this group</button>
          </div>
        </div>
        <div class="small muted">Members: <span class="mono">${members}</span></div>
        <div class="drop small muted">Drop a bind here (replace with group 1→many)</div>
        <hr class="sep"/>
        <div class="small muted">Mapped binds:</div>
        <div class="bindlist"></div>
      `;
      const drop = card.querySelector('.drop');
      wireDrop(drop, 'yellow', g.members);

      const list = card.querySelector('.bindlist');
      const arr = (new Map(buildGroupIndex(state.groups))).get(g.name) || gIdx.get(g.name) || [];
      if(arr.length===0){
        const m = document.createElement('div');
        m.className='muted small';
        m.textContent='(none)';
        list.appendChild(m);
      }else{
        for(const it of arr){
          const pill = mkBindPill(it.port, {in:it.in}, async ()=>{
            try{
              await clearGroupFromPort(it.port, g.members);
              log(`Removed bind ${it.port} from group ${g.name}`,'ok');
              await refresh();
            }catch(e){ log(e,'err'); }
          });
          list.appendChild(pill);
        }
      }

      card.querySelector('[data-clear]')?.addEventListener('click', async ()=>{
        try{
          await clearGroupEverywhere(g.members);
          log(`Cleared group ${g.name} from all binds`,'ok');
          await refresh();
        }catch(e){ log(e,'err'); }
      });

      gridY.appendChild(card);
    }
  }

  function renderUnmapped(){
    const box = $('#unmapped');
    box.innerHTML = '';
    const items = [];
    for(const r of relays()){
      const hasAny = (r.dests||[]).length>0;
      if(!hasAny){
        const el = document.createElement('div');
        el.className='chip';
        el.innerHTML = `<strong>bind ${r.port}</strong> <span class="tag">in:${r.pkts_in||0}</span>`;
        items.push(el);
      }
    }
    if(items.length===0){
      const m = document.createElement('div');
      m.className='muted';
      m.textContent='(none)';
      box.appendChild(m);
    }else{
      for(const el of items) box.appendChild(el);
    }
  }

  /* ---------- Loaders & refresh ---------- */
  async function loadConfig(){
    const t = await GET('/api/v1/config');
    state.cfgText = t;
    const {greens,blues,groups} = parseConfig(t);
    state.greens = greens; state.blues = blues; state.groups = groups;
  }
  async function loadStatus(){
    state.status = await GET('/api/v1/status');
  }
  async function refresh(){
    const sel = state.selected;
    await Promise.all([loadConfig(), loadStatus()]);
    renderBinds();
    renderTargets();
    renderUnmapped();
    // keep selection highlighting
    if(sel){
      state.selected = sel;
      const chip = document.querySelector(`.chip[data-port="${sel}"]`);
      if(chip) chip.classList.add('selected');
    }
  }

  /* ---------- Wire header buttons ---------- */
  $('#refresh').onclick = ()=> refresh().catch(e=>log(e,'err'));
  $('#clearAll').onclick = async ()=>{
    try{ await clearAll(); log('Cleared all mappings','ok'); await refresh(); }
    catch(e){ log(e,'err'); }
  };

  // initial
  refresh().catch(e=>log(e,'err'));
  // periodic
  setInterval(()=> loadStatus().then(()=>{ renderBinds(); renderTargets(); renderUnmapped(); }).catch(()=>{}), 1500);
})();
</script>
</body>
</html>
