<!doctype html>
<meta charset="utf-8">
<title>autod — ESP32 console</title>
<style>
  /* Inline console theme (from assets/console-theme.css) */
  :root {
    --bg: #e7eef9;
    --fg: #142033;
    --mut: #3f516b;
    --ok: #23853f;
    --err: #b83228;
    --panel: #0f6cd1;
    --card: #ffffff;
    --line: #c5d4ea;
    --scroll-track: #d7e3f5;
    --scroll-thumb: #87a5d5;
    --scroll-thumb-hover: #6b8ac3;
  }

  * {
    box-sizing: border-box;
    min-width: 0;
    scrollbar-width: thin;
    scrollbar-color: var(--scroll-thumb) var(--scroll-track);
  }

  *::-webkit-scrollbar { width: 10px; height: 10px; }
  *::-webkit-scrollbar-track { background: var(--scroll-track); }
  *::-webkit-scrollbar-thumb {
    background: var(--scroll-thumb);
    border-radius: 999px;
    border: 2px solid transparent;
    background-clip: content-box;
  }
  *::-webkit-scrollbar-thumb:hover {
    background: var(--scroll-thumb-hover);
    background-clip: content-box;
  }

  html, body {
    margin: 0;
    height: 100%;
    background: var(--bg);
    color: var(--fg);
    font: 14px/1.4 system-ui, Segoe UI, Roboto, Inter, sans-serif;
    -webkit-tap-highlight-color: transparent;
    overflow-wrap: anywhere;
    word-break: break-word;
    overscroll-behavior: contain;
  }

  header {
    padding: 14px 16px;
    border-bottom: 1px solid var(--line);
    background: linear-gradient(120deg, #0d63c2, #0f6cd1 40%, #1b7ee5);
    color: #f5f9ff;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
    position: sticky;
    top: 0;
    z-index: 1;
  }

  header .title { font-weight: 700; }
  header .sub { color: var(--mut); font-size: 12px; }

  main {
    padding: 14px;
    display: grid;
    gap: 12px;
    grid-template-columns: 1fr;
  }

  .card {
    background: var(--card);
    border: 1px solid var(--line);
    border-radius: 14px;
    overflow: hidden;
    box-shadow: 0 10px 28px rgba(13, 55, 109, 0.12);
  }

  .card h2 {
    margin: 0;
    font-size: 14px;
    padding: 0;
    border-bottom: 1px solid var(--line);
  }

  .card .body {
    padding: 12px 14px;
    display: grid;
    gap: 10px;
  }

  .card h2 .card-toggle {
    width: 100%;
    background: transparent;
    border: 0;
    color: inherit;
    font: inherit;
    padding: 14px 16px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    cursor: pointer;
    min-height: 44px;
    text-align: left;
    touch-action: manipulation;
    border-radius: 12px;
  }

  .card h2 .card-toggle:focus-visible {
    outline: 2px solid var(--mut);
    outline-offset: 2px;
    border-radius: 12px;
  }

  .card h2 .card-toggle-label { flex: 1; font-weight: 600; }

  .card h2 .card-toggle-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    border-radius: 999px;
    border: 1px solid #264775;
    background: #154274;
    color: #e9f1fb;
    transition: background 0.2s ease, border-color 0.2s ease;
  }

  .card h2 .card-toggle-icon::before {
    content: "";
    display: inline-block;
    width: 8px;
    height: 8px;
    border-right: 2px solid currentColor;
    border-bottom: 2px solid currentColor;
    transform: rotate(45deg);
    transition: transform 0.2s ease;
  }

  .collapsible-card:not(.collapsed) .card-toggle-icon {
    background: rgba(35, 133, 63, 0.18);
    border-color: rgba(35, 133, 63, 0.5);
  }

  .collapsible-card:not(.collapsed) .card-toggle-icon::before { transform: rotate(-135deg); }

  @media (hover: hover) {
    .card h2 .card-toggle:hover { background: rgba(255, 255, 255, 0.02); }
  }

  .collapsible-card.collapsed > .body { display: none; }
  .collapsible-card > .body[hidden] { display: none !important; }

  .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .row > label { display: flex; align-items: center; gap: 8px; flex: 1 1 180px; }

  input, button, textarea, select {
    background: #fff;
    color: var(--fg);
    border: 1px solid var(--line);
    border-radius: 10px;
    padding: 8px 10px;
    font: inherit;
    max-width: 100%;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
  }

  input[type="text"], input:not([type]) { width: clamp(140px, 100%, 280px); }

  textarea {
    width: 100%;
    min-height: 100px;
    resize: vertical;
    border-radius: 12px;
    white-space: pre-wrap;
    overflow-wrap: anywhere;
    word-break: break-word;
  }

  button { cursor: pointer; }

  code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

  .inline {
    display: block;
    max-width: 100%;
    overflow: auto;
    white-space: pre-wrap;
    overflow-wrap: anywhere;
    word-break: break-word;
    padding: 8px 10px;
    background: #0f1620;
    color: #eaf1fb;
    border: 1px solid #1f3148;
    border-radius: 10px;
  }

  .kv { display: grid; grid-template-columns: minmax(90px, 160px) 1fr; gap: 6px; align-items: center; }

  .pill {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 2px 8px;
    border: 1px solid var(--line);
    border-radius: 999px;
    color: var(--mut);
    font-size: 12px;
  }

  .ok { color: var(--ok); }
  .err { color: var(--err); }

  .grid { display: grid; gap: 8px; }
  .caps { display: flex; flex-wrap: wrap; gap: 6px; }
  .mut { color: var(--mut); }

  .sse a { color: inherit; text-decoration: underline dotted; word-break: break-all; }

  .spacer { flex: 1; }

  :root {
    --page-bg: #e5ecf9;
    --panel-top: #d2e1f8;
    --panel-bottom: #f0f5ff;
    --accent: #1a6adf;
    --accent-strong: #0f56c3;
    --accent-soft: rgba(26, 106, 223, 0.18);
    --border-strong: #b7cbea;
    --shadow-soft: 0 14px 34px rgba(13, 55, 109, 0.16);
  }

  body { margin: 0; background: linear-gradient(180deg, var(--panel-top), var(--panel-bottom)); }
  header { padding: 1.5rem; display: flex; justify-content: space-between; align-items: flex-start; gap: 1rem; flex-wrap: wrap; }
  .title-stack { display: flex; flex-direction: column; gap: 0.15rem; }
  .subline { display: flex; align-items: center; gap: 0.5rem; color: var(--mut); font-size: 0.95rem; }
  .connection-note { padding: 0.15rem 0.55rem; border: 1px solid var(--line); border-radius: 999px; font-size: 0.9rem; color: var(--mut); }
  header { background: linear-gradient(135deg, #f2f6ff, #deebff 45%, #cddfff); color: var(--fg); border-bottom: 1px solid var(--border-strong); box-shadow: var(--shadow-soft); }

  .sticky-tabs { position: sticky; top: 0; z-index: 10; background: rgba(255,255,255,0.9); backdrop-filter: blur(6px); padding: 0.75rem 0 1rem; box-shadow: 0 6px 12px rgba(14,76,149,0.15); border-bottom: 1px solid var(--border-strong); margin-top: 0.4rem; }
  .tabs-top { display: flex; align-items: center; justify-content: space-between; gap: 0.75rem; flex-wrap: wrap; }
  .tab-actions { display: flex; align-items: stretch; gap: 0.5rem; }
  .tab-actions .button { min-width: 160px; }
  .card-head { display: flex; align-items: flex-start; justify-content: space-between; gap: 10px; flex-wrap: wrap; }
  .card-title-group { display: flex; flex-direction: column; gap: 4px; min-width: 0; }
  .card-title-row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
  .card-subtitle { display: flex; align-items: center; gap: 6px; color: var(--mut); font-size: 14px; }
  .badge { display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; border-radius: 999px; border: 1px solid var(--border-strong); background: #e6eeff; color: var(--fg); font-size: 13px; line-height: 1; }
  .badge.status-badge { color: var(--fg); border-color: #afc4e7; background: #d9e7ff; }
  .card-summary { display: none; color: var(--mut); font-size: 14px; padding: 4px 0; }
  .card.card-collapsed .card-summary { display: block; }
  .card.card-collapsed .card-collapsible { display: none; }
  .card-collapsible[hidden] { display: none !important; }
  .toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .toolbar .button, .toolbar button, .toolbar select { min-height: 36px; }
  .toolbar.primary .button, .toolbar.primary button { min-width: 160px; }
  .toolbar .spacer { flex: 1; }
  .optional-card .card-actions { justify-content: flex-end; }
  .optional-card.card-collapsed .card-collapsible { display: none; }
  .button.primary { background: linear-gradient(135deg, var(--accent), var(--accent-strong)); color: #fff; border-color: var(--accent-strong); box-shadow: 0 8px 18px rgba(14,76,149,0.24); }
  .button.primary:hover { background: linear-gradient(135deg, #2a7ff0, #1b6dd8); border-color: #1b6dd8; }
  .button.ghost { background: #f6f9ff; color: var(--fg); border-color: var(--border-strong); }
  .button.ghost:hover { border-color: #9dbbea; background: #eaf1fb; }
  .button.danger { background: rgba(192,57,43,0.12); color: var(--err); border-color: var(--err); }
  .button.danger:hover { background: rgba(192,57,43,0.22); color: #fff; }
  main { padding: 1.5rem; }
  .tabs { display: flex; flex-direction: column; gap: 0.5rem; padding: 0 1.5rem 1rem; border-bottom: 1px solid var(--border-strong); }
  .tabs .tab-row { display: flex; column-gap: 0.5rem; row-gap: 0.35rem; flex-wrap: wrap; align-items: center; }
  .tabs button { border: 1px solid var(--border-strong); background: #f6f9ff; color: inherit; padding: 0.5rem 1rem; border-radius: 999px; cursor: pointer; transition: background 120ms ease, border-color 120ms ease, box-shadow 120ms ease; box-shadow: 0 6px 14px rgba(14,76,149,0.08); }
  .tabs button:hover { background: #e7f0ff; border-color: #adc8f0; }
  .tabs button:focus-visible { outline: none; border-color: #9dbbea; box-shadow: 0 0 0 2px rgba(29,115,232,0.2); }
  .tabs button.slot-primary { border: 1px solid var(--ok); color: var(--ok); background: rgba(46,155,75,0.12); box-shadow: 0 0 0 1px rgba(46,155,75,0.2); }
  .tabs button.slot-primary.active { background: var(--accent-strong); color: #fff; box-shadow: none; border-color: var(--accent-strong); }
  .status-row { display: flex; column-gap: 1rem; row-gap: 0.35rem; flex-wrap: wrap; align-items: center; }
  .status-pill { background: #e4edff; border: 1px solid var(--border-strong); border-radius: 999px; padding: 0.35rem 0.75rem; font-size: 0.9rem; box-shadow: 0 6px 14px rgba(14,76,149,0.12); }
  .tab-panel { display: none; flex-direction: column; gap: 1.5rem; }
  .tab-panel.active { display: flex; }
  :root { --card-pad: 1.1rem 1.25rem; }
  .card h2, .card h3 { margin: 0 0 0.25rem; }
  .card-head, .card-summary, .card > .body { padding: var(--card-pad); }
  .slot-layout { display: grid; gap: 1.5rem; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); }
  .slot-card .body { display: flex; flex-direction: column; gap: 0.75rem; }
  .slot-card > h2,
  .slot-node-card > h3 {
    padding: var(--card-pad);
    border-bottom: 1px solid var(--line);
  }
  .slot-summary-block { display: flex; flex-direction: column; gap: 0.5rem; }
  .slot-summary-head { display: flex; align-items: center; justify-content: space-between; gap: 0.75rem; flex-wrap: wrap; }
  .slot-summary-title { display: flex; align-items: center; gap: 0.4rem; font-size: 1.05rem; }
  .slot-summary-title strong { font-size: 1.1rem; }
  .slot-meta-inline { display: flex; align-items: center; gap: 0.4rem; flex-wrap: wrap; }
  .slot-meta-inline .badge { background: #edf3ff; border-color: var(--border-strong); }
  .slot-meta-inline .badge.critical { border-color: var(--err); color: var(--err); }
  .slot-line { color: var(--mut); }
  .slot-line strong { font-size: 1.05rem; color: var(--fg); }
  .slot-actions { display: flex; flex-direction: column; gap: 0.75rem; border: 1px solid var(--line); border-radius: 12px; padding: 0.75rem; background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(241,246,255,0.9)); box-shadow: 0 8px 18px rgba(14, 76, 149, 0.1); }
  .slot-action-switch { display: inline-flex; align-items: stretch; border: 1px solid var(--line); border-radius: 10px; overflow: hidden; }
  .slot-action-switch button { border: none; background: transparent; color: var(--mut); padding: 0.45rem 0.9rem; cursor: pointer; transition: background 120ms ease, color 120ms ease; font-weight: 600; flex: 1; text-align: center; }
  .slot-action-switch button + button { border-left: 1px solid var(--line); }
  .slot-action-switch button.active { background: rgba(26, 106, 223, 0.12); color: var(--fg); }
  .slot-action-switch button:disabled { cursor: not-allowed; color: rgba(20, 32, 51, 0.35); background: rgba(26, 106, 223, 0.06); }
  .slot-action-panels { width: 100%; }
  .slot-action-panel { display: none; }
  .slot-action-panel.active { display: block; }
  .slot-actions-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 0.75rem 1rem; align-items: end; }
  .slot-actions-grid label { display: flex; flex-direction: column; gap: 0.25rem; font-size: 0.95rem; }
  .slot-actions-grid select { min-height: 38px; }
  .slot-action-row { display: flex; flex-direction: column; gap: 0.35rem; align-items: flex-start; }
  .slot-action-row .mut { line-height: 1.4; }
  .slot-waiting .mut { color: var(--mut); }
  .slot-node-card .body { padding: var(--card-pad); display: flex; flex-direction: column; gap: 0.75rem; }
  .slot-node-empty {
    border: 1px dashed var(--border-strong);
    background: linear-gradient(135deg, rgba(26, 106, 223, 0.12), rgba(26, 106, 223, 0.05));
    border-radius: 12px;
    padding: 0.95rem 1.1rem;
    color: var(--fg);
    display: flex;
    align-items: center;
    gap: 0.6rem;
    box-shadow: 0 8px 18px rgba(14, 76, 149, 0.12);
  }
  .slot-node-empty.loading::before {
    content: '';
    width: 10px;
    height: 10px;
    border-radius: 999px;
    border: 2px solid rgba(26, 115, 232, 0.3);
    border-top-color: transparent;
    display: inline-block;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
  .node-controls { gap: 1rem; }
  .node-relay { border-top: 1px solid rgba(255,255,255,0.08); padding-top: 0.75rem; display: flex; flex-direction: column; gap: 0.75rem; }
  .node-relay textarea { width: 100%; min-height: 140px; }
  .node-relay .row { gap: 0.75rem; flex-wrap: wrap; align-items: flex-end; }
  .node-relay label { font-size: 0.95rem; display: flex; flex-direction: column; gap: 0.25rem; }
  .node-relay input[type="text"],
  .node-relay input[type="number"],
  .node-relay select { min-width: 160px; }
  textarea { font-family: "SFMono-Regular", Consolas, "Liberation Mono", monospace; }

  /* Inline VRX styles */
  .joy-row { align-items: center; }
  .joy-row .mut { font-size: 12px; }
  #joystickEndpoint { word-break: break-all; }
  .joy-grid { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); justify-items: stretch; }
  .joy-item { background: #0f1620; color: #e6effb; border: 1px solid #1f3148; border-radius: 12px; padding: 12px; display: grid; gap: 10px; justify-items: center; transition: border-color 0.2s ease, box-shadow 0.2s ease; min-width: 0; box-shadow: 0 8px 18px rgba(7, 24, 48, 0.4); }
  .joy-item .joy-idx { color: #b7c6df; font-size: 12px; letter-spacing: 0.08em; text-transform: uppercase; text-align: center; }
  .joy-bar { position: relative; width: 20px; height: 120px; border-radius: 10px; border: 1px solid rgba(154, 161, 166, 0.35); background: linear-gradient(180deg, rgba(54, 194, 117, 0.08), rgba(54, 194, 117, 0.02)); overflow: hidden; }
  .joy-bar::after { content: ""; position: absolute; inset: 0; border-radius: 10px; border: 1px solid rgba(11, 13, 16, 0.45); pointer-events: none; }
  .joy-bar-fill { position: absolute; left: 0; right: 0; bottom: 0; height: 0%; background: linear-gradient(180deg, var(--ok), #1a7d45); transition: height 0.2s ease; }
  .joy-values { display: grid; gap: 2px; justify-items: center; width: 100%; text-align: center; font-size: 12px; }
  .joy-values > div { display: flex; align-items: center; justify-content: center; width: 100%; white-space: nowrap; }
  .joy-item .joy-val { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-weight: 600; font-size: 12px; font-variant-numeric: tabular-nums; }
  .joy-item .joy-raw { color: #b7c6df; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 10px; font-variant-numeric: tabular-nums; }
  .joy-item.joy-bump { border-color: rgba(54, 194, 117, 0.45); box-shadow: 0 0 0 1px rgba(54, 194, 117, 0.25); }
  .joy-meta { display: grid; gap: 4px; justify-items: center; width: 100%; text-align: center; font-size: 11px; color: #c6d2e8; margin-top: 4px; }
  .joy-meta-map { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-weight: 600; font-size: 12px; color: #f0f4fb; }
  .joy-meta-map.joy-meta-map-unmapped { color: var(--err); }
  .joy-meta-tags { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; }
  .joy-meta-tag { font-size: 10px; cursor: pointer; transition: color 0.2s ease, border-color 0.2s ease, background 0.2s ease; }
  .joy-meta-tag[aria-disabled="true"] { cursor: not-allowed; opacity: 0.55; }
  .joy-meta-tag-normal { color: #c6d2e8; border-color: #2b4160; background: rgba(255, 255, 255, 0.05); }
  .joy-meta-tag-invert { color: var(--err); border-color: rgba(255, 107, 107, 0.45); background: rgba(255, 107, 107, 0.15); }
  .joy-meta-dead { font-size: 11px; color: #b7c6df; }
  .joy-meta-dead.joy-meta-dead-active { color: #f0f4fb; }
  .joy-controls { display: grid; gap: 6px; justify-items: center; width: 100%; }
  .joy-move { display: flex; gap: 6px; }
  .joy-move-btn { padding: 4px 8px; font-size: 11px; line-height: 1; border-radius: 999px; background: rgba(255, 255, 255, 0.02); border: 1px solid var(--line); color: var(--fg); min-width: 0; }
  .joy-move-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .joy-move-btn:not(:disabled):hover { background: rgba(255, 255, 255, 0.05); }
  .joy-deadband-control { display: grid; gap: 4px; width: 100%; font-size: 10px; color: var(--mut); justify-items: center; }
  .joy-deadband-slider { width: 100%; }
  .joy-item.joy-item-inverted { border-color: rgba(255, 107, 107, 0.35); }
  .joy-item.joy-item-unmapped .joy-meta-map { color: var(--err); }

  .dvr-body { display: grid; grid-template-rows: auto 1fr; gap: 10px; height: 360px; min-height: 0; }
  .dvr-scroll { display: grid; gap: 6px; overflow: auto; padding-right: 4px; min-height: 0; }
  .dvr-list { display: grid; gap: 6px; }
  .dvr-item {
    display: grid;
    gap: 4px;
    padding: 12px 14px;
    border: 1px solid var(--line);
    border-radius: 12px;
    background: linear-gradient(135deg, rgba(15, 108, 209, 0.06), rgba(15, 108, 209, 0.02));
    box-shadow: 0 6px 16px rgba(14, 76, 149, 0.08);
  }
  .dvr-item a { color: inherit; text-decoration: none; font-weight: 600; word-break: break-all; }
  .dvr-item a:hover { text-decoration: underline; }
  .dvr-meta { color: var(--mut); font-size: 12px; }
  .dvr-message { font-size: 12px; }
  .dvr-message.ok { color: var(--ok); }
  .dvr-message.err { color: var(--err); }
  .dvr-empty {
    color: var(--mut);
    font-size: 12px;
    padding: 10px 12px;
    border: 1px dashed var(--line);
    border-radius: 10px;
    background: linear-gradient(135deg, rgba(15, 108, 209, 0.04), rgba(15, 108, 209, 0.015));
  }

  .nodes-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap: 10px; }
  .node {
    border: 1px solid var(--line);
    background: linear-gradient(145deg, rgba(15, 108, 209, 0.05), rgba(15, 108, 209, 0.02));
    border-radius: 12px;
    padding: 12px 14px;
    display: grid;
    gap: 8px;
    box-shadow: 0 6px 16px rgba(14, 76, 149, 0.08);
  }
  .node .top { display: flex; align-items: center; justify-content: space-between; gap: 6px; }
  .node .ip { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color: var(--mut); }
  .node .meta { font-size: 12px; color: var(--mut); }
  .node .role { border-color: #2d333b; }
  .node-head { cursor: pointer; display: grid; gap: 6px; position: relative; padding-right: 16px; }
  .node-head::after { content: '\25B8'; position: absolute; right: 0; top: 12px; font-size: 12px; color: var(--mut); transition: transform 0.2s ease; }
  .node.expanded .node-head::after { transform: rotate(90deg); }
  .node-head:focus-visible { outline: 2px solid var(--mut); outline-offset: 2px; border-radius: 10px; }
  .node-controls { display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--line); gap: 10px; }
  .node.expanded .node-controls { display: grid; }
  .node-control-toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .node-control-toolbar .spacer { flex: 1; }
  .node-control-stats { font-size: 12px; color: var(--mut); }
  .node-target { font-size: 12px; color: var(--mut); }
  .progress { height: 10px; border: 1px solid var(--line); border-radius: 999px; overflow: hidden; background: rgba(15, 108, 209, 0.06); }
  .progress > div { height: 100%; background: linear-gradient(90deg, var(--ok), #64d38f); width: 0%; }
  .nodes-toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .nodes-toolbar .mut { font-size: 12px; }
  .nodes-stats { display: flex; flex-wrap: wrap; gap: 8px; font-size: 12px; color: var(--mut); }

  .cap-toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .cap-toolbar .mini-rk-gamma-row { flex: 1 1 100%; }
  .cap-stats { display: flex; flex-wrap: wrap; gap: 8px; font-size: 12px; color: var(--mut); }
  .cap-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 10px; }
  .video-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 10px; }

  .ctl {
    display: grid;
    gap: 8px;
    padding: 12px 14px;
    border: 1px solid var(--line);
    border-radius: 12px;
    background: linear-gradient(145deg, rgba(15, 108, 209, 0.05), rgba(15, 108, 209, 0.02));
    box-shadow: 0 6px 16px rgba(14, 76, 149, 0.08);
  }
  .ctl .lbl { display: flex; justify-content: space-between; gap: 8px; align-items: center; }
  .ctl .lbl .name { font-weight: 600; }
  .ctl .lbl .val { color: var(--mut); font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; transition: color 0.35s ease; }
  .ctl .desc { color: var(--mut); font-size: 12px; }
  .ctl .errtxt { color: var(--err); font-size: 12px; }
  .switch { position: relative; width: 46px; height: 26px; }
  .switch input { appearance: none; width: 46px; height: 26px; background: #12161a; border: 1px solid var(--line); border-radius: 999px; outline: none; transition: 0.15s; display: block; }
  .switch input:checked { background: #1b2d22; border-color: #254a35; }
  .switch input::after { content: ""; position: absolute; top: 3px; left: 3px; width: 20px; height: 20px; border-radius: 50%; background: #cfd6dd; transition: 0.15s; }
  .switch input:checked::after { left: 23px; background: #e8f6ee; }

  .freebox { display: none; margin-top: 6px; }
  .cap-toolbar button + .cap-toolbar button { margin-left: 0; }

  .embed-wrap { border: 1px solid var(--line); border-radius: 12px; overflow: hidden; background: #0f1317; min-height: 320px; display: grid; gap: 0; }
  .embed-frame { width: 100%; min-height: 320px; border: 0; background: #0f1317; }
  .embed-note { padding: 10px 12px; font-size: 12px; }

  .mini-status { display: flex; justify-content: flex-end; align-items: center; min-height: 26px; }
  .status-indicator { display: inline-flex; align-items: center; gap: 6px; font-size: 12px; padding: 2px 10px; border-radius: 999px; border: 1px solid var(--line); color: var(--mut); background: #0f1317; transition: color 0.3s ease, border-color 0.3s ease, background 0.3s ease; }
  .status-indicator::before { content: ""; width: 8px; height: 8px; border-radius: 50%; background: var(--mut); transition: background 0.3s ease; }
  .status-indicator.running { color: var(--mut); }
  .status-indicator.running::before { background: var(--mut); }
  .status-indicator.ok { color: var(--ok); border-color: rgba(54, 194, 117, 0.4); background: rgba(54, 194, 117, 0.08); }
  .status-indicator.ok::before { background: var(--ok); }
  .status-indicator.err { color: var(--err); border-color: rgba(255, 107, 107, 0.4); background: rgba(255, 107, 107, 0.08); }
  .status-indicator.err::before { background: var(--err); }
  .status-indicator.flash { animation: statusBlink 0.7s ease-out; }
  .status-indicator.err.flash { animation: statusBlinkErr 0.7s ease-out; }
  @keyframes statusBlink { 0% { box-shadow: 0 0 0 0 rgba(54, 194, 117, 0.35); } 100% { box-shadow: 0 0 0 10px rgba(54, 194, 117, 0); } }
  @keyframes statusBlinkErr { 0% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.35); } 100% { box-shadow: 0 0 0 10px rgba(255, 107, 107, 0); } }
  @media (prefers-reduced-motion: reduce) {
    .status-indicator.flash, .status-indicator.err.flash { animation: none; }
  }
  .ctl.flash-ok { border-color: rgba(54, 194, 117, 0.4); box-shadow: 0 0 0 1px rgba(54, 194, 117, 0.3); }
  .ctl.flash-err { border-color: rgba(255, 107, 107, 0.45); box-shadow: 0 0 0 1px rgba(255, 107, 107, 0.3); }

  .udp-viewport { display: grid; gap: 6px; }
  .udp-screen { position: relative; width: 100%; aspect-ratio: 16/9; border: 1px solid var(--line); border-radius: 12px; overflow: hidden; cursor: crosshair; }
  .udp-screen-image { position: absolute; inset: 0; background-color: #0f1317; pointer-events: none; overflow: hidden; }
  .udp-screen-image::after { content: ""; position: absolute; inset: 0; background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0)); pointer-events: none; }
  .udp-screen-image img { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity 0.25s ease; }
  .udp-screen-image img[data-active="true"] { opacity: 1; }
  .udp-screen::after { content: ""; position: absolute; inset: 0; border: 1px dashed rgba(154, 161, 166, 0.25); pointer-events: none; }
  .udp-roi { position: absolute; border: 2px solid rgba(54, 194, 117, 0.8); background: rgba(54, 194, 117, 0.18); border-radius: 10px; box-shadow: 0 0 0 1px rgba(54, 194, 117, 0.45); min-width: 0; min-height: 0; transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease; }
  .udp-screen-hint { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); padding: 8px 12px; border-radius: 999px; border: 1px solid var(--line); background: rgba(15, 19, 23, 0.8); font-size: 12px; color: var(--mut); pointer-events: none; transition: opacity 0.2s ease, visibility 0.2s ease; }
  .udp-screen-hint.hidden { opacity: 0; visibility: hidden; }
  .udp-roi-meta { display: grid; gap: 4px; font-size: 12px; color: var(--mut); }
  .udp-roi-meta strong { color: var(--fg); }
  .udp-roi-meta .udp-value { color: var(--fg); font-weight: 600; }

  :root { --udp-embed-height: 800px; }
  #card-udp-relay #udpRelayEmbedContainer.embed-wrap { height: auto; min-height: 0; }
  #card-udp-relay #udpRelayEmbedContainer .embed-frame { display: block; width: 100%; height: var(--udp-embed-height) !important; border: 0; }
  #card-udp-relay .embed-note { margin-top: 8px; }

  .sync-body { gap: 12px; }
  .sync-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 10px; }
  .sync-slot { border: 1px solid var(--line); border-radius: 12px; padding: 12px; background: #0f1317; display: grid; gap: 8px; }
  .sync-slot-head { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; justify-content: space-between; }
  .sync-slot-title { font-weight: 600; }
  .sync-slot-label { font-size: 12px; color: var(--mut); }
  .sync-slot-gen { font-size: 12px; color: var(--mut); }
  .sync-slot-id { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-weight: 600; word-break: break-all; }
  .sync-slot-meta { font-size: 12px; color: var(--mut); }
  .sync-slot-last { font-size: 12px; color: var(--mut); }
  .sync-slot-actions { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .sync-slot-empty { color: var(--mut); font-size: 12px; }
  .sync-slot-prefer { font-size: 12px; color: var(--mut); margin-top: 4px; }
  .sync-slot-prefer[data-status="matched"] { color: #34d399; }
  .sync-slot-prefer[data-status="waiting"] { color: #f97316; }
  .sync-slot-prefer[data-status="open"] { color: #93c5fd; }
  .sync-move-select { min-width: 140px; }
  .sync-slot-replay { font-size: 12px; padding: 4px 8px; }
  .sync-delete-btn { font-size: 12px; padding: 4px 8px; background: #2a1717; color: #fff; border: 1px solid rgba(255, 107, 107, 0.4); border-radius: 6px; }
  .sync-delete-btn:disabled { opacity: 0.6; }
  .sync-waiting { display: grid; gap: 8px; }
  .sync-waiting-entry { border: 1px dashed var(--line); border-radius: 10px; padding: 10px; display: grid; gap: 6px; }
  .sync-pending { border: 1px solid var(--line); border-radius: 10px; padding: 10px; display: grid; gap: 6px; }
  .sync-pending ul { list-style: none; margin: 0; padding: 0; display: grid; gap: 4px; font-size: 12px; }
  .sync-pending li { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
  .sync-remove-pending { font-size: 11px; padding: 2px 6px; }

  @media (max-width: 960px){
    header { flex-direction: column; align-items: stretch; gap: 0.75rem; }
    .tabs-top { flex-direction: column; align-items: stretch; }
    .tab-row { width: 100%; }
    .tab-actions { width: 100%; }
    .tab-actions .button { width: 100%; }
    .tabs { padding: 0 1rem 1rem; }
    .tabs .tab-row { flex-direction: column; align-items: stretch; }
    .tabs button { width: 100%; text-align: center; }
    .status-row { flex-direction: column; align-items: stretch; }
    .slot-actions, .slot-waiting { flex-direction: column; align-items: stretch; }
    .slot-actions button, .slot-waiting button, .slot-actions select, .slot-waiting select { width: 100%; }
    .slot-actions label, .slot-waiting label { width: 100%; }
    .slot-action-switch { width: 100%; }
    .slot-action-switch button { flex: 1; justify-content: center; }
    .slot-actions-grid { grid-template-columns: 1fr; }
    .node-relay .row { flex-direction: column; align-items: stretch; }
    .node-relay input[type="text"], .node-relay input[type="number"], .node-relay select { width: 100%; }
    header { padding-bottom: 0.5rem; }
  }
</style>

<header>
  <div class="title-stack">
    <div class="title">autod — ESP32 console</div>
    <div class="subline">
      <span class="sub" id="subtitle">nodes + sync overview</span>
      <span class="connection-note" id="headerStatus">Waiting for /caps…</span>
    </div>
  </div>
</header>

<nav class="tabs sticky-tabs" role="tablist">
  <div class="tabs-top">
    <div class="tab-row">
      <button class="active" data-tab="groundstation" aria-controls="panel-groundstation" title="Groundstation overview">Groundstation</button>
      <button data-tab="slot1" aria-controls="panel-slot1" class="slot-primary" title="Slot 1 slave assignment">Slot 1</button>
      <button data-tab="slot2" aria-controls="panel-slot2" title="Slot 2 slave assignment">Slot 2</button>
      <button data-tab="slot3" aria-controls="panel-slot3" title="Slot 3 slave assignment">Slot 3</button>
    </div>
    <div class="tab-actions">
      <button class="button danger" id="nodesScanBtn">POST /nodes (scan)</button>
    </div>
  </div>
  <div class="status-row">
    <div class="status-pill" id="nodesSummary">Nodes: waiting…</div>
    <div class="status-pill" id="syncSummary">Sync: waiting…</div>
  </div>
</nav>

<main>
  <section class="tab-panel active" data-panel="groundstation" id="panel-groundstation">
    <section class="card" id="capsCard">
      <div class="card-head">
        <div class="card-title-group">
          <div class="card-title-row">
            <h2>Device & runtime</h2>
          </div>
          <div class="card-subtitle">
            <span>Runtime status</span>
            <span class="badge" id="capsStatus">waiting…</span>
          </div>
        </div>
        <div class="card-actions">
          <div class="toolbar primary">
            <button class="button primary" id="capsRefreshBtn">Refresh /caps</button>
          </div>
        </div>
      </div>
      <div class="body grid">
        <div class="kv"><div class="mut">Device</div><div id="dev_device">—</div></div>
        <div class="kv"><div class="mut">Role</div><div id="dev_role">—</div></div>
        <div class="kv"><div class="mut">Version</div><div id="dev_version">—</div></div>
        <div class="kv"><div class="mut">Interfaces</div><div id="dev_if">—</div></div>
        <div class="kv"><div class="mut">Uptime</div><div id="dev_uptime">—</div></div>
        <div class="kv"><div class="mut">Loadavg</div><div id="dev_load">—</div></div>
        <div class="kv"><div class="mut">Capabilities</div><div class="caps" id="dev_caps">—</div></div>
        <div class="kv"><div class="mut">SSE</div><div class="sse" id="dev_sse">—</div></div>
        <div class="toolbar" id="deviceRuntimeActions" style="display:none">
          <button id="pixelpilotMiniRkRebootBtn">Reboot device</button>
          <button id="pixelpilotMiniRkShutdownBtn">Shutdown device</button>
        </div>
      </div>
    </section>

    <section class="card card-collapsed optional-card" id="pixelpilotMiniRkCard">
      <div class="card-head">
        <div class="card-title-group">
          <div class="card-title-row">
            <h2>Pixelpilot Mini RK</h2>
          </div>
          <div class="card-subtitle">
            <span>Service status</span>
            <span class="badge status-badge status-indicator" id="pixelpilotMiniRkStatus" aria-live="polite">waiting…</span>
          </div>
        </div>
        <div class="card-actions">
          <div class="toolbar">
            <button class="button ghost" type="button" id="pixelpilotMiniRkToggle" data-card-toggle aria-expanded="false">Show details</button>
            <button class="button primary" id="pixelpilotMiniRkToggleRecordingBtn">Toggle Recording</button>
          </div>
        </div>
      </div>
      <div class="card-summary" id="pixelpilotMiniRkSummary" data-card-summary>Waiting for capabilities…</div>
      <div class="body grid card-collapsible" data-card-body hidden>
        <div class="cap-toolbar">
          <div class="toolbar" id="pixelpilotMiniRkActions">
            <button id="pixelpilotMiniRkToggleOsdBtn">Toggle OSD</button>
            <button id="pixelpilotMiniRkRestartServiceBtn">Restart pixelpilot_mini_rk</button>
            <button id="pixelpilotMiniRkStopServiceBtn">Stop pixelpilot_mini_rk</button>
            <button id="pixelpilotMiniRkStartServiceBtn">Start pixelpilot_mini_rk</button>
          </div>
          <div class="toolbar mini-rk-gamma-row">
            <label for="pixelpilotMiniRkGammaSelect">Gamma preset</label>
            <select id="pixelpilotMiniRkGammaSelect" disabled>
              <option>Loading presets…</option>
            </select>
            <button id="pixelpilotMiniRkApplyGammaBtn" type="button" disabled>Apply preset</button>
            <button id="pixelpilotMiniRkReloadGammaBtn" type="button">Reload presets</button>
            <div class="mut" id="pixelpilotMiniRkGammaNotice">Loading presets…</div>
          </div>
        </div>
      </div>
    </section>

    <section class="card card-collapsed optional-card" id="dvrCard">
      <div class="card-head">
        <div class="card-title-group">
          <div class="card-title-row">
            <h2>DVR recordings</h2>
          </div>
          <div class="card-subtitle">
            <span>Recording status</span>
            <span class="badge" id="dvrStatus">waiting…</span>
          </div>
        </div>
        <div class="card-actions">
          <div class="toolbar">
            <button class="button ghost" type="button" id="dvrToggle" data-card-toggle aria-expanded="false">Show details</button>
            <button class="button primary" id="dvrRefreshBtn">Refresh list</button>
          </div>
        </div>
      </div>
      <div class="card-summary" id="dvrSummary" data-card-summary>Waiting for capabilities…</div>
      <div class="body grid dvr-body card-collapsible" data-card-body hidden>
        <div class="toolbar">
          <button id="dvrDeleteAllBtn">Delete all</button>
          <div class="spacer"></div>
        </div>
        <div class="dvr-scroll">
          <div id="dvrMessage" class="dvr-message" style="display:none"></div>
          <div id="dvrEmptyState" class="dvr-empty" style="display:none">No recordings found.</div>
          <div id="dvrList" class="dvr-list"></div>
        </div>
      </div>
    </section>
  </section>

  <section class="tab-panel" data-panel="slot1" id="panel-slot1">
    <div class="slot-layout" data-slot="1">
      <section class="card slot-card">
        <h2>Slot 1</h2>
        <div class="body">
          <div class="slot-summary-block">
            <div class="slot-summary-head">
              <div class="slot-summary-title">
                <strong id="slot1Summary">No slave assigned.</strong>
              </div>
              <div class="slot-meta-inline">
                <span class="badge" id="slot1LastSeen">Last seen —</span>
                <span class="badge" id="slot1Generation">Generation: —</span>
              </div>
            </div>
            <div class="slot-line" id="slot1Meta">—</div>
            <div class="slot-line" id="slot1SlotMeta">Slot config: —</div>
          </div>
          <div class="slot-actions" data-slot="1">
            <div class="slot-action-switch" role="group" aria-label="Slot 1 actions">
              <button type="button" class="active" data-slot-action="assign">Assign</button>
              <button type="button" data-slot-action="move">Move</button>
              <button type="button" data-slot-action="replay">Replay</button>
            </div>
            <div class="slot-action-panels">
              <div class="slot-action-panel slot-waiting active" data-slot-panel="assign">
                <div class="slot-actions-grid">
                  <label>Assign waiting slave
                    <select id="slot1AssignSelect" class="slot-assign-select"></select>
                  </label>
                  <div class="slot-action-row">
                    <button type="button" class="slot-assign-btn" data-slot="1">Assign to slot 1</button>
                    <div class="mut" id="slot1WaitingSummary">Waiting: —</div>
                  </div>
                </div>
              </div>
              <div class="slot-action-panel" data-slot-panel="move">
                <div class="slot-actions-grid">
                  <label>Move assignment
                    <select id="slot1MoveSelect" class="slot-move-select"></select>
                  </label>
                  <div class="slot-action-row">
                    <button type="button" class="slot-move-btn" data-slot="1">Send move</button>
                    <div class="mut">Move or unassign the current slave.</div>
                  </div>
                </div>
              </div>
              <div class="slot-action-panel" data-slot-panel="replay">
                <div class="slot-actions-grid">
                  <div class="slot-action-row">
                    <button type="button" class="slot-replay-btn" data-slot="1">Replay commands</button>
                    <div class="mut">Re-send the latest slot commands to this slave.</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
      <section class="card slot-node-card">
        <h3>Node & relay</h3>
        <div class="body" id="slot1NodeContainer">
          <div class="slot-node-empty">Waiting for slot assignment.</div>
        </div>
      </section>
    </div>
  </section>

  <section class="tab-panel" data-panel="slot2" id="panel-slot2">
    <div class="slot-layout" data-slot="2">
      <section class="card slot-card">
        <h2>Slot 2</h2>
        <div class="body">
          <div class="slot-summary-block">
            <div class="slot-summary-head">
              <div class="slot-summary-title">
                <strong id="slot2Summary">No slave assigned.</strong>
              </div>
              <div class="slot-meta-inline">
                <span class="badge" id="slot2LastSeen">Last seen —</span>
                <span class="badge" id="slot2Generation">Generation: —</span>
              </div>
            </div>
            <div class="slot-line" id="slot2Meta">—</div>
            <div class="slot-line" id="slot2SlotMeta">Slot config: —</div>
          </div>
          <div class="slot-actions" data-slot="2">
            <div class="slot-action-switch" role="group" aria-label="Slot 2 actions">
              <button type="button" class="active" data-slot-action="assign">Assign</button>
              <button type="button" data-slot-action="move">Move</button>
              <button type="button" data-slot-action="replay">Replay</button>
            </div>
            <div class="slot-action-panels">
              <div class="slot-action-panel slot-waiting active" data-slot-panel="assign">
                <div class="slot-actions-grid">
                  <label>Assign waiting slave
                    <select id="slot2AssignSelect" class="slot-assign-select"></select>
                  </label>
                  <div class="slot-action-row">
                    <button type="button" class="slot-assign-btn" data-slot="2">Assign to slot 2</button>
                    <div class="mut" id="slot2WaitingSummary">Waiting: —</div>
                  </div>
                </div>
              </div>
              <div class="slot-action-panel" data-slot-panel="move">
                <div class="slot-actions-grid">
                  <label>Move assignment
                    <select id="slot2MoveSelect" class="slot-move-select"></select>
                  </label>
                  <div class="slot-action-row">
                    <button type="button" class="slot-move-btn" data-slot="2">Send move</button>
                    <div class="mut">Move or unassign the current slave.</div>
                  </div>
                </div>
              </div>
              <div class="slot-action-panel" data-slot-panel="replay">
                <div class="slot-actions-grid">
                  <div class="slot-action-row">
                    <button type="button" class="slot-replay-btn" data-slot="2">Replay commands</button>
                    <div class="mut">Re-send the latest slot commands to this slave.</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
      <section class="card slot-node-card">
        <h3>Node & relay</h3>
        <div class="body" id="slot2NodeContainer">
          <div class="slot-node-empty">Waiting for slot assignment.</div>
        </div>
      </section>
    </div>
  </section>

  <section class="tab-panel" data-panel="slot3" id="panel-slot3">
    <div class="slot-layout" data-slot="3">
      <section class="card slot-card">
        <h2>Slot 3</h2>
        <div class="body">
          <div class="slot-summary-block">
            <div class="slot-summary-head">
              <div class="slot-summary-title">
                <strong id="slot3Summary">No slave assigned.</strong>
              </div>
              <div class="slot-meta-inline">
                <span class="badge" id="slot3LastSeen">Last seen —</span>
                <span class="badge" id="slot3Generation">Generation: —</span>
              </div>
            </div>
            <div class="slot-line" id="slot3Meta">—</div>
            <div class="slot-line" id="slot3SlotMeta">Slot config: —</div>
          </div>
          <div class="slot-actions" data-slot="3">
            <div class="slot-action-switch" role="group" aria-label="Slot 3 actions">
              <button type="button" class="active" data-slot-action="assign">Assign</button>
              <button type="button" data-slot-action="move">Move</button>
              <button type="button" data-slot-action="replay">Replay</button>
            </div>
            <div class="slot-action-panels">
              <div class="slot-action-panel slot-waiting active" data-slot-panel="assign">
                <div class="slot-actions-grid">
                  <label>Assign waiting slave
                    <select id="slot3AssignSelect" class="slot-assign-select"></select>
                  </label>
                  <div class="slot-action-row">
                    <button type="button" class="slot-assign-btn" data-slot="3">Assign to slot 3</button>
                    <div class="mut" id="slot3WaitingSummary">Waiting: —</div>
                  </div>
                </div>
              </div>
              <div class="slot-action-panel" data-slot-panel="move">
                <div class="slot-actions-grid">
                  <label>Move assignment
                    <select id="slot3MoveSelect" class="slot-move-select"></select>
                  </label>
                  <div class="slot-action-row">
                    <button type="button" class="slot-move-btn" data-slot="3">Send move</button>
                    <div class="mut">Move or unassign the current slave.</div>
                  </div>
                </div>
              </div>
              <div class="slot-action-panel" data-slot-panel="replay">
                <div class="slot-actions-grid">
                  <div class="slot-action-row">
                    <button type="button" class="slot-replay-btn" data-slot="3">Replay commands</button>
                    <div class="mut">Re-send the latest slot commands to this slave.</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
      <section class="card slot-node-card">
        <h3>Node & relay</h3>
        <div class="body" id="slot3NodeContainer">
          <div class="slot-node-empty">Waiting for slot assignment.</div>
        </div>
      </section>
    </div>
  </section>
</main>

<script type="module">
const $ = (sel, root = document) => root.querySelector(sel);
const nodesState = {
  expanded: new Set(),
  pollTimer: null,
  loading: false,
  list: [],
  listSignature: '',
  version: 0,
  scanning: false,
  pendingRefresh: false
};
const NODES_POLL_MS = 7000;
const NODES_SCAN_POLL_MS = 1000;
const MAX_SYNC_SLOTS = 3;
const syncState = { slots: Array.from({ length: MAX_SYNC_SLOTS }, () => null), meta: new Map(), waiting: [], refMs: 0, signature: '' };
const syncUiState = { busy: false, pollTimer: null, loading: false, pendingRefresh: false };
const SYNC_POLL_MS = 7000;
const slotActionState = new Map();
const tabState = { active: 'groundstation' };
const DEFAULT_CMD_TIMEOUT_MS = 6000;
const capsState = { capList: new Set(), hasExec: false };
const dvrState = { initialized: false, hasExec: false, loading: false, enabled: false };
const miniRkState = { initialized: false, gamma: { presets: [], loading: false } };
const slotRenderCache = new Map();

function cardElements(cardId){
  const card = document.getElementById(cardId);
  if (!card) return {};
  return {
    card,
    body: card.querySelector('[data-card-body]'),
    summary: card.querySelector('[data-card-summary]'),
    toggle: card.querySelector('[data-card-toggle]')
  };
}

function setCardCollapsed(cardId, collapsed){
  const { card, body, toggle } = cardElements(cardId);
  if (!card || !body || !toggle) return;
  card.classList.toggle('card-collapsed', collapsed);
  body.hidden = collapsed;
  toggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
  toggle.textContent = collapsed ? 'Show details' : 'Hide details';
}

function setOptionalCardState(cardId, options = {}){
  const { card, summary } = cardElements(cardId);
  if (!card) return;
  const enabled = !!options.enabled;
  card.dataset.enabled = enabled ? 'true' : 'false';
  if (summary && typeof options.summary === 'string') summary.textContent = options.summary;
  setCardCollapsed(cardId, !enabled);
  card.classList.toggle('optional-inactive', !enabled);
}

function initCardToggle(cardId){
  const { card, toggle } = cardElements(cardId);
  if (!card || !toggle) return;
  toggle.addEventListener('click', () => {
    const next = !card.classList.contains('card-collapsed');
    setCardCollapsed(cardId, next);
  });
}

function secsToHhMmSs(value){
  const sec = Number(value);
  if (!Number.isFinite(sec) || sec < 0) return '—';
  const hours = Math.floor(sec / 3600);
  const minutes = Math.floor((sec % 3600) / 60);
  const seconds = Math.floor(sec % 60);
  const pad = num => String(num).padStart(2, '0');
  return `${hours}:${pad(minutes)}:${pad(seconds)}`;
}

function formatInterfaces(list){
  if (!Array.isArray(list) || !list.length) return '—';
  return list.map(entry => `${entry.if || entry.name || 'if'}:${entry.ip || entry.addr || '—'}`).join('  ');
}

function formatLoadavg(list){
  if (!Array.isArray(list) || !list.length) return '—';
  return list.join(' ');
}

function renderCapsList(list){
  const el = document.getElementById('dev_caps');
  if (!el) return;
  el.innerHTML = '';
  if (!Array.isArray(list) || !list.length){
    el.textContent = '—';
    return;
  }
  list.forEach(cap => {
    const pill = document.createElement('span');
    pill.className = 'pill';
    pill.textContent = cap;
    el.appendChild(pill);
  });
}

function renderSseList(entries){
  const el = document.getElementById('dev_sse');
  if (!el) return;
  el.innerHTML = '';
  if (!Array.isArray(entries) || !entries.length){
    el.textContent = '—';
    return;
  }
  const frag = document.createDocumentFragment();
  entries.forEach(item => {
    if (!item || !item.url) return;
    const link = document.createElement('a');
    link.href = item.url;
    link.target = '_blank';
    link.rel = 'noreferrer';
    link.textContent = item.name || item.url;
    frag.appendChild(link);
    frag.appendChild(document.createTextNode(' '));
  });
  el.appendChild(frag);
}

function formatBytes(bytes){
  const value = Number(bytes);
  if (!Number.isFinite(value) || value < 0) return '—';
  if (value >= 1024 * 1024) return `${(value / (1024 * 1024)).toFixed(1)} MB`;
  if (value >= 1024) return `${(value / 1024).toFixed(1)} KB`;
  return `${value} B`;
}

function formatLocalDate(ts){
  const value = Number(ts);
  if (!Number.isFinite(value) || value <= 0) return '—';
  return new Date(value * 1000).toLocaleString();
}

function formatAgoFromSeconds(ts){
  if (!ts) return '—';
  const sec = Number(ts);
  if (!Number.isFinite(sec)) return '—';
  const now = Math.floor(Date.now() / 1000);
  const delta = Math.max(0, now - sec);
  if (delta < 60) return `${delta}s ago`;
  if (delta < 3600) return `${Math.floor(delta / 60)}m ago`;
  if (delta < 86400) return `${Math.floor(delta / 3600)}h ago`;
  return `${Math.floor(delta / 86400)}d ago`;
}

function formatAgoMs(ms, refMs){
  const value = Number(ms);
  const ref = Number(refMs);
  if (!Number.isFinite(value)) return '—';
  let delta = Number.isFinite(ref) ? Math.max(0, ref - value) : 0;
  if (!Number.isFinite(ref)) delta = Math.max(0, Date.now() - value);
  const sec = Math.round(delta / 1000);
  if (sec < 60) return `${sec}s ago`;
  const min = Math.round(sec / 60);
  if (min < 60) return `${min}m ago`;
  const hr = Math.round(min / 60);
  if (hr < 48) return `${hr}h ago`;
  return `${Math.round(hr / 24)}d ago`;
}

function decodeBase64ToUtf8(b64){
  if (!b64) return '';
  try {
    const bin = atob(b64);
    const bytes = Uint8Array.from(bin, ch => ch.charCodeAt(0));
    const dec = new TextDecoder('utf-8', { fatal: false });
    return dec.decode(bytes);
  } catch (err) {
    console.warn('Failed to decode relay body', err);
    try { return atob(b64); } catch { return ''; }
  }
}

function initTabs(){
  const buttons = document.querySelectorAll('.tabs button[data-tab]');
  const panels = document.querySelectorAll('.tab-panel');
  const setActive = name => {
    if (!name) return;
    tabState.active = name;
    buttons.forEach(btn => {
      const match = btn.dataset.tab === name;
      btn.classList.toggle('active', match);
      btn.setAttribute('aria-selected', match ? 'true' : 'false');
    });
    panels.forEach(panel => {
      const match = panel.dataset.panel === name;
      panel.classList.toggle('active', match);
      panel.setAttribute('aria-hidden', match ? 'false' : 'true');
    });
  };
  buttons.forEach(btn => {
    btn.setAttribute('role', 'tab');
    btn.addEventListener('click', () => setActive(btn.dataset.tab));
  });
  panels.forEach(panel => panel.setAttribute('role', 'tabpanel'));
  setActive(tabState.active);
}

function setSyncSummary(text){
  const el = document.getElementById('syncSummary');
  if (el) el.textContent = text;
}

function setSyncBusy(flag){
  syncUiState.busy = !!flag;
  updateSlotPanels();
}

function formatSlaveMeta(rec){
  if (!rec) return '—';
  const parts = [];
  if (rec.device) parts.push(rec.device);
  if (rec.role) parts.push(rec.role);
  if (rec.version) parts.push(`v${rec.version}`);
  if (rec.remote_ip) parts.push(rec.remote_ip);
  if (rec.address && rec.address !== rec.remote_ip) parts.push(rec.address);
  return parts.join(' • ') || '—';
}

function formatSlotConfig(meta){
  if (!meta) return '—';
  const parts = [];
  if (meta.label) parts.push(meta.label);
  if (meta.prefer_id) parts.push(`prefer ${meta.prefer_id}`);
  if (meta.assigned_id) parts.push(`assigned ${meta.assigned_id}`);
  return parts.join(' • ') || '—';
}

function normalizeSlaveRecord(rec){
  if (!rec) return null;
  return {
    id: rec.id ?? null,
    device: rec.device ?? null,
    role: rec.role ?? null,
    version: rec.version ?? null,
    remote_ip: rec.remote_ip ?? rec.address ?? null,
    remote_port: Number.isFinite(rec.remote_port) ? rec.remote_port : null,
    slot: Number.isFinite(rec.slot) ? Number(rec.slot) : null,
    last_seen_ms: Number.isFinite(rec.last_seen_ms) ? Number(rec.last_seen_ms) : null,
    slot_generation: Number.isFinite(rec.slot_generation) ? Number(rec.slot_generation) : null,
    last_ack_generation: Number.isFinite(rec.last_ack_generation) ? Number(rec.last_ack_generation) : null
  };
}

function buildSlotSignature(slotNumber, rec){
  const normalizedRec = normalizeSlaveRecord(rec);
  const slotMeta = syncState.meta.get(slotNumber) || null;
  const waiting = syncState.waiting.map(normalizeSlaveRecord).filter(Boolean);
  const node = rec ? findNodeForSlave(rec) : null;
  const nodeSignature = node
    ? { key: nodeKey(node, slotNumber), data: node }
    : { missing: true, target: rec ? (rec.remote_ip || rec.address || 'unknown') : null, loading: nodesState.loading };
  return JSON.stringify({
    rec: normalizedRec,
    slotMeta,
    waiting,
    busy: syncUiState.busy,
    nodesVersion: nodesState.version,
    nodeSignature
  });
}

function syncSelectOptions(select, items, preserveValue = true){
  if (!select) return;
  const prevValue = preserveValue ? select.value : null;
  let changed = select.options.length !== items.length;
  if (!changed){
    for (let i = 0; i < items.length; i += 1){
      const opt = select.options[i];
      const item = items[i];
      if (!opt || opt.value !== item.value || opt.textContent !== item.label || opt.disabled !== !!item.disabled){
        changed = true;
        break;
      }
    }
  }
  if (!changed) return;
  select.innerHTML = '';
  items.forEach(item => {
    const opt = document.createElement('option');
    opt.value = item.value ?? '';
    opt.textContent = item.label ?? '';
    opt.disabled = !!item.disabled;
    if (item.selected) opt.selected = true;
    select.append(opt);
  });
  if (preserveValue && prevValue){
    const match = Array.from(select.options).find(opt => opt.value === prevValue && !opt.disabled);
    if (match) select.value = prevValue;
  }
  if (!select.value && items.some(item => item.selected)){
    const selectedItem = items.find(item => item.selected);
    if (selectedItem) select.value = selectedItem.value ?? '';
  }
}

function slotActionSection(slotNumber){
  return document.querySelector(`.slot-actions[data-slot="${slotNumber}"]`);
}

function setSlotActionActive(slotNumber, action){
  const section = slotActionSection(slotNumber);
  if (!section || !action) return;
  const buttons = section.querySelectorAll('[data-slot-action]');
  const panels = section.querySelectorAll('[data-slot-panel]');
  buttons.forEach(btn => {
    const match = btn.dataset.slotAction === action;
    btn.classList.toggle('active', match);
    btn.setAttribute('aria-pressed', match ? 'true' : 'false');
  });
  panels.forEach(panel => {
    const match = panel.dataset.slotPanel === action;
    panel.classList.toggle('active', match);
    panel.hidden = !match;
  });
  slotActionState.set(slotNumber, action);
}

function syncSlotActionSelection(slotNumber){
  const section = slotActionSection(slotNumber);
  if (!section) return;
  const buttons = Array.from(section.querySelectorAll('[data-slot-action]'));
  const desired = slotActionState.get(slotNumber);
  const candidate = buttons.find(btn => !btn.disabled && btn.dataset.slotAction === desired)
    || buttons.find(btn => !btn.disabled)
    || buttons[0];
  if (candidate){
    setSlotActionActive(slotNumber, candidate.dataset.slotAction);
  }
}

function initSlotActionSegments(){
  document.querySelectorAll('.slot-actions').forEach(section => {
    const slot = Number(section.dataset.slot);
    if (!Number.isFinite(slot)) return;
    section.querySelectorAll('[data-slot-action]').forEach(btn => {
      btn.addEventListener('click', () => {
        if (btn.disabled) return;
        setSlotActionActive(slot, btn.dataset.slotAction);
      });
    });
    syncSlotActionSelection(slot);
  });
}

function buildSlotPlaceholder(text, className = ''){
  const wrapper = document.createElement('div');
  wrapper.className = `slot-node-empty${className ? ` ${className}` : ''}`;
  wrapper.textContent = text;
  return wrapper;
}

function findNodeForSlave(rec){
  if (!rec) return null;
  const list = Array.isArray(nodesState.list) ? nodesState.list : [];
  const id = (rec.id || '').trim();
  const ip = (rec.remote_ip || rec.address || '').trim();
  const remotePort = Number(rec.remote_port);
  for (const node of list){
    if (!node || typeof node !== 'object') continue;
    if (id && (node.id === id || node.name === id)) return node;
    const nodeIp = (node.ip || node.host || '').trim();
    if (ip && nodeIp === ip){
      if (!Number.isFinite(remotePort)) return node;
      const nodePort = Number(node.port);
      if (!Number.isFinite(nodePort) || nodePort === remotePort) return node;
    }
  }
  return null;
}

function renderSlotNode(slotNumber, rec){
  const container = document.getElementById(`slot${slotNumber}NodeContainer`);
  if (!container) return;
  container.innerHTML = '';
  if (syncUiState.busy && !rec){
    container.append(buildSlotPlaceholder('Syncing slot updates…', 'loading'));
    return;
  }
  if (!rec){
    container.append(buildSlotPlaceholder('Waiting for slot assignment.'));
    return;
  }
  const node = findNodeForSlave(rec);
  if (node){
    container.append(buildNodeCard(node, slotNumber));
    return;
  }
  if (nodesState.loading){
    container.append(buildSlotPlaceholder('Loading node details…', 'loading'));
    return;
  }
  const targetIp = rec.remote_ip || rec.address || 'unknown';
  container.append(buildSlotPlaceholder(`No /nodes entry for ${targetIp}. Refresh nodes to discover relay details.`));
}

function updateSlotSummary(slotNumber, rec){
  const summaryEl = document.getElementById(`slot${slotNumber}Summary`);
  const metaEl = document.getElementById(`slot${slotNumber}Meta`);
  const lastSeenEl = document.getElementById(`slot${slotNumber}LastSeen`);
  const genEl = document.getElementById(`slot${slotNumber}Generation`);
  const slotMetaEl = document.getElementById(`slot${slotNumber}SlotMeta`);
  const slotMeta = syncState.meta.get(slotNumber) || null;
  if (summaryEl){
    summaryEl.textContent = rec ? (rec.id || rec.remote_ip || 'unnamed') : 'No slave assigned.';
  }
  if (metaEl){
    metaEl.textContent = rec ? formatSlaveMeta(rec) : '—';
  }
  if (lastSeenEl){
    lastSeenEl.textContent = rec ? `Last seen ${formatAgoMs(rec.last_seen_ms, syncState.refMs)}` : 'Last seen —';
  }
  if (genEl){
    genEl.textContent = rec
      ? `Generation ack ${rec.last_ack_generation ?? '—'} / slot ${rec.slot_generation ?? '—'}`
      : 'Generation: —';
  }
  if (slotMetaEl){
    slotMetaEl.textContent = `Slot config: ${formatSlotConfig(slotMeta)}`;
  }
}

function describeWaiting(waiting){
  if (!waiting.length) return 'Waiting: None';
  const names = waiting.map(rec => rec?.id || rec?.remote_ip || 'unknown');
  return `Waiting: ${waiting.length} (${names.join(', ')})`;
}

function updateSlotWaiting(slotNumber){
  const waitingEl = document.getElementById(`slot${slotNumber}WaitingSummary`);
  if (waitingEl) waitingEl.textContent = describeWaiting(syncState.waiting);
}

function populateWaitingSelect(select){
  if (!select) return;
  const waiting = syncState.waiting.filter(item => item && item.id);
  const items = waiting.length
    ? [
        { value: '', label: 'Select slave…', selected: true },
        ...waiting.map(rec => ({
          value: rec.id,
          label: `${rec.id} (${formatAgoMs(rec.last_seen_ms, syncState.refMs)})`
        }))
      ]
    : [{ value: '', label: 'No waiting slaves', selected: true }];
  syncSelectOptions(select, items, true);
  select.disabled = syncUiState.busy || !waiting.length;
}

function updateSlotControls(slotNumber, rec){
  const moveSelect = document.getElementById(`slot${slotNumber}MoveSelect`);
  const moveBtn = document.querySelector(`.slot-move-btn[data-slot="${slotNumber}"]`);
  const actionSection = slotActionSection(slotNumber);
  const hasWaiting = syncState.waiting.some(entry => entry && entry.id);
  if (moveSelect){
    const items = !rec
      ? [{ value: '', label: 'No assigned slave', selected: true }]
      : [
          { value: '', label: 'Select target…', selected: true },
          ...Array.from({ length: MAX_SYNC_SLOTS }, (_v, i) => i + 1)
            .filter(slot => slot !== slotNumber)
            .map(slot => ({ value: String(slot), label: `Slot ${slot}` })),
          { value: '__unassign__', label: 'Unassign' }
        ];
    syncSelectOptions(moveSelect, items, true);
    moveSelect.disabled = syncUiState.busy || !rec;
  }
  if (moveBtn){
    moveBtn.disabled = syncUiState.busy || !rec;
  }
  const replayBtn = document.querySelector(`.slot-replay-btn[data-slot="${slotNumber}"]`);
  if (replayBtn){
    replayBtn.disabled = syncUiState.busy || !rec;
  }
  const assignSelect = document.getElementById(`slot${slotNumber}AssignSelect`);
  if (assignSelect){
    populateWaitingSelect(assignSelect);
  }
  const assignBtn = document.querySelector(`.slot-assign-btn[data-slot="${slotNumber}"]`);
  if (assignBtn){
    assignBtn.disabled = syncUiState.busy || !hasWaiting;
  }
  if (actionSection){
    const assignToggle = actionSection.querySelector('[data-slot-action="assign"]');
    const moveToggle = actionSection.querySelector('[data-slot-action="move"]');
    const replayToggle = actionSection.querySelector('[data-slot-action="replay"]');
    if (assignToggle) assignToggle.disabled = syncUiState.busy || !hasWaiting;
    if (moveToggle) moveToggle.disabled = syncUiState.busy || !rec;
    if (replayToggle) replayToggle.disabled = syncUiState.busy || !rec;
  }
  syncSlotActionSelection(slotNumber);
}

function updateSlotPanels(){
  for (let slot = 1; slot <= MAX_SYNC_SLOTS; slot += 1){
    const rec = syncState.slots[slot - 1] || null;
    const signature = buildSlotSignature(slot, rec);
    const cached = slotRenderCache.get(slot);
    if (cached && cached.signature === signature) continue;
    slotRenderCache.set(slot, { signature });
    updateSlotSummary(slot, rec);
    renderSlotNode(slot, rec);
    updateSlotControls(slot, rec);
    updateSlotWaiting(slot);
  }
}

async function postExec(payload, timeoutMs = DEFAULT_CMD_TIMEOUT_MS){
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch('/exec', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
      signal: controller.signal
    });
    const data = await res.json().catch(() => null);
    if (!res.ok){
      const message = data?.error || data?.stderr || data?.stdout || `HTTP ${res.status}`;
      throw new Error(message);
    }
    return data || {};
  } finally {
    clearTimeout(timer);
  }
}

function setCapsStatus(text){
  const statusEl = document.getElementById('capsStatus');
  if (statusEl) statusEl.textContent = text;
  setHeaderStatus(text);
}

function setHeaderStatus(text){
  const headerStatus = document.getElementById('headerStatus');
  if (headerStatus) headerStatus.textContent = text;
}

function applyCapabilityToggles(capList){
  const list = Array.isArray(capList) ? capList : [];
  capsState.capList = new Set(list);
  capsState.hasExec = capsState.capList.has('exec');
  const hasMiniRk = capsState.capList.has('pixelpilot_mini_rk');
  const hasDvr = capsState.capList.has('dvr');

  const deviceActionsRow = document.getElementById('deviceRuntimeActions');
  if (deviceActionsRow) deviceActionsRow.style.display = hasMiniRk ? '' : 'none';

  const pixelpilotCard = document.getElementById('pixelpilotMiniRkCard');
  const miniRkToggle = document.getElementById('pixelpilotMiniRkToggle');
  const miniRkPrimary = document.getElementById('pixelpilotMiniRkToggleRecordingBtn');
  if (pixelpilotCard){
    setOptionalCardState('pixelpilotMiniRkCard', {
      enabled: hasMiniRk,
      summary: hasMiniRk ? 'Pixelpilot Mini RK ready' : 'Capability missing — controls hidden'
    });
    pixelpilotCard.querySelectorAll('button').forEach(btn => {
      if (btn.id === 'pixelpilotMiniRkToggle') return;
      btn.disabled = !hasMiniRk;
    });
    if (miniRkToggle) miniRkToggle.disabled = false;
    if (miniRkPrimary) miniRkPrimary.disabled = !hasMiniRk;
    if (hasMiniRk){
      ensureMiniRkCard();
      setMiniRkStatusIdle('Idle');
    } else {
      setMiniRkStatusIdle('cap missing');
    }
  }

  ensureDvrHandlers();
  dvrState.hasExec = capsState.hasExec;
  dvrState.enabled = hasDvr;
  updateDvrControls();
  const dvrCard = document.getElementById('dvrCard');
  const dvrToggle = document.getElementById('dvrToggle');
  const dvrRefreshBtn = document.getElementById('dvrRefreshBtn');
  if (dvrCard){
    setOptionalCardState('dvrCard', {
      enabled: hasDvr,
      summary: hasDvr ? 'Recording list available' : 'Capability missing — collapsed'
    });
    if (dvrToggle) dvrToggle.disabled = false;
    if (dvrRefreshBtn) dvrRefreshBtn.disabled = !hasDvr;
    if (hasDvr){
      refreshDvrList();
    } else {
      clearDvrCard();
    }
  }
}

function renderCaps(caps){
  document.getElementById('dev_device').textContent = caps?.device || '—';
  document.getElementById('dev_role').textContent = caps?.role || '—';
  document.getElementById('dev_version').textContent = caps?.version || '—';
  document.getElementById('dev_if').textContent = formatInterfaces(caps?.ifaddrs);
  document.getElementById('dev_uptime').textContent = secsToHhMmSs(caps?.uptime_s);
  document.getElementById('dev_load').textContent = formatLoadavg(caps?.loadavg);
  renderCapsList(caps?.caps);
  renderSseList(caps?.sse);
  const subtitle = document.getElementById('subtitle');
  if (subtitle){
    const label = [caps?.device || 'device', caps?.version ? `v${caps.version}` : ''].filter(Boolean).join(' ');
    subtitle.textContent = label || 'Device summary';
  }
  setCapsStatus(`Updated ${new Date().toLocaleTimeString()}`);
  applyCapabilityToggles(Array.isArray(caps?.caps) ? caps.caps : []);
}

async function fetchCaps(){
  setCapsStatus('Loading /caps…');
  try {
    const res = await fetch('/caps', { cache: 'no-store' });
    if (!res.ok){
      const txt = await res.text().catch(() => '');
      throw new Error(`${res.status} ${txt.trim()}`);
    }
    const data = await res.json();
    renderCaps(data);
  } catch (err) {
    setCapsStatus(`Failed (${err.message})`);
  }
}

function ensureDvrHandlers(){
  if (dvrState.initialized) return;
  const refreshBtn = document.getElementById('dvrRefreshBtn');
  const deleteBtn = document.getElementById('dvrDeleteAllBtn');
  if (refreshBtn) refreshBtn.addEventListener('click', () => { void refreshDvrList(); });
  if (deleteBtn) deleteBtn.addEventListener('click', () => { void deleteAllDvrRecordings(); });
  dvrState.initialized = true;
}

function updateDvrControls(){
  const deleteBtn = document.getElementById('dvrDeleteAllBtn');
  if (deleteBtn){
    const hasAccess = dvrState.enabled && dvrState.hasExec;
    deleteBtn.disabled = !hasAccess;
    deleteBtn.title = hasAccess ? '' : (dvrState.enabled ? 'Requires exec capability' : 'Requires DVR capability');
  }
}

function showDvrMessage(text, type){
  const msgEl = document.getElementById('dvrMessage');
  if (!msgEl) return;
  msgEl.classList.remove('ok', 'err');
  if (!text){
    msgEl.style.display = 'none';
    msgEl.textContent = '';
    return;
  }
  msgEl.textContent = text;
  if (type) msgEl.classList.add(type);
  msgEl.style.display = 'block';
}

function clearDvrCard(){
  const listEl = document.getElementById('dvrList');
  const emptyEl = document.getElementById('dvrEmptyState');
  const statusEl = document.getElementById('dvrStatus');
  showDvrMessage('', '');
  if (listEl) listEl.innerHTML = '';
  if (emptyEl) emptyEl.style.display = 'none';
  if (statusEl) statusEl.textContent = 'cap missing';
}

function renderDvrEntries(entries){
  const listEl = document.getElementById('dvrList');
  const emptyEl = document.getElementById('dvrEmptyState');
  if (!listEl || !emptyEl) return;
  listEl.innerHTML = '';
  if (!Array.isArray(entries) || !entries.length){
    emptyEl.style.display = 'block';
    return;
  }
  emptyEl.style.display = 'none';
  const frag = document.createDocumentFragment();
  entries.forEach(entry => {
    if (!entry || typeof entry.name !== 'string') return;
    const item = document.createElement('div');
    item.className = 'dvr-item';
    const link = document.createElement('a');
    link.href = `/media/${encodeURIComponent(entry.name)}`;
    link.textContent = entry.name;
    link.download = entry.name;
    item.appendChild(link);
    const meta = document.createElement('div');
    meta.className = 'dvr-meta';
    const sizeText = formatBytes(entry.sizeBytes);
    const timeText = formatLocalDate(entry.mtimeSec);
    meta.textContent = (sizeText === '—' && timeText === '—') ? '—' : `${sizeText} • ${timeText}`;
    item.appendChild(meta);
    frag.appendChild(item);
  });
  listEl.appendChild(frag);
}

function parseDvrListFromHtml(html){
  if (typeof DOMParser !== 'function') return [];
  try {
    const doc = new DOMParser().parseFromString(html, 'text/html');
    return Array.from(doc.querySelectorAll('a')).map(a => a.getAttribute('href') || '')
      .map(raw => raw.split('#')[0].split('?')[0].replace(/^\/+|\/+$/g, ''))
      .filter(Boolean)
      .filter(name => name !== '..' && name.toLowerCase().endsWith('.mp4'));
  } catch {
    return [];
  }
}

async function refreshDvrList(){
  const card = document.getElementById('dvrCard');
  if (!card || card.dataset.enabled !== 'true') return;
  if (dvrState.loading) return;
  const statusEl = document.getElementById('dvrStatus');
  const listEl = document.getElementById('dvrList');
  const emptyEl = document.getElementById('dvrEmptyState');
  if (!statusEl || !listEl || !emptyEl) return;
  dvrState.loading = true;
  statusEl.textContent = 'Loading…';
  listEl.innerHTML = '';
  emptyEl.style.display = 'none';
  showDvrMessage('', '');
  try {
    let entries = [];
    if (dvrState.hasExec){
      const res = await postExec({ path: '/sys/dvr/list', args: [] });
      const ok = typeof res?.rc === 'number' ? res.rc === 0 : true;
      const stdout = String(res?.stdout ?? '');
      if (!ok){
        const errMsg = (res?.stderr || stdout || 'failed to list recordings').trim();
        throw new Error(errMsg || 'failed to list recordings');
      }
      entries = stdout.split(/\r?\n/).map(line => {
        const trimmed = line.trim();
        if (!trimmed) return null;
        const parts = trimmed.split('\t');
        const name = parts[0]?.trim();
        if (!name) return null;
        const size = parts.length > 1 ? Number(parts[1]) : NaN;
        const mtime = parts.length > 2 ? Number(parts[2]) : NaN;
        return {
          name,
          sizeBytes: Number.isFinite(size) && size >= 0 ? size : null,
          mtimeSec: Number.isFinite(mtime) && mtime > 0 ? Math.floor(mtime) : null
        };
      }).filter(Boolean);
    } else {
      const resp = await fetch('/media/', { cache: 'no-store' });
      if (!resp.ok){
        throw new Error(`/media/ responded with ${resp.status}`);
      }
      const html = await resp.text();
      const names = parseDvrListFromHtml(html);
      entries = names.map(name => ({ name }));
    }
    entries.sort((a, b) => {
      const aTs = Number.isFinite(a?.mtimeSec) ? a.mtimeSec : 0;
      const bTs = Number.isFinite(b?.mtimeSec) ? b.mtimeSec : 0;
      if (bTs !== aTs) return bTs - aTs;
      return (a?.name || '').localeCompare(b?.name || '', 'en', { numeric: true, sensitivity: 'base' });
    });
    renderDvrEntries(entries);
    statusEl.textContent = `${entries.length} recording${entries.length === 1 ? '' : 's'} • ${new Date().toLocaleTimeString()}`;
  } catch (err) {
    statusEl.textContent = 'Failed';
    showDvrMessage(err.message || 'failed to load recordings', 'err');
  } finally {
    dvrState.loading = false;
  }
}

async function deleteAllDvrRecordings(){
  if (!dvrState.hasExec || !dvrState.enabled) return;
  if (!confirm('Delete all DVR recordings?')) return;
  const deleteBtn = document.getElementById('dvrDeleteAllBtn');
  const statusEl = document.getElementById('dvrStatus');
  if (deleteBtn) deleteBtn.disabled = true;
  showDvrMessage('', '');
  if (statusEl) statusEl.textContent = 'Deleting…';
  try {
    const res = await postExec({ path: '/sys/dvr/delete_all', args: [] });
    const ok = typeof res?.rc === 'number' ? res.rc === 0 : true;
    const detail = (res?.stderr || res?.stdout || (ok ? 'Deleted recordings' : 'Delete failed')).trim();
    showDvrMessage(detail || (ok ? 'Deleted recordings' : 'Delete failed'), ok ? 'ok' : 'err');
  } catch (err) {
    showDvrMessage(err.message || 'Delete failed', 'err');
  } finally {
    if (deleteBtn) deleteBtn.disabled = !dvrState.hasExec;
    await refreshDvrList();
  }
}

function miniRkStatusEl(){
  return document.getElementById('pixelpilotMiniRkStatus');
}

function setMiniRkStatusIdle(text = 'Idle'){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('running', 'ok', 'err', 'flash');
  el.textContent = text;
  el.title = '';
}

function setMiniRkStatusRunning(){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('ok', 'err', 'flash');
  el.classList.add('running');
  el.textContent = 'Running…';
  el.title = '';
}

function setMiniRkStatusResult(ok, detail = ''){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('running', 'ok', 'err', 'flash');
  el.classList.add(ok ? 'ok' : 'err');
  el.textContent = `${ok ? 'Success' : 'Error'} • ${new Date().toLocaleTimeString()}`;
  el.title = detail || '';
  void el.offsetWidth;
  el.classList.add('flash');
}

async function runMiniRkCommand(command, btnEl){
  const payload = typeof command === 'string'
    ? { path: command, args: [] }
    : {
        path: command?.path || '',
        args: Array.isArray(command?.args) ? command.args : []
      };
  if (!payload.path){
    setMiniRkStatusResult(false, 'invalid command');
    return;
  }
  setMiniRkStatusRunning();
  if (btnEl) btnEl.disabled = true;
  try {
    const res = await postExec(payload);
    const ok = typeof res?.rc === 'number' ? res.rc === 0 : true;
    const stdout = (res?.stdout || '').trim();
    const stderr = (res?.stderr || '').trim();
    const detail = ok ? (stdout.split('\n')[0] || '') : (stderr || stdout || 'command failed');
    setMiniRkStatusResult(ok, detail);
  } catch (err) {
    setMiniRkStatusResult(false, err.message || 'command failed');
  } finally {
    if (btnEl) btnEl.disabled = false;
  }
}

function parseMiniRkGammaPresets(stdout){
  const out = [];
  const seen = new Set();
  String(stdout || '').split(/\r?\n/).forEach(rawLine => {
    const line = rawLine.trim();
    if (!line || /^available presets/i.test(line) || seen.has(line)) return;
    seen.add(line);
    out.push(line);
  });
  return out;
}

function renderMiniRkGammaPresets(presets){
  const select = document.getElementById('pixelpilotMiniRkGammaSelect');
  const applyBtn = document.getElementById('pixelpilotMiniRkApplyGammaBtn');
  if (!select || !applyBtn) return;
  select.innerHTML = '';
  const items = Array.isArray(presets) ? presets : [];
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.disabled = true;
  placeholder.selected = true;
  placeholder.textContent = items.length ? 'Select preset…' : 'No presets available';
  select.appendChild(placeholder);
  items.forEach(preset => {
    const option = document.createElement('option');
    option.value = preset;
    option.textContent = preset;
    select.appendChild(option);
  });
  select.disabled = items.length === 0;
  applyBtn.disabled = true;
}

async function loadMiniRkGammaPresets(){
  const select = document.getElementById('pixelpilotMiniRkGammaSelect');
  const applyBtn = document.getElementById('pixelpilotMiniRkApplyGammaBtn');
  const reloadBtn = document.getElementById('pixelpilotMiniRkReloadGammaBtn');
  const noticeEl = document.getElementById('pixelpilotMiniRkGammaNotice');
  if (!select || !applyBtn) return;
  if (miniRkState.gamma.loading) return;
  miniRkState.gamma.loading = true;
  select.disabled = true;
  applyBtn.disabled = true;
  if (reloadBtn) reloadBtn.disabled = true;
  if (noticeEl) noticeEl.textContent = 'Loading presets…';
  try {
    const res = await postExec({ path: '/sys/pixelpilot_mini_rk/gamma', args: ['--list'] });
    const presets = parseMiniRkGammaPresets(res?.stdout || '');
    miniRkState.gamma.presets = presets;
    renderMiniRkGammaPresets(presets);
    if (noticeEl){
      noticeEl.textContent = presets.length ? `Loaded ${presets.length} preset${presets.length === 1 ? '' : 's'}` : 'No presets reported';
    }
  } catch (err) {
    miniRkState.gamma.presets = [];
    renderMiniRkGammaPresets([]);
    if (noticeEl) noticeEl.textContent = err.message || 'Failed to load presets';
  } finally {
    if (reloadBtn) reloadBtn.disabled = false;
    miniRkState.gamma.loading = false;
  }
}

function initMiniRkGammaControls(){
  const select = document.getElementById('pixelpilotMiniRkGammaSelect');
  const applyBtn = document.getElementById('pixelpilotMiniRkApplyGammaBtn');
  const reloadBtn = document.getElementById('pixelpilotMiniRkReloadGammaBtn');
  if (!select || !applyBtn) return;
  select.addEventListener('change', () => {
    applyBtn.disabled = !select.value;
  });
  applyBtn.addEventListener('click', () => {
    const preset = select.value.trim();
    if (!preset) return;
    runMiniRkCommand({ path: '/sys/pixelpilot_mini_rk/gamma', args: [preset] }, applyBtn);
  });
  if (reloadBtn){
    reloadBtn.addEventListener('click', () => { void loadMiniRkGammaPresets(); });
  }
  void loadMiniRkGammaPresets();
}

function ensureMiniRkCard(){
  if (miniRkState.initialized) return;
  setMiniRkStatusIdle('Idle');
  const mapping = [
    { selector: '#pixelpilotMiniRkToggleOsdBtn', command: { path: '/sys/pixelpilot_mini_rk/toggle_osd' } },
    { selector: '#pixelpilotMiniRkToggleRecordingBtn', command: { path: '/sys/pixelpilot_mini_rk/toggle_recording' } },
    { selector: '#pixelpilotMiniRkRestartServiceBtn', command: { path: '/sys/pixelpilot_mini_rk/restart' } },
    { selector: '#pixelpilotMiniRkStopServiceBtn', command: { path: '/sys/pixelpilot_mini_rk/stop' } },
    { selector: '#pixelpilotMiniRkStartServiceBtn', command: { path: '/sys/pixelpilot_mini_rk/start' } },
    { selector: '#pixelpilotMiniRkRebootBtn', command: { path: '/sys/reboot' } },
    { selector: '#pixelpilotMiniRkShutdownBtn', command: { path: '/sys/shutdown' } }
  ];
  mapping.forEach(entry => {
    const btn = document.querySelector(entry.selector);
    if (btn) btn.addEventListener('click', () => { void runMiniRkCommand(entry.command, btn); });
  });
  initMiniRkGammaControls();
  miniRkState.initialized = true;
}

function nodeKey(node, idx){
  const ip = (node?.ip || node?.host || '').trim();
  const port = node?.port;
  if (ip && (port || port === 0)) return `${ip}:${port}`;
  if (ip) return ip;
  return `node-${idx}`;
}

function setNodesSummary(text){
  const summary = document.getElementById('nodesSummary');
  if (summary) summary.textContent = text;
}

async function sendRelayRequest(node, elements){
  const { methodEl, pathEl, bodyEl, timeoutEl, outputEl, buttonEl } = elements;
  if (!node || !methodEl || !pathEl || !outputEl || !buttonEl) return;
  const method = (methodEl.value || 'GET').toUpperCase();
  const path = pathEl.value.trim() || '/';
  const timeout = Math.max(0, parseInt(timeoutEl?.value || '4000', 10) || 4000);
  const bodyText = bodyEl?.value.trim();
  const payload = {
    node_ip: node.ip || node.host,
    method,
    path,
    timeout_ms: timeout
  };
  if (bodyText && method !== 'GET' && method !== 'HEAD'){
    payload.body = bodyText;
    payload.headers = { 'Content-Type': 'application/json' };
  }
  buttonEl.disabled = true;
  outputEl.value = 'Sending via /http…';
  try {
    const res = await fetch('/http', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const data = await res.json().catch(() => null);
    if (!res.ok){
      outputEl.value = data && data.error ? `error: ${data.error}` : `HTTP ${res.status}`;
      return;
    }
    if (!data || data.error){
      outputEl.value = data && data.error ? `error: ${data.error}` : 'relay_failed';
      return;
    }
    const bodyStr = decodeBase64ToUtf8(data.body_base64);
    const headerLines = Array.isArray(data.headers)
      ? data.headers.map(h => `${h.name}: ${h.value}`).join('\n')
      : '';
    const summary = [
      `status ${data.status_code ?? '?'} ${data.reason || ''}`.trim(),
      `target ${data.target_ip || '?'}:${data.target_port || ''}`.trim(),
      data.sync_id ? `sync id ${data.sync_id}` : '',
      headerLines ? '\n-- headers --\n' + headerLines : '',
      '\n-- body --',
      bodyStr
    ].filter(Boolean).join('\n');
    outputEl.value = summary;
  } catch (err) {
    outputEl.value = `relay_error: ${err.message}`;
  } finally {
    buttonEl.disabled = false;
  }
}

function buildNodeCard(node, idx){
  const key = nodeKey(node, idx);
  const expanded = nodesState.expanded.has(key);
  const nodeDiv = document.createElement('div');
  nodeDiv.className = 'node' + (expanded ? ' expanded' : '');

  const head = document.createElement('div');
  head.className = 'node-head';
  head.tabIndex = 0;
  head.setAttribute('role', 'button');
  head.setAttribute('aria-expanded', expanded ? 'true' : 'false');

  const top = document.createElement('div');
  top.className = 'top';
  const roleSpan = document.createElement('span');
  roleSpan.className = 'pill role';
  roleSpan.textContent = node.role || '—';
  const ipSpan = document.createElement('span');
  ipSpan.className = 'ip';
  ipSpan.textContent = `${node.ip || '—'}:${node.port ?? ''}`;
  top.append(roleSpan, ipSpan);

  const deviceLine = document.createElement('div');
  const strong = document.createElement('strong');
  strong.textContent = node.device || '—';
  const meta = document.createElement('span');
  meta.className = 'meta';
  meta.textContent = node.version ? `v${node.version}` : '';
  deviceLine.append(strong, document.createTextNode(' '), meta);

  const lastSeen = document.createElement('div');
  lastSeen.className = 'meta';
  lastSeen.textContent = `last seen ${formatAgoFromSeconds(node.last_seen)}`;

  head.append(top, deviceLine, lastSeen);
  nodeDiv.append(head);

  const controls = document.createElement('div');
  controls.className = 'node-controls';
  controls.style.display = expanded ? 'grid' : 'none';

  const relay = document.createElement('div');
  relay.className = 'node-relay';
  const intro = document.createElement('div');
  intro.className = 'mut';
  intro.textContent = 'Relay requests via /http to reach /caps, /exec, or other endpoints on this node.';
  relay.append(intro);

  const pathRow = document.createElement('div');
  pathRow.className = 'row';
  const methodLabel = document.createElement('label');
  methodLabel.textContent = 'method ';
  const methodSelect = document.createElement('select');
  methodSelect.innerHTML = '<option>GET</option><option>POST</option><option>PUT</option><option>DELETE</option>';
  methodLabel.append(methodSelect);
  const pathLabel = document.createElement('label');
  pathLabel.textContent = 'path ';
  const pathInput = document.createElement('input');
  pathInput.type = 'text';
  pathInput.value = '/caps';
  pathLabel.append(pathInput);
  const timeoutLabel = document.createElement('label');
  timeoutLabel.textContent = 'timeout (ms) ';
  const timeoutInput = document.createElement('input');
  timeoutInput.type = 'number';
  timeoutInput.min = '100';
  timeoutInput.value = '4000';
  timeoutLabel.append(timeoutInput);
  pathRow.append(methodLabel, pathLabel, timeoutLabel);
  relay.append(pathRow);

  const bodyArea = document.createElement('textarea');
  bodyArea.placeholder = 'Optional JSON body (defaults to /caps)';
  relay.append(bodyArea);

  const actionRow = document.createElement('div');
  actionRow.className = 'row';
  const capsBtn = document.createElement('button');
  capsBtn.type = 'button';
  capsBtn.textContent = 'Load /caps';
  capsBtn.addEventListener('click', ev => {
    ev.stopPropagation();
    methodSelect.value = 'GET';
    pathInput.value = '/caps';
    bodyArea.value = '';
  });
  const execBtn = document.createElement('button');
  execBtn.type = 'button';
  execBtn.textContent = 'POST /exec';
  execBtn.addEventListener('click', ev => {
    ev.stopPropagation();
    methodSelect.value = 'POST';
    pathInput.value = '/exec';
    bodyArea.value = JSON.stringify({ path: '/sys/help', args: [] }, null, 2);
  });
  const spacer = document.createElement('div');
  spacer.className = 'spacer';
  const sendBtn = document.createElement('button');
  sendBtn.type = 'button';
  sendBtn.textContent = 'Send via /http';
  sendBtn.addEventListener('click', ev => {
    ev.stopPropagation();
    void sendRelayRequest(node, {
      methodEl: methodSelect,
      pathEl: pathInput,
      bodyEl: bodyArea,
      timeoutEl: timeoutInput,
      outputEl: relayOutput,
      buttonEl: sendBtn
    });
  });
  actionRow.append(capsBtn, execBtn, spacer, sendBtn);
  relay.append(actionRow);

  const relayOutput = document.createElement('textarea');
  relayOutput.readOnly = true;
  relayOutput.placeholder = 'Relay response will appear here';
  relay.append(relayOutput);

  controls.append(relay);
  nodeDiv.append(controls);

  const toggle = () => {
    const isOpen = nodesState.expanded.has(key);
    if (isOpen){
      nodesState.expanded.delete(key);
      controls.style.display = 'none';
      nodeDiv.classList.remove('expanded');
      head.setAttribute('aria-expanded', 'false');
    } else {
      nodesState.expanded.add(key);
      controls.style.display = 'grid';
      nodeDiv.classList.add('expanded');
      head.setAttribute('aria-expanded', 'true');
    }
  };

  head.addEventListener('click', toggle);
  head.addEventListener('keydown', ev => {
    if (ev.key === 'Enter' || ev.key === ' '){
      ev.preventDefault();
      toggle();
    }
  });

  return nodeDiv;
}

function renderNodes(data){
  const nodes = Array.isArray(data?.nodes) ? data.nodes : [];
  const nextListSignature = JSON.stringify(nodes);
  const listChanged = nodesState.listSignature !== nextListSignature;
  if (listChanged){
    nodesState.list = nodes;
    nodesState.listSignature = nextListSignature;
    nodesState.version += 1;
  }
  nodesState.scanning = !!data?.scanning;
  const scanEnabled = data?.scan_feature_enabled !== false;
  const parts = [];
  parts.push(`${nodes.length} node${nodes.length === 1 ? '' : 's'}`);
  if (nodesState.scanning){
    const pct = typeof data?.progress_pct === 'number'
      ? Math.max(0, Math.min(100, Math.round(data.progress_pct)))
      : null;
    parts.push(pct === null ? 'scanning…' : `scanning ${pct}%`);
  } else {
    parts.push(scanEnabled ? 'scan idle' : 'scan disabled');
  }
  setNodesSummary(`Nodes: ${parts.filter(Boolean).join(' • ')}`);
  const scanBtn = document.getElementById('nodesScanBtn');
  if (scanBtn) scanBtn.disabled = !scanEnabled || !!data?.scanning;
  if (listChanged) updateSlotPanels();
}

async function fetchNodes(){
  if (nodesState.loading){
    nodesState.pendingRefresh = true;
    return;
  }
  nodesState.loading = true;
  try {
    const res = await fetch('/nodes', { cache: 'no-store' });
    if (!res.ok){
      const detail = await res.text().catch(() => '');
      setNodesSummary(`Nodes: Failed (${res.status} ${detail.trim()})`);
      const wasEmpty = nodesState.listSignature === '[]';
      nodesState.list = [];
      nodesState.listSignature = '[]';
      if (!wasEmpty) nodesState.version += 1;
      nodesState.scanning = false;
      if (!wasEmpty) updateSlotPanels();
    } else {
      const data = await res.json();
      renderNodes(data);
    }
  } catch (err) {
    setNodesSummary(`Nodes: Failed (${err.message})`);
    const wasEmpty = nodesState.listSignature === '[]';
    nodesState.list = [];
    nodesState.listSignature = '[]';
    if (!wasEmpty) nodesState.version += 1;
    nodesState.scanning = false;
    if (!wasEmpty) updateSlotPanels();
  } finally {
    nodesState.loading = false;
    if (nodesState.pendingRefresh){
      nodesState.pendingRefresh = false;
      fetchNodes();
      return;
    }
    scheduleNodesPoll();
  }
}

function scheduleNodesPoll(){
  if (nodesState.pollTimer){
    clearTimeout(nodesState.pollTimer);
    nodesState.pollTimer = null;
  }
  const delay = nodesState.scanning ? NODES_SCAN_POLL_MS : NODES_POLL_MS;
  nodesState.pollTimer = setTimeout(() => { nodesState.pollTimer = null; fetchNodes(); }, delay);
}

async function triggerNodesScan(){
  $('#nodesScanBtn').disabled = true;
  try {
    await fetch('/nodes', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: '{}' });
  } catch (err) {
    setNodesSummary(`Nodes: Scan failed (${err.message})`);
  } finally {
    fetchNodes();
  }
}

function renderSync(data){
  if (!data){
    syncState.slots = Array.from({ length: MAX_SYNC_SLOTS }, () => null);
    syncState.meta = new Map();
    syncState.waiting = [];
    syncState.refMs = 0;
    const signature = JSON.stringify({ slots: [], waiting: [], meta: [], refMs: 0 });
    const changed = syncState.signature !== signature;
    syncState.signature = signature;
    setSyncSummary('Sync: No data');
    if (changed) updateSlotPanels();
    return;
  }
  const slotsMeta = new Map();
  (Array.isArray(data.slots) ? data.slots : []).forEach(entry => {
    const slotNum = Number(entry?.slot);
    if (Number.isFinite(slotNum) && slotNum >= 1 && slotNum <= MAX_SYNC_SLOTS){
      slotsMeta.set(slotNum, entry);
    }
  });
  const slots = Array.from({ length: MAX_SYNC_SLOTS }, () => null);
  const waiting = [];
  let refMs = 0;
  (Array.isArray(data.slaves) ? data.slaves : []).forEach(rec => {
    if (!rec || typeof rec !== 'object') return;
    if (Number.isFinite(rec.last_seen_ms) && rec.last_seen_ms > refMs) refMs = rec.last_seen_ms;
    const slotNum = Number(rec.slot);
    if (Number.isFinite(slotNum) && slotNum >= 1 && slotNum <= MAX_SYNC_SLOTS){
      slots[slotNum - 1] = rec;
    } else {
      waiting.push(rec);
    }
  });
  syncState.slots = slots;
  syncState.meta = slotsMeta;
  syncState.waiting = waiting;
  syncState.refMs = refMs;
  const signature = JSON.stringify({
    slots: slots.map(normalizeSlaveRecord),
    waiting: waiting.map(normalizeSlaveRecord).filter(Boolean),
    meta: Array.from(slotsMeta.entries()),
    refMs
  });
  const changed = syncState.signature !== signature;
  syncState.signature = signature;
  setSyncSummary(`Sync: Updated ${new Date().toLocaleTimeString()} • ${ (data.slaves?.length) || 0 } known`);
  if (changed) updateSlotPanels();
}

async function sendMoveRequest(slaveId, slotTarget){
  if (!slaveId) return;
  if (slotTarget !== null && !Number.isFinite(slotTarget)) return;
  const label = slotTarget === null ? `unassign ${slaveId}` : `move ${slaveId} → slot ${slotTarget}`;
  setSyncBusy(true);
  setSyncSummary(`Sync: Requesting ${label}…`);
  try {
    const res = await fetch('/sync/push', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ moves: [{ slave_id: slaveId, slot: slotTarget }] })
    });
    if (!res.ok){
      const txt = await res.text().catch(() => '');
      throw new Error(`${res.status} ${txt.trim()}`.trim());
    }
    setSyncSummary(`Sync: Move queued for ${slaveId}`);
    await fetchSync();
  } catch (err) {
    setSyncSummary(`Sync: Move failed (${err.message})`);
  } finally {
    setSyncBusy(false);
  }
}

async function fetchSync(){
  if (syncUiState.loading){
    syncUiState.pendingRefresh = true;
    return;
  }
  syncUiState.loading = true;
  setSyncSummary('Sync: Loading /sync/slaves…');
  try {
    const res = await fetch('/sync/slaves', { cache: 'no-store' });
    if (!res.ok){
      const text = await res.text().catch(() => '');
      setSyncSummary(`Sync: Failed (${res.status} ${text.trim()})`);
      syncState.slots = Array.from({ length: MAX_SYNC_SLOTS }, () => null);
      syncState.meta = new Map();
      syncState.waiting = [];
      const signature = JSON.stringify({ slots: [], waiting: [], meta: [], refMs: 0 });
      const changed = syncState.signature !== signature;
      syncState.signature = signature;
      if (changed) updateSlotPanels();
      return;
    }
    const data = await res.json();
    renderSync(data);
  } catch (err) {
    setSyncSummary(`Sync: Failed (${err.message})`);
    syncState.slots = Array.from({ length: MAX_SYNC_SLOTS }, () => null);
    syncState.meta = new Map();
    syncState.waiting = [];
    const signature = JSON.stringify({ slots: [], waiting: [], meta: [], refMs: 0 });
    const changed = syncState.signature !== signature;
    syncState.signature = signature;
    if (changed) updateSlotPanels();
  } finally {
    syncUiState.loading = false;
    if (syncUiState.pendingRefresh){
      syncUiState.pendingRefresh = false;
      fetchSync();
      return;
    }
    scheduleSyncPoll();
  }
}

function scheduleSyncPoll(){
  if (syncUiState.pollTimer){
    clearTimeout(syncUiState.pollTimer);
    syncUiState.pollTimer = null;
  }
  syncUiState.pollTimer = setTimeout(() => { syncUiState.pollTimer = null; fetchSync(); }, SYNC_POLL_MS);
}

async function requestReplay(slotNumber){
  if (!Number.isFinite(slotNumber)) return;
  setSyncBusy(true);
  setSyncSummary(`Sync: Requesting replay for slot ${slotNumber}…`);
  try {
    const res = await fetch('/sync/push', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ replay_slots: [slotNumber] })
    });
    if (!res.ok){
      const txt = await res.text().catch(() => '');
      throw new Error(`${res.status} ${txt.trim()}`.trim());
    }
    setSyncSummary(`Sync: Replay requested for slot ${slotNumber}`);
    await fetchSync();
  } catch (err) {
    setSyncSummary(`Sync: Replay failed (${err.message})`);
  } finally {
    setSyncBusy(false);
  }
}

function attachSlotHandlers(){
  document.querySelectorAll('.slot-replay-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const slot = Number(btn.dataset.slot);
      if (!Number.isFinite(slot)) return;
      void requestReplay(slot);
    });
  });
  document.querySelectorAll('.slot-move-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const slot = Number(btn.dataset.slot);
      if (!Number.isFinite(slot)) return;
      const select = document.getElementById(`slot${slot}MoveSelect`);
      if (!select) return;
      const value = select.value;
      if (!value) return;
      const rec = syncState.slots[slot - 1];
      if (!rec || !rec.id) return;
      let target = null;
      if (value !== '__unassign__'){
        target = Number(value);
        if (!Number.isFinite(target)) return;
      }
      select.selectedIndex = 0;
      void sendMoveRequest(rec.id, target);
    });
  });
  document.querySelectorAll('.slot-assign-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const slot = Number(btn.dataset.slot);
      if (!Number.isFinite(slot)) return;
      const select = document.getElementById(`slot${slot}AssignSelect`);
      if (!select || !select.value) return;
      const slaveId = select.value;
      select.selectedIndex = 0;
      void sendMoveRequest(slaveId, slot);
    });
  });
}

initCardToggle('pixelpilotMiniRkCard');
initCardToggle('dvrCard');
const capsRefreshBtn = document.getElementById('capsRefreshBtn');
if (capsRefreshBtn) capsRefreshBtn.addEventListener('click', () => { void fetchCaps(); });
ensureDvrHandlers();
initTabs();
attachSlotHandlers();
initSlotActionSegments();
$('#nodesScanBtn').addEventListener('click', triggerNodesScan);
void fetchCaps();
fetchNodes();
fetchSync();
</script>
