<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>UDP Relay Manager</title>
<style>
  :root {
    /* Match the existing console theme */
    --bg:#0b0d10; --fg:#e8e8ea; --mut:#9aa1a6;
    --panel:#12161a; --card:#151a1f; --line:#21262c;
    --ok:#36c275; --warn:#e7b75f; --err:#ff6b6b;
    --scroll-track:#0f1317; --scroll-thumb:#2a3139; --scroll-thumb-hover:#36404a;

    /* Category tints */
    --g-bg:#132217; --g-br:#1d412a; /* GREEN (exclusive) */
    --b-bg:#121e28; --b-br:#263f53; /* BLUE (many→1)    */
    --y-bg:#2a2212; --y-br:#4b3c1a; /* YELLOW (1→many)  */
  }
  *{box-sizing:border-box;min-width:0;scrollbar-width:thin;scrollbar-color:var(--scroll-thumb) var(--scroll-track);-webkit-tap-highlight-color:transparent}
  *::-webkit-scrollbar{width:10px;height:10px}
  *::-webkit-scrollbar-track{background:var(--scroll-track)}
  *::-webkit-scrollbar-thumb{background:var(--scroll-thumb);border-radius:999px;border:2px solid transparent;background-clip:content-box}
  *::-webkit-scrollbar-thumb:hover{background:var(--scroll-thumb-hover);background-clip:content-box}

  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,Segoe UI,Roboto,Inter,sans-serif;overflow-wrap:anywhere;word-break:break-word}
  header{padding:14px 16px;border-bottom:1px solid var(--line);background:var(--panel);display:flex;justify-content:space-between;align-items:center;gap:12px;position:sticky;top:0;z-index:2}
  header .title{font-weight:700}
  header .sub{color:var(--mut);font-size:12px}
  main{padding:14px;max-width:1200px;margin:0 auto;display:grid;gap:12px;grid-template-columns:1.1fr .9fr}
  @media (max-width:980px){ main{grid-template-columns:1fr} }

  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;overflow:hidden}
  .card h2{margin:0;padding:12px 14px;border-bottom:1px solid var(--line);font-size:14px}
  .card .body{padding:12px 14px;display:grid;gap:10px}

  button,input,select{font:inherit}
  button{
    cursor:pointer;background:#0f1317;color:var(--fg);border:1px solid var(--line);
    border-radius:10px;padding:8px 12px;min-height:36px
  }
  .pill{border-radius:999px;padding:6px 12px}
  .primary{background:linear-gradient(180deg,#1f6b43,#165538);border-color:#1f6b43}
  .danger{background:#2a1212;border-color:#4a1d1d}

  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .mut{color:var(--mut);font-size:12px}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}

  /* Chips (bind sources) */
  .chips{display:flex;flex-wrap:wrap;gap:10px}
  .chip{
    background:#0f1317;border:1px dashed #2a3240;border-radius:12px;padding:10px 12px;
    display:flex;gap:10px;align-items:center;user-select:none;min-height:40px;min-width:120px
  }
  .chip[draggable="true"]{cursor:grab}
  .chip.dragging{opacity:.7}
  .chip.selected{outline:2px solid #4ea2ff}
  .chip .tag{opacity:.7;font-size:12px}

  /* Target cards */
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px}
  .tcard{border:1px solid var(--line);border-radius:12px;padding:10px;display:grid;gap:8px}
  .tcard.g{background:var(--g-bg);border-color:var(--g-br)}
  .tcard.b{background:var(--b-bg);border-color:var(--b-br)}
  .tcard.y{background:var(--y-bg);border-color:var(--y-br)}
  .tcard .head{display:flex;justify-content:space-between;align-items:center;gap:8px}
  .badge{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--line);border-radius:999px;padding:2px 8px;font-size:12px;color:var(--mut)}
  .drop{
    min-height:64px;border:2px dashed rgba(255,255,255,.15);border-radius:10px;padding:10px;
    display:flex;align-items:center;justify-content:center;color:var(--mut);font-size:12px
  }
  .drop.drag-over{outline:3px solid rgba(255,255,255,.18)}
  .drop.disabled{opacity:.4;pointer-events:none}
  .bindlist{display:flex;flex-wrap:wrap;gap:8px}
  .bindpill{background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.18);padding:6px 10px;border-radius:999px;display:flex;align-items:center;gap:8px}
  .bindpill.readonly{cursor:default}
  .bindpill .rm{border:none;background:transparent;color:#ffd0d0;font-weight:700;cursor:pointer;padding:0 6px;border-radius:6px}
  .bindpill .rm:hover{background:#2a0f0f}

  /* Unmapped */
  .empty{color:var(--mut);font-size:12px}

  /* Log */
  .log{height:160px;overflow:auto;background:#0f1317;border:1px solid var(--line);border-radius:12px;padding:10px}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}

  /* Flash feedback on success/failure */
  .flash-ok{box-shadow:0 0 0 9999px rgba(54,194,117,.0) inset}
  .flash-err{box-shadow:0 0 0 9999px rgba(255,107,107,.0) inset}
  .flash-ok, .flash-err{animation:flash 700ms ease}
  @keyframes flash { 0%{box-shadow:0 0 0 9999px rgba(255,255,255,.0) inset}
                     20%{box-shadow:0 0 0 9999px rgba(255,255,255,.10) inset}
                     100%{box-shadow:0 0 0 9999px rgba(255,255,255,.0) inset} }
</style>
</head>
<body>
<header>
  <div>
    <div class="title">UDP Relay Manager</div>
    <div class="sub">drag & drop or tap → tap • tip: <span class="mono">Shift</span>-click Reload for sync</div>
  </div>
  <div class="row">
    <button id="reload" class="pill primary" title="POST /api/v1/reload  •  Shift+Click = sync">Reload</button>
    <button id="refresh" class="pill primary" title="Reload config & status">Refresh</button>
    <button id="clearAll" class="pill danger" title="Clear all mappings">Clear ALL</button>
  </div>
</header>

<main>
  <section class="card">
    <h2>Sources (Binds)</h2>
    <div class="body">
      <div id="bindChips" class="chips" aria-label="Bind ports list"></div>
      <div class="mut">Tip: drag a bind onto a target, or tap a bind then tap a target.</div>
    </div>
  </section>

  <section class="card">
    <h2>Targets (Destinations & Groups)</h2>
    <div class="body">
      <div class="mut">Drop a bind on a card. Green = 1→1 (exclusive), Blue = many→1 (append), Yellow = 1→many (group replace). Use <span class="mono">uart</span>, <span class="mono">uart1</span>, … to target the serial bridges.</div>
      <div id="gridG" class="grid" style="margin-top:6px"></div>
      <div id="gridB" class="grid"></div>
      <div id="gridY" class="grid"></div>
    </div>
  </section>

  <section class="card">
    <h2>Unmapped Binds</h2>
    <div class="body">
      <div id="unmapped" class="chips"></div>
    </div>
  </section>

  <section class="card">
    <h2>Log</h2>
    <div class="body">
      <div id="log" class="log mono" aria-live="polite"></div>
    </div>
  </section>
</main>

<script>
(function(){
  const $ = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));
  const sleep = ms => new Promise(r => setTimeout(r, ms));

  const MAX_UARTS = 4;
  const isUartToken = (s)=> /^uart\d*$/i.test(String(s||''));
  const canonicalUartToken = (s)=>{
    if (!isUartToken(s)) return null;
    const raw = String(s||'').trim().toLowerCase();
    const suffix = raw.slice(4);
    if (!suffix || suffix === '0') return 'uart';
    const idx = parseInt(suffix, 10);
    if (!Number.isFinite(idx) || idx < 0 || idx >= MAX_UARTS) return null;
    return `uart${idx}`;
  };
  const friendlyUartLabel = (token)=>{
    const canon = canonicalUartToken(token);
    if (!canon) return token;
    const idx = canon === 'uart' ? 0 : parseInt(canon.slice(4), 10) || 0;
    return idx === 0 ? 'UART sink #1' : `UART sink #${idx+1}`;
  };

  const log = (m,c='')=>{
    const el = $('#log');
    const d = document.createElement('div');
    if(c) d.className=c;
    d.textContent = `[${new Date().toLocaleTimeString()}] ${m}`;
    el.prepend(d);
    while (el.childElementCount > 300) el.lastElementChild?.remove();
  };

  /* ---------------- Backend calls (unchanged) ---------------- */
  const GET  = p => fetch(p).then(r=>{if(!r.ok) throw new Error(r.statusText); return p.includes('/status')?r.json():r.text()});
  const POST = (p,b)=> fetch(p,{method:'POST',headers:{'Content-Type':'application/json'},body:b})
                        .then(async r=>{if(!r.ok) throw new Error(await r.text()); try{return await r.json()}catch{return await r.text()}});
  const action = (v,o)=>POST(`/api/v1/action/${v}`, JSON.stringify(o||{}));

  /* ---------------- State ---------------- */
  const state = {
    status:null,    // { relays: [...], uarts:[...] }
    cfgText:'',
    greens:[],      // ["ip:port", ...]
    blues:[],       // ["ip:port", ...]
    groups:[],      // [{name, members:[...]}]
    uarts:[],
    selected:null   // selected bind port (number)
  };

  /* ---------------- Helpers ---------------- */
  const normDest = (s)=>{
    s = String(s||'').trim();
    if (!s) return null;
    const uartTok = canonicalUartToken(s);
    if (uartTok) return uartTok;
    const m = s.match(/^([^:\s]+):(\d{1,5})$/);
    return m ? `${m[1]}:${m[2]}` : null;
  };

  function parseConfig(txt){
    const greens = [], blues = [], groups = [];
    for(const raw of String(txt||'').replace(/\r/g,'').split(/\n/)){
      const ln = raw.replace(/[;#].*$/,'').trim(); if(!ln) continue;
      let m;
      if((m = ln.match(/^\s*dest_green\s*=\s*(\S+)\s*$/))){
        const d = normDest(m[1]); if(d && !greens.includes(d)) greens.push(d); continue;
      }
      if((m = ln.match(/^\s*dest_blue\s*=\s*(\S+)\s*$/))){
        const d = normDest(m[1]); if(d && !blues.includes(d)) blues.push(d); continue;
      }
      if((m = ln.match(/^\s*group_yellow\s*=\s*([^|]+)\|(.+)\s*$/))){
        const name = m[1].trim(); const members = [];
        for(const t of m[2].split(',')){ const d = normDest(t); if(d && !members.includes(d)) members.push(d); }
        if(name && members.length) groups.push({name, members});
        continue;
      }
    }
    return {greens,blues,groups};
  }

  const relays = ()=> (state.status && Array.isArray(state.status.relays)) ? state.status.relays : [];
  const destToken = d => {
    if(!d) return null;
    if(d.type === 'uart'){
      const tok = canonicalUartToken(d.token || 'uart');
      return tok || 'uart';
    }
    if(typeof d.ip === 'string' && typeof d.port !== 'undefined') return `${d.ip}:${d.port}`;
    return null;
  };
  const listTokens = r => (r.dests||[]).map(destToken).filter(Boolean);
  const labelDest = token => {
    const canon = canonicalUartToken(token);
    return canon ? friendlyUartLabel(canon) : token;
  };

  function buildDestIndex(){
    const idx = new Map();
    for(const r of relays()){
      for(const d of (r.dests||[])){
        const token = destToken(d);
        if(!token) continue;
        if(!idx.has(token)) idx.set(token, []);
        idx.get(token).push({port:r.port, pkts:d.pkts||0, in:r.pkts_in||0});
      }
    }
    return idx;
  }
  function buildGroupIndex(groups){
    const gidx = new Map();
    for(const g of groups) gidx.set(g.name, []);
    for(const r of relays()){
      const tokens = listTokens(r).sort();
      for(const g of groups){
        const gm = [...g.members].sort();
        if(tokens.length === gm.length && tokens.every((t,i)=>t===gm[i])){
          let outSum = 0;
          for(const d of (r.dests||[])){
            const tok = destToken(d);
            if(tok && g.members.includes(tok)) outSum += (d.pkts||0);
          }
          gidx.get(g.name).push({port:r.port, in:r.pkts_in||0, out:outSum});
          break;
        }
      }
    }
    return gidx;
  }

  /* ---------------- Actions (unchanged endpoints) ---------------- */
  async function removeDestFromPort(port, dest){ await action('clear_to', {port, dest}); }
  async function clearDestinationEverywhere(dest){
    for(const r of relays()){ if(listTokens(r).includes(dest)) await removeDestFromPort(r.port, dest); }
  }
  async function clearGroupFromPort(port, members){
    for(const d of members) await removeDestFromPort(port, d);
  }
  async function clearGroupEverywhere(members){
    for(const r of relays()){
      const tokens = listTokens(r);
      let hasAny = members.some(d=>tokens.includes(d));
      if(hasAny){ for(const d of members) await removeDestFromPort(r.port, d); }
    }
  }
  async function clearAll(){ for(const r of relays()) await action('clear',{port:r.port}); }

  // feedback flash
  function flash(el, ok=true){
    if(!el) return;
    el.classList.remove('flash-ok','flash-err');
    void el.offsetWidth;
    el.classList.add(ok ? 'flash-ok' : 'flash-err');
    setTimeout(()=>el.classList.remove('flash-ok','flash-err'), 750);
  }

  async function dropGreen(srcPort, dest, cardEl){
    try{
      const label = labelDest(dest);
      await clearDestinationEverywhere(dest);
      await action('set', {port:srcPort, dests:[dest]});
      log(`bind ${srcPort} → ${label} (exclusive)`,'ok');
      flash(cardEl, true);
      await refresh();
    }catch(e){ flash(cardEl,false); log(e,'err'); }
  }
  async function dropBlue(srcPort, dest, cardEl){
    try{
      const label = labelDest(dest);
      const r = relays().find(x=>x.port===srcPort);
      if(!r) return;
      if(!listTokens(r).includes(dest)){
        await action('append',{port:srcPort, dests:[dest]});
        log(`bind ${srcPort} +→ ${label}`,'ok');
        flash(cardEl, true);
        await refresh();
      } else {
        log(`bind ${srcPort} already has ${label}`,'warn');
        flash(cardEl, true);
      }
    }catch(e){ flash(cardEl,false); log(e,'err'); }
  }
  async function dropYellow(srcPort, groupMembers, cardEl){
    try{
      await action('set', {port:srcPort, dests:[...groupMembers]});
      const labelMembers = groupMembers.map(labelDest).join(', ');
      log(`bind ${srcPort} → [${labelMembers}] (group)`, 'ok');
      flash(cardEl, true);
      await refresh();
    }catch(e){ flash(cardEl,false); log(e,'err'); }
  }

  /* ---------------- Drag / Tap wiring ---------------- */
  function setSelected(port){
    state.selected = port;
    $$('.chip').forEach(c => c.classList.toggle('selected', Number(c.dataset.port)===port));
  }

  function wireChip(el, port){
    el.setAttribute('draggable','true');
    el.setAttribute('tabindex','0');
    el.dataset.port = String(port);
    el.addEventListener('dragstart', e=>{
      el.classList.add('dragging');
      try {
        e.dataTransfer.setData('text/plain', String(port));
        e.dataTransfer.setData('application/x-bind-port', String(port));
        e.dataTransfer.effectAllowed = 'copy';
      }catch{}
    });
    el.addEventListener('dragend', ()=> el.classList.remove('dragging'));
    el.addEventListener('click', ()=>{
      setSelected(state.selected===port ? null : port);
    });
    el.addEventListener('keydown', (e)=>{
      if(e.key==='Enter' || e.key===' '){ e.preventDefault(); setSelected(state.selected===port ? null : port); }
    });
  }

  function wireDropZone(el, onDo){
    const allow = e => { e.preventDefault(); e.stopPropagation(); };
    el.addEventListener('dragenter', allow);
    el.addEventListener('dragover', e=>{ allow(e); try{ e.dataTransfer.dropEffect='copy'; }catch{}; el.classList.add('drag-over'); });
    el.addEventListener('dragleave', ()=> el.classList.remove('drag-over'));
    el.addEventListener('drop', e=>{
      allow(e); el.classList.remove('drag-over');
      let txt = '';
      try{ txt = e.dataTransfer.getData('application/x-bind-port') || e.dataTransfer.getData('text/plain') || ''; }catch{}
      const p = parseInt(txt,10);
      if(!Number.isFinite(p)) return;
      onDo(p);
    });
    el.addEventListener('click', ()=>{
      if(state.selected) onDo(state.selected);
    });
    el.setAttribute('tabindex','0');
    el.addEventListener('keydown', (e)=>{ if((e.key==='Enter'||e.key===' ') && state.selected){ e.preventDefault(); onDo(state.selected); } });
  }

  /* ---------------- Rendering ---------------- */
  function renderBinds(){
    const wrap = $('#bindChips');
    const frag = document.createDocumentFragment();
    const rel = [...relays()].sort((a,b)=>a.port-b.port);
    for(const r of rel){
      const el = document.createElement('div');
      el.className = 'chip';
      el.innerHTML = `<strong>bind ${r.port}</strong> <span class="tag">in:${r.pkts_in||0}</span>`;
      wireChip(el, r.port);
      if (state.selected === r.port) el.classList.add('selected');
      frag.appendChild(el);
    }
    wrap.innerHTML = ''; wrap.appendChild(frag);
  }

  function mkBindPill(port, info, remover){
    const p = document.createElement('span');
    p.className = 'bindpill small mono';
    const pk = (info && typeof info.pkts!=='undefined') ? ` · pkts:${info.pkts}` : '';
    const inpk = (info && typeof info.in!=='undefined') ? ` · in:${info.in}` : '';
    p.innerHTML = `bind ${port}<span class="mut">${inpk}${pk}</span>`;
    const x = document.createElement('button');
    x.className = 'rm';
    x.title = 'Remove mapping';
    x.textContent = '×';
    x.onclick = remover;
    p.appendChild(x);
    return p;
  }

  function renderTargets(){
    const gridG = $('#gridG'), gridB = $('#gridB'), gridY = $('#gridY');
    gridG.innerHTML = ''; gridB.innerHTML = ''; gridY.innerHTML = '';

    const dIdx = buildDestIndex();
    const gIdx = buildGroupIndex(state.groups);

    const uartMap = new Map();
    for (const raw of Array.isArray(state.uarts) ? state.uarts : []){
      if (!raw || typeof raw !== 'object') continue;
      const canon = canonicalUartToken(raw.token || '');
      if (!canon) continue;
      const entry = {...raw, token: canon};
      if (!Array.isArray(entry.dests)) entry.dests = [];
      uartMap.set(canon, entry);
    }
    const getUart = token => uartMap.get(token) || {enabled:false,dests:[],device:'',baud:null,pkts_in:0,pkts_out:0,bytes_in:0,bytes_out:0,drops:0,send_errs:0};

    const decorateUartCard = (card, dropEl, bindList, arr, token)=>{
      const uart = getUart(token);
      const label = friendlyUartLabel(token);
      card.classList.add('uart-card');
      const headMono = card.querySelector('.head .mono');
      if (headMono) headMono.textContent = label;
      const badge = card.querySelector('.badge');
      if (badge && !badge.textContent.includes('UART')) badge.textContent = `${badge.textContent} · UART`;

      const status = document.createElement('div');
      status.className = 'mut';
      if (uart.enabled){
        const parts = [];
        if (uart.device) parts.push(uart.device);
        if (uart.baud) parts.push(`@${uart.baud}`);
        parts.push(`pkts in:${uart.pkts_in||0}`);
        parts.push(`out:${uart.pkts_out||0}`);
        parts.push(`drops:${uart.drops||0}`);
        if (typeof uart.send_errs !== 'undefined') parts.push(`errs:${uart.send_errs}`);
        status.textContent = parts.join(' • ');
      } else {
        status.textContent = `${label} disabled (set uart_device in config)`;
      }
      const mappedLabel = card.querySelector('.mut');
      if (mappedLabel) card.insertBefore(status, mappedLabel);
      else card.appendChild(status);

      const clearBtn = card.querySelector('[data-clear]');
      if (clearBtn){
        clearBtn.textContent = `Clear ${label}`;
        clearBtn.title = `Remove all binds mapped to ${label}`;
        clearBtn.disabled = (arr.length === 0);
      }

      const fanLabel = document.createElement('div');
      fanLabel.className = 'mut';
      fanLabel.textContent = `${label} → UDP fan-out:`;
      const destWrap = document.createElement('div');
      destWrap.className = 'bindlist';
      const dests = Array.isArray(uart.dests) ? uart.dests : [];
      if (dests.length === 0){
        const m = document.createElement('div'); m.className='empty'; m.textContent='(none)'; destWrap.appendChild(m);
      } else {
        for (const dest of dests){
          const pill = document.createElement('span');
          pill.className = 'bindpill small mono readonly';
          const pk = (typeof dest.pkts !== 'undefined') ? ` · pkts:${dest.pkts}` : '';
          const ip = (typeof dest.ip === 'string' && dest.ip.length) ? dest.ip : '?';
          const port = (typeof dest.port === 'number') ? dest.port : (dest.port ?? '?');
          pill.textContent = `${ip}:${port}${pk}`;
          destWrap.appendChild(pill);
        }
      }
      if (bindList){
        bindList.insertAdjacentElement('afterend', fanLabel);
        fanLabel.insertAdjacentElement('afterend', destWrap);
      } else {
        card.appendChild(fanLabel);
        card.appendChild(destWrap);
      }

      if (dropEl && !uart.enabled){
        dropEl.textContent = `${label} unavailable`;
        dropEl.classList.add('disabled');
        dropEl.setAttribute('aria-disabled','true');
        dropEl.setAttribute('tabindex','-1');
      }
    };

    // Greens (exclusive)
    for(const d of state.greens){
      const canon = canonicalUartToken(d);
      const isUart = !!canon;
      const useToken = canon || d;
      const displayLabel = labelDest(d);
      const dropMsg = isUart ? `Drop a bind here (exclusive → ${displayLabel})` : 'Drop a bind here (exclusive 1→1)';
      const card = document.createElement('div');
      card.className = 'tcard g';
      card.innerHTML = `
        <div class="head">
          <div class="row"><span class="badge">GREEN</span><span class="mono">${displayLabel}</span></div>
          <div class="row"><button class="small" data-clear>Clear this dest</button></div>
        </div>
        <div class="drop" aria-label="Drop bind here">${dropMsg}</div>
        <div class="mut">Mapped binds:</div>
        <div class="bindlist"></div>
      `;
      const drop = card.querySelector('.drop');
      if (isUart){
        const info = getUart(useToken);
        if (info.enabled){
          wireDropZone(drop, (src)=>dropGreen(src, useToken, card));
        } else {
          drop.textContent = `${displayLabel} unavailable`;
          drop.classList.add('disabled');
          drop.setAttribute('aria-disabled','true');
          drop.setAttribute('tabindex','-1');
        }
      } else {
        wireDropZone(drop, (src)=>dropGreen(src, d, card));
      }

      const list = card.querySelector('.bindlist');
      const arr = dIdx.get(useToken) || dIdx.get(d) || [];
      if(arr.length===0){
        const m = document.createElement('div'); m.className='empty'; m.textContent='(none)'; list.appendChild(m);
      }else{
        for(const it of arr){
          const pill = mkBindPill(it.port, {pkts:it.pkts, in:it.in}, async ()=>{
            try{ await removeDestFromPort(it.port, useToken); log(`Removed bind ${it.port} → ${displayLabel}`,'ok'); await refresh(); }
            catch(e){ log(e,'err'); }
          });
          list.appendChild(pill);
        }
      }

      card.querySelector('[data-clear]')?.addEventListener('click', async ()=>{
        try{ await clearDestinationEverywhere(useToken); log(`Cleared all binds from ${displayLabel}`,'ok'); await refresh(); }
        catch(e){ log(e,'err'); }
      });

      if (isUart) decorateUartCard(card, drop, list, arr, useToken);
      gridG.appendChild(card);
    }

    // Blues (many→1)
    for(const d of state.blues){
      const canon = canonicalUartToken(d);
      const isUart = !!canon;
      const useToken = canon || d;
      const displayLabel = labelDest(d);
      const dropMsg = isUart ? `Drop a bind here (append to ${displayLabel})` : 'Drop a bind here (append many→1)';
      const card = document.createElement('div');
      card.className = 'tcard b';
      card.innerHTML = `
        <div class="head">
          <div class="row"><span class="badge">BLUE</span><span class="mono">${displayLabel}</span></div>
          <div class="row"><button class="small" data-clear>Clear this dest</button></div>
        </div>
        <div class="drop" aria-label="Drop bind here">${dropMsg}</div>
        <div class="mut">Mapped binds:</div>
        <div class="bindlist"></div>
      `;
      const drop = card.querySelector('.drop');
      if (isUart){
        const info = getUart(useToken);
        if (info.enabled){
          wireDropZone(drop, (src)=>dropBlue(src, useToken, card));
        } else {
          drop.textContent = `${displayLabel} unavailable`;
          drop.classList.add('disabled');
          drop.setAttribute('aria-disabled','true');
          drop.setAttribute('tabindex','-1');
        }
      } else {
        wireDropZone(drop, (src)=>dropBlue(src, d, card));
      }

      const list = card.querySelector('.bindlist');
      const arr = dIdx.get(useToken) || dIdx.get(d) || [];
      if(arr.length===0){
        const m = document.createElement('div'); m.className='empty'; m.textContent='(none)'; list.appendChild(m);
      }else{
        for(const it of arr){
          const pill = mkBindPill(it.port, {pkts:it.pkts, in:it.in}, async ()=>{
            try{ await removeDestFromPort(it.port, useToken); log(`Removed bind ${it.port} → ${displayLabel}`,'ok'); await refresh(); }
            catch(e){ log(e,'err'); }
          });
          list.appendChild(pill);
        }
      }

      card.querySelector('[data-clear]')?.addEventListener('click', async ()=>{
        try{ await clearDestinationEverywhere(useToken); log(`Cleared all binds from ${displayLabel}`,'ok'); await refresh(); }
        catch(e){ log(e,'err'); }
      });

      if (isUart) decorateUartCard(card, drop, list, arr, useToken);
      gridB.appendChild(card);
    }

    // Yellows (groups)
    for(const g of state.groups){
      const card = document.createElement('div');
      card.className = 'tcard y';
      const members = g.members.map(labelDest).join(', ');
      card.innerHTML = `
        <div class="head">
          <div class="row"><span class="badge">YELLOW</span><span class="mono">${g.name}</span></div>
          <div class="row"><button class="small" data-clear>Clear this group</button></div>
        </div>
        <div class="mut">Members: <span class="mono">${members}</span></div>
        <div class="drop" aria-label="Drop bind here">Drop a bind here (replace with group 1→many)</div>
        <div class="mut">Mapped binds:</div>
        <div class="bindlist"></div>
      `;
      const drop = card.querySelector('.drop');
      wireDropZone(drop, (src)=>dropYellow(src, g.members, card));

      const list = card.querySelector('.bindlist');
      const arr = gIdx.get(g.name) || [];
      if(arr.length===0){
        const m = document.createElement('div'); m.className='empty'; m.textContent='(none)'; list.appendChild(m);
      }else{
        for(const it of arr){
          const pill = mkBindPill(it.port, {in:it.in}, async ()=>{
            try{ await clearGroupFromPort(it.port, g.members); log(`Removed bind ${it.port} from group ${g.name}`,'ok'); await refresh(); }
            catch(e){ log(e,'err'); }
          });
          list.appendChild(pill);
        }
      }

      card.querySelector('[data-clear]')?.addEventListener('click', async ()=>{
        try{ await clearGroupEverywhere(g.members); log(`Cleared group ${g.name} from all binds`,'ok'); await refresh(); }
        catch(e){ log(e,'err'); }
      });

      gridY.appendChild(card);
    }
  }
  function renderUnmapped(){
    const box = $('#unmapped');
    box.innerHTML = '';
    const frag = document.createDocumentFragment();
    const items = [];
    for(const r of relays()){
      const hasAny = (r.dests||[]).length>0;
      if(!hasAny){
        const el = document.createElement('div');
        el.className='chip';
        el.innerHTML = `<strong>bind ${r.port}</strong> <span class="tag">in:${r.pkts_in||0}</span>`;
        wireChip(el, r.port);
        items.push(el);
      }
    }
    if(items.length===0){
      const m = document.createElement('div'); m.className='empty'; m.textContent='(none)'; frag.appendChild(m);
    }else{
      for(const el of items.sort((a,b)=>Number(a.dataset.port)-Number(b.dataset.port))) frag.appendChild(el);
    }
    box.appendChild(frag);
  }

  /* ---------------- Loaders & refresh ---------------- */
  async function loadConfig(){
    const t = await GET('/api/v1/config');
    state.cfgText = t;
    const {greens,blues,groups} = parseConfig(t);
    state.greens = greens; state.blues = blues; state.groups = groups;
  }
  async function loadStatus(){
    const data = await GET('/api/v1/status');
    state.status = data;
    const defaults = Array.from({length:MAX_UARTS}, (_,i)=>({token: i===0 ? 'uart' : `uart${i}`, enabled:false, dests:[]}));
    const seen = new Map(defaults.map(u=>[u.token, {...u}]));
    const arr = Array.isArray(data?.uarts) ? data.uarts : [];
    for (const raw of arr){
      if (!raw || typeof raw !== 'object') continue;
      const canon = canonicalUartToken(raw.token || '');
      if (!canon) continue;
      const entry = {...raw, token: canon};
      if (!Array.isArray(entry.dests)) entry.dests = [];
      seen.set(canon, entry);
    }
    state.uarts = Array.from(seen.values());
  }

  async function refresh(){
    const sel = state.selected; // keep selection
    await Promise.all([loadConfig(), loadStatus()]);
    renderBinds(); renderTargets(); renderUnmapped();
    if (sel){ state.selected = sel; const chip = document.querySelector(`.chip[data-port="${sel}"]`); if(chip) chip.classList.add('selected'); }
  }

  /* ---------------- Header buttons ---------------- */
  $('#reload').onclick = async (e)=>{
    const btn = e.currentTarget;
    const sync = e.shiftKey === true;
    btn.disabled = true;
    try{
      if(sync){
        const res = await POST('/api/v1/reload', JSON.stringify({sync:true}));
        flash(btn, true);
        log('Reloaded (sync) ' + (typeof res==='string'?res:JSON.stringify(res)), 'ok');
        await refresh();
      }else{
        const res = await POST('/api/v1/reload', '{}');
        flash(btn, true);
        log('Reload queued ' + (typeof res==='string'?res:JSON.stringify(res)), 'ok');
        // small delay to let daemon enqueue before we poll
        await sleep(250);
        await refresh();
      }
    }catch(err){
      flash(btn, false);
      log('Reload failed: ' + (err?.message || String(err)), 'err');
    }finally{
      btn.disabled = false;
    }
  };

  $('#refresh').onclick = ()=> refresh().catch(e=>log(e,'err'));
  $('#clearAll').onclick = async ()=>{
    if(!confirm('Clear ALL mappings from all binds?')) return;
    try{ await clearAll(); log('Cleared all mappings','ok'); await refresh(); }
    catch(e){ log(e,'err'); }
  };

  /* ---------------- Init & periodic ---------------- */
  refresh().catch(e=>log(e,'err'));
  setInterval(async ()=>{
    try{
      await loadStatus();
      const sel = state.selected;
      renderBinds(); renderTargets(); renderUnmapped();
      if (sel){ state.selected = sel; const chip = document.querySelector(`.chip[data-port="${sel}"]`); if(chip) chip.classList.add('selected'); }
    }catch(_){}
  }, 1500);
})();
</script>
</body>
</html>
