<!doctype html>
<meta charset="utf-8">
<title>autod — VRX console</title>
<style>
  :root {
    --bg:#0b0d10; --fg:#e8e8ea; --mut:#9aa1a6; --ok:#36c275; --err:#ff6b6b;
    --panel:#12161a; --card:#151a1f; --line:#21262c;
    --scroll-track:#0f1317; --scroll-thumb:#2a3139; --scroll-thumb-hover:#36404a;
  }
  *{box-sizing:border-box; min-width:0; scrollbar-width:thin; scrollbar-color:var(--scroll-thumb) var(--scroll-track)}
  *::-webkit-scrollbar{width:10px;height:10px}
  *::-webkit-scrollbar-track{background:var(--scroll-track)}
  *::-webkit-scrollbar-thumb{background:var(--scroll-thumb);border-radius:999px;border:2px solid transparent;background-clip:content-box}
  *::-webkit-scrollbar-thumb:hover{background:var(--scroll-thumb-hover); background-clip:content-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,Segoe UI,Roboto,Inter,sans-serif;-webkit-tap-highlight-color:transparent;overflow-wrap:anywhere; word-break:break-word; overscroll-behavior:contain}
  header{padding:14px 16px;border-bottom:1px solid var(--line);background:var(--panel);display:flex;justify-content:space-between;align-items:center;gap:12px;position:sticky;top:0;z-index:1}
  header .title{font-weight:700}
  header .sub{color:var(--mut);font-size:12px}
  main{padding:14px;display:grid;gap:12px;grid-template-columns:1fr}
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;overflow:hidden}
  .card h2{margin:0;padding:12px 14px;border-bottom:1px solid var(--line);font-size:14px}
  .card .body{padding:12px 14px;display:grid;gap:10px}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .row > label{display:flex;align-items:center;gap:8px;flex:1 1 180px}
  input,button,textarea,select{
    background:#0f1317;color:var(--fg);border:1px solid var(--line);
    border-radius:10px;padding:8px 10px;font:inherit;max-width:100%
  }
  input[type="text"], input:not([type]){width:clamp(140px, 100%, 280px)}
  textarea{width:100%;min-height:100px;resize:vertical;border-radius:12px;white-space:pre-wrap;overflow-wrap:anywhere;word-break:break-word}
  button{cursor:pointer}
  code,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .inline{display:block;max-width:100%;overflow:auto;white-space:pre-wrap;overflow-wrap:anywhere;word-break:break-word;padding:8px 10px;background:#0f1317;border:1px solid var(--line);border-radius:10px}
  .kv{display:grid;grid-template-columns:minmax(90px,160px) 1fr;gap:6px;align-items:center}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border:1px solid var(--line);border-radius:999px;color:var(--mut);font-size:12px}
  .ok{color:var(--ok)} .err{color:var(--err)}
  .grid{display:grid;gap:8px}
  .caps{display:flex;flex-wrap:wrap;gap:6px}
  .mut{color:var(--mut)}
  .sse a{color:inherit;text-decoration:underline dotted;word-break:break-all}

  .dvr-body{display:grid;grid-template-rows:auto 1fr;gap:10px;height:360px;min-height:0}
  .dvr-scroll{display:grid;gap:6px;overflow:auto;padding-right:4px;min-height:0}
  .dvr-list{display:grid;gap:6px}
  .dvr-item{display:grid;gap:4px;padding:10px 12px;border:1px solid var(--line);border-radius:10px;background:#0f1317}
  .dvr-item a{color:inherit;text-decoration:none;font-weight:600;word-break:break-all}
  .dvr-item a:hover{text-decoration:underline}
  .dvr-meta{color:var(--mut);font-size:12px}
  .dvr-message{font-size:12px}
  .dvr-message.ok{color:var(--ok)}
  .dvr-message.err{color:var(--err)}
  .dvr-empty{color:var(--mut);font-size:12px}

  .nodes-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:10px}
  .node{border:1px solid var(--line);background:#0f1317;border-radius:12px;padding:10px;display:grid;gap:6px}
  .node .top{display:flex;align-items:center;justify-content:space-between;gap:6px}
  .node .ip{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;color:var(--mut)}
  .node .meta{font-size:12px;color:var(--mut)}
  .node .role{border-color:#2d333b}
  .node-head{cursor:pointer;display:grid;gap:6px;position:relative;padding-right:16px}
  .node-head::after{content:'\25B8';position:absolute;right:0;top:12px;font-size:12px;color:var(--mut);transition:transform .2s ease}
  .node.expanded .node-head::after{transform:rotate(90deg)}
  .node-head:focus-visible{outline:2px solid var(--mut);outline-offset:2px;border-radius:10px}
  .node-controls{display:none;margin-top:10px;padding-top:10px;border-top:1px solid var(--line);gap:10px}
  .node.expanded .node-controls{display:grid}
  .node-control-toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .node-control-toolbar .spacer{flex:1}
  .node-control-stats{font-size:12px;color:var(--mut)}
  .node-target{font-size:12px;color:var(--mut)}
  .progress{height:10px;border:1px solid var(--line);border-radius:999px;overflow:hidden;background:#0f1317}
  .progress > div{height:100%;background:linear-gradient(90deg,var(--ok),#64d38f);width:0%}
  .nodes-toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .nodes-toolbar .mut{font-size:12px}
  .nodes-stats{display:flex;flex-wrap:wrap;gap:8px;font-size:12px;color:var(--mut)}
  .spacer{flex:1}

  .cap-toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .cap-stats{display:flex;flex-wrap:wrap;gap:8px;font-size:12px;color:var(--mut)}
  .cap-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px}
  .video-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px}

  .ctl{display:grid;gap:6px;padding:10px;border:1px solid var(--line);border-radius:12px;background:#0f1317}
  .ctl .lbl{display:flex;justify-content:space-between;gap:8px;align-items:center}
  .ctl .lbl .name{font-weight:600}
  .ctl .lbl .val{color:var(--mut);font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;transition:color .35s ease}
  .ctl .desc{color:var(--mut);font-size:12px}
  .ctl .errtxt{color:var(--err);font-size:12px}
  .switch{position:relative;width:46px;height:26px}
  .switch input{appearance:none;width:46px;height:26px;background:#12161a;border:1px solid var(--line);border-radius:999px;outline:none;transition:.15s;display:block}
  .switch input:checked{background:#1b2d22;border-color:#254a35}
  .switch input::after{content:"";position:absolute;top:3px;left:3px;width:20px;height:20px;border-radius:50%;background:#cfd6dd;transition:.15s}
  .switch input:checked::after{left:23px;background:#e8f6ee}

  .freebox{display:none;margin-top:6px}
  .cap-toolbar button + .cap-toolbar button{margin-left:0}

  .embed-wrap{border:1px solid var(--line);border-radius:12px;overflow:hidden;background:#0f1317;min-height:320px;display:grid;gap:0}
  .embed-frame{width:100%;min-height:320px;border:0;background:#0f1317}
  .embed-note{padding:10px 12px;font-size:12px}

  .mini-status{display:flex;justify-content:flex-end;align-items:center;min-height:26px}
  .status-indicator{display:inline-flex;align-items:center;gap:6px;font-size:12px;padding:2px 10px;border-radius:999px;border:1px solid var(--line);color:var(--mut);background:#0f1317;transition:color .3s ease,border-color .3s ease,background .3s ease}
  .status-indicator::before{content:"";width:8px;height:8px;border-radius:50%;background:var(--mut);transition:background .3s ease}
  .status-indicator.running{color:var(--mut)}
  .status-indicator.running::before{background:var(--mut)}
  .status-indicator.ok{color:var(--ok);border-color:rgba(54,194,117,.4);background:rgba(54,194,117,.08)}
  .status-indicator.ok::before{background:var(--ok)}
  .status-indicator.err{color:var(--err);border-color:rgba(255,107,107,.4);background:rgba(255,107,107,.08)}
  .status-indicator.err::before{background:var(--err)}
  .status-indicator.flash{animation:statusBlink .7s ease-out}
  .status-indicator.err.flash{animation:statusBlinkErr .7s ease-out}
  @keyframes statusBlink{0%{box-shadow:0 0 0 0 rgba(54,194,117,.35)}100%{box-shadow:0 0 0 10px rgba(54,194,117,0)}}
  @keyframes statusBlinkErr{0%{box-shadow:0 0 0 0 rgba(255,107,107,.35)}100%{box-shadow:0 0 0 10px rgba(255,107,107,0)}}
  @media (prefers-reduced-motion:reduce){
    .status-indicator.flash,.status-indicator.err.flash{animation:none}
  }
  .ctl.flash-ok{border-color:rgba(54,194,117,.4);box-shadow:0 0 0 1px rgba(54,194,117,.3)}
  .ctl.flash-err{border-color:rgba(255,107,107,.45);box-shadow:0 0 0 1px rgba(255,107,107,.3)}

  .udp-dpad-wrap{display:grid;gap:6px}
  .udp-dpad-header{display:flex;flex-wrap:wrap;gap:8px;align-items:center;font-size:12px;color:var(--mut)}
  .udp-dpad-header strong{color:var(--fg);font-size:13px}
  .udp-dpad{display:grid;grid-template-columns:repeat(3,minmax(48px,1fr));grid-template-rows:repeat(3,minmax(40px,1fr));gap:6px;justify-content:center;align-items:center}
  .udp-dpad button{padding:10px 0;font-weight:600;min-width:0}
  .udp-dpad-display{display:grid;gap:2px;text-align:center;font-size:12px;color:var(--mut)}
  .udp-dpad-display .udp-value{font-size:14px}
  .udp-value{color:var(--fg);font-weight:600}



:root { --udp-embed-height: 800px; } /* tweak as needed */
/* Let the container grow naturally; don't fix its height */
#card-udp-relay #udpRelayEmbedContainer.embed-wrap {
  height: auto;
  min-height: 0;
}

/* Force the iframe to the desired height (override any global iframe rules) */
#card-udp-relay #udpRelayEmbedContainer .embed-frame {
  display: block;
  width: 100%;
  height: var(--udp-embed-height) !important;
  border: 0;
}

/* Give the note normal flow space below the embed */
#card-udp-relay .embed-note { margin-top: 8px; }

</style>

<header>
  <div>
    <div class="title">autod — VRX console</div>
    <div class="sub" id="subtitle">loading caps…</div>
  </div>
  <div class="row" style="justify-content:flex-end">
    <button id="refreshCaps">Refresh /caps</button>
  </div>
</header>

<main>
  <section class="card" id="capsCard" style="display:none">
    <h2>Device & runtime</h2>
    <div class="body grid">
      <div class="kv"><div class="mut">Device</div><div id="dev_device">—</div></div>
      <div class="kv"><div class="mut">Role</div><div id="dev_role">—</div></div>
      <div class="kv"><div class="mut">Version</div><div id="dev_version">—</div></div>
      <div class="kv"><div class="mut">Interfaces</div><div id="dev_if">—</div></div>
      <div class="kv"><div class="mut">Uptime</div><div id="dev_uptime">—</div></div>
      <div class="kv"><div class="mut">Loadavg</div><div id="dev_load">—</div></div>
      <div class="kv"><div class="mut">Capabilities</div><div class="caps" id="dev_caps">—</div></div>
      <div class="kv"><div class="mut">SSE</div><div class="sse" id="dev_sse">—</div></div>
      <div class="row" id="deviceRuntimeActions" style="display:none">
        <button id="pixelpilotMiniRkRebootBtn">Reboot device</button>
        <button id="pixelpilotMiniRkShutdownBtn">Shutdown device</button>
      </div>
    </div>
  </section>

  <section class="card" id="nodesCard" style="display:none">
    <h2>Nodes</h2>
    <div class="body grid">
      <div class="nodes-toolbar">
        <button id="nodesScanBtn">POST /nodes (scan)</button>
        <div class="spacer"></div>
        <div class="nodes-stats" id="nodesStats">—</div>
      </div>
      <div class="progress" aria-label="Scan progress"><div id="nodesProgress"></div></div>
      <div id="nodesNotice" class="mut">—</div>
      <div class="nodes-grid" id="nodesGrid"></div>
    </div>
  </section>

  <section class="card" id="pixelpilotCard" style="display:none">
    <h2>Pixelpilot</h2>
    <div class="body grid">
      <div class="cap-toolbar">
        <div id="pixelpilotCmds" class="row"></div>
        <button id="pixelpilotRefreshBtn">Refresh values</button>
        <div class="spacer"></div>
        <div class="cap-stats" id="pixelpilotStats">—</div>
      </div>
      <div class="cap-grid" id="pixelpilotGrid"></div>
      <div>
        <div class="mut">Last request:</div>
        <pre class="inline" id="pixelpilotReqPreview">{}</pre>
        <div class="mut">Last response:</div>
        <textarea id="pixelpilotResp" readonly></textarea>
      </div>
    </div>
  </section>

  <section class="card" id="pixelpilotMiniRkCard" style="display:none">
    <h2>Pixelpilot Mini RK</h2>
    <div class="body grid">
      <div class="cap-toolbar">
        <div class="row" id="pixelpilotMiniRkActions">
          <button id="pixelpilotMiniRkToggleOsdBtn">Toggle OSD</button>
          <button id="pixelpilotMiniRkToggleRecordingBtn">Toggle Recording</button>
          <button id="pixelpilotMiniRkRestartServiceBtn">Restart pixelpilot_mini_rk</button>
          <button id="pixelpilotMiniRkStopServiceBtn">Stop pixelpilot_mini_rk</button>
          <button id="pixelpilotMiniRkStartServiceBtn">Start pixelpilot_mini_rk</button>
        </div>
        <div class="spacer"></div>
        <div class="mini-status">
          <div class="status-indicator" id="pixelpilotMiniRkStatus" aria-live="polite">Idle</div>
        </div>
      </div>
    </div>
  </section>

  <section class="card" id="dvrCard" style="display:none">
    <h2>DVR recordings</h2>
    <div class="body grid dvr-body">
      <div class="row">
        <button id="dvrRefreshBtn">Refresh list</button>
        <button id="dvrDeleteAllBtn">Delete all</button>
        <div class="spacer"></div>
        <div class="mut" id="dvrStatus">—</div>
      </div>
      <div class="dvr-scroll">
        <div id="dvrMessage" class="dvr-message" style="display:none"></div>
        <div id="dvrEmptyState" class="dvr-empty" style="display:none">No recordings found.</div>
        <div id="dvrList" class="dvr-list"></div>
      </div>
    </div>
  </section>

  <section class="card" id="udpRelayCard" style="display:none">
    <h2>UDP relay</h2>
    <div class="body grid">
      <div class="cap-toolbar">
        <div id="udpRelayCmds" class="row"></div>
        <button id="udpRelayRefreshBtn">Refresh values</button>
        <button id="udpRelayReloadEmbedBtn">Reload relay UI</button>
        <div class="spacer"></div>
        <div class="cap-stats" id="udpRelayStats">—</div>
      </div>

      <section id="card-udp-relay" class="card">
      <div id="udpRelayEmbedContainer" class="embed-wrap">
        <div class="embed-note mut">Trying to load http://localhost:9000/…</div>
      </div>
      </section>

      <div class="cap-grid" id="udpRelayGrid"></div>
      <div>
        <div class="mut">Last request:</div>
        <pre class="inline" id="udpRelayReqPreview">{}</pre>
        <div class="mut">Last response:</div>
        <textarea id="udpRelayResp" readonly></textarea>
      </div>
    </div>
  </section>

  <section class="card" id="udpSenderCard" style="display:none">
    <h2>UDP sender</h2>
    <div class="body grid">
      <div class="row">
        <label>host <input id="udpSenderHost" value="192.168.2.20"></label>
        <label>port <input id="udpSenderPort" type="number" min="1" max="65535" value="5005"></label>
      </div>
      <div class="udp-dpad-wrap">
        <div class="udp-dpad-header">
          <strong>ROI size (%)</strong>
          <div>X: <span class="udp-value" data-udp-value="xsize">50</span>% · Y: <span class="udp-value" data-udp-value="ysize">50</span>%</div>
        </div>
        <div class="udp-dpad" role="group" aria-label="Adjust ROI size">
          <div></div>
          <button type="button" data-udp-key="ysize" data-udp-delta="5">Y+</button>
          <div></div>
          <button type="button" data-udp-key="xsize" data-udp-delta="-5">X-</button>
          <div class="udp-dpad-display">
            <div>X <span class="udp-value" data-udp-value="xsize">50</span>%</div>
            <div>Y <span class="udp-value" data-udp-value="ysize">50</span>%</div>
          </div>
          <button type="button" data-udp-key="xsize" data-udp-delta="5">X+</button>
          <div></div>
          <button type="button" data-udp-key="ysize" data-udp-delta="-5">Y-</button>
          <div></div>
        </div>
      </div>
      <div class="udp-dpad-wrap">
        <div class="udp-dpad-header">
          <strong>ROI position (%)</strong>
          <div>X: <span class="udp-value" data-udp-value="xpos">50</span>% · Y: <span class="udp-value" data-udp-value="ypos">50</span>%</div>
        </div>
        <div class="udp-dpad" role="group" aria-label="Adjust ROI position">
          <div></div>
          <button type="button" data-udp-key="ypos" data-udp-delta="-5">Up</button>
          <div></div>
          <button type="button" data-udp-key="xpos" data-udp-delta="-5">Left</button>
          <div class="udp-dpad-display">
            <div>X <span class="udp-value" data-udp-value="xpos">50</span>%</div>
            <div>Y <span class="udp-value" data-udp-value="ypos">50</span>%</div>
          </div>
          <button type="button" data-udp-key="xpos" data-udp-delta="5">Right</button>
          <div></div>
          <button type="button" data-udp-key="ypos" data-udp-delta="5">Down</button>
          <div></div>
        </div>
      </div>
      <div class="row">
        <label>ttl (ms) <input id="udpSenderTtl" type="number" min="0" value="10000"></label>
        <button id="udpSenderSendBtn">Send</button>
        <div class="spacer"></div>
      </div>
      <div>
        <div class="mut">curl preview:</div>
        <pre class="inline" id="udpSenderCurlPreview"></pre>
      </div>
      <div>
        <div class="mut">Request body:</div>
        <pre class="inline" id="udpSenderBodyPreview"></pre>
      </div>
      <div>
        <div class="mut">Last response:</div>
        <textarea id="udpSenderResponse" readonly></textarea>
      </div>
    </div>
  </section>

  <section class="card" id="linkCard" style="display:none">
    <h2>Link</h2>
    <div class="body grid">
      <div class="cap-toolbar">
        <div id="linkCmds" class="row"></div>
        <div class="spacer"></div>
        <div class="cap-stats" id="linkStats">—</div>
      </div>
      <div class="cap-grid" id="linkGrid"></div>
      <div>
        <div class="mut">Last request:</div>
        <pre class="inline" id="linkReqPreview">{}</pre>
        <div class="mut">Last response:</div>
        <textarea id="linkResp" readonly></textarea>
      </div>
    </div>
  </section>
  <section class="card" id="execCard">
    <h2>/exec — raw runner</h2>
    <div class="body">
      <div class="row">
        <label>path <input id="exec_path" value="/sys/pixelpilot/help"></label>
        <label>args (space-separated) <input id="exec_args" placeholder=''></label>
        <button id="exec_btn">POST /exec</button>
      </div>
      <div class="mut">Body preview:</div>
      <pre class="inline" id="exec_body_preview">{}</pre>
      <div class="mut">Response:</div>
      <textarea id="exec_out" readonly></textarea>
    </div>
  </section>
  <section class="card" id="remoteExecCard" style="display:none">
    <h2>Remote /exec — raw runner</h2>
    <div class="body">
      <div class="row">
        <label>target <input id="remoteExec_targetInput" value="http://192.168.2.203:55667/exec" placeholder="http://host:port/exec"></label>
        <div class="spacer"></div>
      </div>
      <div class="row">
        <label>path <input id="remoteExec_path" value="/sys/help"></label>
        <label>args (space-separated; use key=value for setters) <input id="remoteExec_args" placeholder='bitrate=8192'></label>
        <button id="remoteExec_btn">POST remote /exec</button>
      </div>
      <div class="mut" id="remoteExec_target">Target: —</div>
      <div class="mut">Body preview:</div>
      <pre class="inline" id="remoteExec_body_preview">{}</pre>
      <div class="mut">Response:</div>
      <textarea id="remoteExec_out" readonly></textarea>
    </div>
  </section>
</main>

<script>
const $ = s => document.querySelector(s);
const fmtOneLine = obj => JSON.stringify(obj);
const sleep = ms => new Promise(r => setTimeout(r, ms));
const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
const DEFAULT_REMOTE_EXEC_TARGET = 'http://192.168.2.203:55667/exec';

function joinCaps(caps){
  if (!Array.isArray(caps) || !caps.length) return '—';
  const frag = document.createDocumentFragment();
  caps.forEach(c => { const span = document.createElement('span'); span.className='pill'; span.textContent=c; frag.appendChild(span); });
  return frag;
}

function normalizeRemoteExecTarget(raw){
  let next = (raw ?? '').trim();
  if (!next) return DEFAULT_REMOTE_EXEC_TARGET;
  if (!/^https?:\/\//i.test(next)){
    next = 'http://' + next.replace(/^\/+/, '');
  }
  return next;
}

function getRemoteExecTarget(){
  const input = document.getElementById('remoteExec_targetInput');
  if (!input) return DEFAULT_REMOTE_EXEC_TARGET;
  return normalizeRemoteExecTarget(input.value);
}

function updateRemoteExecTargetDisplay(){
  const targetEl = document.getElementById('remoteExec_target');
  if (!targetEl) return;
  targetEl.textContent = `Target: ${getRemoteExecTarget()}`;
}
function secsToHhMmSs(secs){ if(!secs&&secs!==0)return'—'; const s=Math.floor(secs); const h=(s/3600)|0,m=((s%3600)/60)|0,ss=s%60; return `${h}h ${m}m ${ss}s`; }
function tsToAgo(tsSec){ if(!tsSec)return'—'; const now=(Date.now()/1000)|0; const d=Math.max(0,now-tsSec); if(d<60)return`${d|0}s ago`; if(d<3600)return`${(d/60)|0}m ago`; if(d<86400)return`${(d/3600)|0}h ago`; return`${(d/86400)|0}d ago`; }
function fmtDate(tsSec){ if(!tsSec)return'—'; const d=new Date(tsSec*1000); return d.toISOString().replace('T',' ').replace(/\.\d+Z$/,'Z'); }
function fmtSizeMb(bytes){ if(typeof bytes!=='number'||!Number.isFinite(bytes)||bytes<0)return'—'; const mb=bytes/1048576; const places=mb>=100?0:(mb>=10?1:2); return `${mb.toFixed(places)} MB`; }
function fmtLocalDateTime(tsSec){ if(typeof tsSec!=='number'||!Number.isFinite(tsSec)||tsSec<=0)return'—'; const d=new Date(tsSec*1000); if(Number.isNaN(d.getTime()))return'—'; return d.toLocaleString(); }

function makeDebounce(fn, wait){
  let t=null, lastArgs=null;
  return (...args)=>{
    lastArgs=args;
    if(t) clearTimeout(t);
    t=setTimeout(()=>{ t=null; fn(...lastArgs); }, wait);
  };
}

function flashCtl(ctlEl, ok){
  const cls = ok ? 'flash-ok' : 'flash-err';
  ctlEl.classList.add(cls);
  setTimeout(()=> ctlEl.classList.remove(cls), 700);
}

function miniRkStatusEl(){
  return document.getElementById('pixelpilotMiniRkStatus');
}

function setMiniRkStatusIdle(text='Idle'){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('running','ok','err','flash');
  el.textContent = text;
  el.title = '';
}

function setMiniRkStatusRunning(){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('ok','err','flash');
  el.classList.add('running');
  el.textContent = 'Running…';
  el.title = '';
}

function setMiniRkStatusResult(ok, detail=''){
  const el = miniRkStatusEl();
  if (!el) return;
  el.classList.remove('running','ok','err','flash');
  el.classList.add(ok ? 'ok' : 'err');
  const stamp = new Date().toLocaleTimeString();
  const label = ok ? 'Success' : 'Error';
  el.textContent = `${label} • ${stamp}`;
  el.title = detail || '';
  // restart animation
  void el.offsetWidth;
  el.classList.add('flash');
}

async function runMiniRkCommand(command, btnEl){
  const payload = typeof command === 'string'
    ? { path: command, args: [] }
    : {
        path: command?.path || '',
        args: Array.isArray(command?.args) ? command.args : []
      };
  if (!payload.path){
    setMiniRkStatusResult(false, 'invalid command');
    return;
  }
  setMiniRkStatusRunning();
  if (btnEl) btnEl.disabled = true;
  try{
    const res = await postExec(payload, CMD_TIMEOUT_MS, 'pixelpilotMiniRk');
    const ok = (res && typeof res.rc === 'number') ? res.rc === 0 : true;
    const rawStdout = (res?.stdout ?? '').trim();
    const rawStderr = (res?.stderr ?? '').trim();
    const detail = ok ? (rawStdout.split('\n')[0] || '') : (rawStderr || rawStdout || 'command failed');
    setMiniRkStatusResult(ok, detail);
  }catch(e){
    setMiniRkStatusResult(false, e?.message || 'command failed');
  }finally{
    if (btnEl) btnEl.disabled = false;
  }
}

const CAP_GET_STAGGER_MS = 100;
const CAP_GET_TIMEOUT_MS = 150;
const CAP_SET_DEBOUNCE_MS = 500;
const CMD_TIMEOUT_MS = 3000;

async function fetchWithTimeout(url, opts = {}, ms = 100){
  const ctrl = new AbortController();
  const id = setTimeout(() => ctrl.abort('timeout'), ms);
  try{
    return await fetch(url, { ...opts, signal: ctrl.signal });
  } finally {
    clearTimeout(id);
  }
}

async function postExec(body, timeoutMs = 100, prefix = ''){
  const reqEl = document.getElementById(prefix+'ReqPreview');
  const respEl = document.getElementById(prefix+'Resp');
  if (reqEl) reqEl.textContent = fmtOneLine(body);
  try{
    const r = await fetchWithTimeout('/exec', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(body)
    }, timeoutMs);
    const txt = await r.text();
    if (respEl) respEl.value = txt.replace(/\n/g,'\\n');
    try { return JSON.parse(txt); }
    catch { return { rc:-1, stdout:txt, stderr:"", elapsed_ms:0 }; }
  }catch(e){
    const payload = { error: (e?.name === 'AbortError' ? 'timeout' : 'network_error'), message: e?.message || String(e), timeout_ms: timeoutMs };
    if (respEl) respEl.value = JSON.stringify(payload);
    throw e;
  }
}


  // Resolve which host to use for the relay UI
function getTargetHost() {
  const qp = new URLSearchParams(location.search);
  // Allow ?host=192.168.2.20 (useful when embedding this page from a scanner)
  return qp.get('host') || location.hostname || 'localhost';
}

// Build base URL for the UI on port 9000 using the resolved host
function relayBase() {
  // If parent is https, prefer http for :9000 unless you terminate TLS there
  const proto = (location.protocol === 'https:' ? 'http:' : location.protocol);
  return `${proto}//${getTargetHost()}:9000/`;
}


function parseArgs(text){
  const out = [];
  text.trim().replace(/"([^\"]*)"|'([^']*)'|(\S+)/g, (_,dq,sq,bare) => { out.push((dq ?? sq ?? bare) + ''); return ''; });
  return out;
}
async function doExec(){
  const path = $('#exec_path').value.trim();
  const args = parseArgs($('#exec_args').value);
  const body = { path, args };
  $('#exec_body_preview').textContent = fmtOneLine(body);
  try{
    const r = await fetch('/exec',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)});
    const txt = await r.text();
    $('#exec_out').value = txt.replace(/\n/g,'\\n');
  }catch(e){
    $('#exec_out').value = `{"error":"fetch_failed","msg":"${e.message}"}`;
  }
}

async function doRemoteExec(){
  const pathInput = $('#remoteExec_path');
  const argsInput = $('#remoteExec_args');
  const previewEl = $('#remoteExec_body_preview');
  const outEl = $('#remoteExec_out');
  if (!pathInput || !argsInput || !previewEl || !outEl) return;
  const path = pathInput.value.trim();
  const args = parseArgs(argsInput.value);
  const body = { path, args };
  previewEl.textContent = fmtOneLine(body);
  const target = getRemoteExecTarget();
  updateRemoteExecTargetDisplay();
  try{
    const r = await fetch(target,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)});
    const txt = await r.text();
    outEl.value = txt.replace(/\n/g,'\\n');
  }catch(e){
    outEl.value = `{"error":"fetch_failed","msg":"${e.message}"}`;
  }
}

let nodesPollTimer = null;

function nodeKeyOf(node, idx){
  const rawIp = (node?.ip || node?.host || node?.addr || '').toString().trim();
  const hasPort = node && node.port !== undefined && node.port !== null && String(node.port).length;
  if (rawIp && hasPort) return `${rawIp}:${node.port}`;
  if (rawIp) return rawIp;
  return `node-${idx}`;
}

function safeNodeIdFromKey(key, idx){
  const cleaned = String(key || '').replace(/[^A-Za-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
  return cleaned || `node-${idx}`;
}

function nodeBaseUrl(node){
  if (!node) return null;
  const explicit = (node.url || node.base_url || '').toString().trim();
  let raw = explicit || (node.ip || node.host || node.addr || '').toString().trim();
  if (!raw) return null;
  if (!/^https?:\/\//i.test(raw)){
    const scheme = (node.scheme || node.proto || 'http').toString().trim().replace(/:$/, '') || 'http';
    raw = `${scheme}://${raw.replace(/^\/+/, '')}`;
  }
  try{
    const u = new URL(raw);
    if (node.port !== undefined && node.port !== null && String(node.port).length){
      u.port = String(node.port);
    }
    u.pathname = '';
    u.hash = '';
    u.search = '';
    return u.toString().replace(/\/+$/, '');
  }catch{
    return raw.replace(/\/+$/, '');
  }
}

function nodeExecUrl(node){
  const base = nodeBaseUrl(node);
  if (!base) return null;
  return base.endsWith('/exec') ? base : `${base}/exec`;
}

const REMOTE_NODE_MIN_TIMEOUT_MS = 500;

async function postExecToNode(entry, body, timeoutMs = 400){
  const url = nodeExecUrl(entry.node);
  if (!url) throw new Error('invalid target');
  const finalTimeout = Math.max(timeoutMs || 0, REMOTE_NODE_MIN_TIMEOUT_MS);
  let resp;
  try{
    resp = await fetchWithTimeout(url, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(body)
    }, finalTimeout);
  }catch(e){
    if (e?.name === 'AbortError') throw new Error('request timed out');
    throw new Error(e?.message || 'network error');
  }
  const txt = await resp.text();
  let parsed;
  try{ parsed = JSON.parse(txt); }
  catch{ parsed = { rc:-1, stdout:txt, stderr:'', elapsed_ms:0 }; }
  if (!resp.ok){
    const msg = (parsed && typeof parsed==='object' && (parsed.stderr || parsed.stdout)) ? (parsed.stderr || parsed.stdout) : `HTTP ${resp.status}`;
    throw new Error(msg);
  }
  return parsed;
}

function ensureNodeManager(entry){
  if (!entry.manager){
    entry.manager = createCapManager({
      cap:'video',
      prefix:`node${entry.safeId}`,
      gridId: entry.gridId,
      statsId: entry.statsId,
      cmdsId: entry.cmdsId,
      exec:(body, timeoutMs)=> postExecToNode(entry, body, timeoutMs),
      getTimeoutMs: 1200,
      getRetryDelayMs: 120,
      getRetries: 4,
      setTimeoutMs: 5000,
      helpTimeoutMs: 600,
      staggerMs: 180
    });
  }
  return entry.manager;
}

function updateNodeTargetInfo(entry){
  if (!entry.targetEl) return;
  const url = nodeExecUrl(entry.node);
  if (url){
    entry.targetEl.textContent = `Target: ${url}`;
    entry.targetEl.title = url;
  } else {
    entry.targetEl.textContent = 'Target: unavailable';
    entry.targetEl.title = '';
  }
}

function toggleNodeExpansion(entry, nodeDiv, controlsEl, headEl){
  if (nodesUI.expanded.has(entry.key)){
    nodesUI.expanded.delete(entry.key);
    nodeDiv.classList.remove('expanded');
    controlsEl.style.display = 'none';
    headEl.setAttribute('aria-expanded','false');
    return;
  }
  nodesUI.expanded.add(entry.key);
  nodeDiv.classList.add('expanded');
  controlsEl.style.display = 'grid';
  headEl.setAttribute('aria-expanded','true');
  const manager = ensureNodeManager(entry);
  manager.ensureUI();
}

function renderNodesCard(state){
  const {nodes=[],scan_feature_enabled=0,scanning=0,targets=0,done=0,progress_pct,last_started,last_finished}=state||{};
  const pct = typeof progress_pct==='number' ? clamp(Math.round(progress_pct),0,100)
             : (targets>0 ? clamp(Math.round(100*done/targets),0,100) : (scanning?0:100));
  $('#nodesStats').textContent = `feature:${scan_feature_enabled?'on':'off'} • scanning:${scanning?'yes':'no'} • targets:${targets} • done:${done} • progress:${pct}% • started:${fmtDate(last_started)} • finished:${fmtDate(last_finished)}`;
  $('#nodesProgress').style.width = pct + '%';
  const notice = scanning ? 'Scanning… polling /nodes every 800ms'
               : (nodes.length?`${nodes.length} node(s) found • click a node to expand controls`:'No nodes found');
  $('#nodesNotice').textContent = notice;
  $('#nodesScanBtn').disabled = !scan_feature_enabled || !!scanning;
  const grid=$('#nodesGrid'); grid.innerHTML='';
  const seen = new Set();
  nodes.forEach((n, idx)=>{
    const key = nodeKeyOf(n, idx);
    const safeId = safeNodeIdFromKey(key, idx);
    seen.add(key);
    let entry = nodesUI.entries.get(key);
    if (!entry){
      entry = { key, safeId, manager:null };
      nodesUI.entries.set(key, entry);
    }
    entry.node = n;
    entry.safeId = safeId;

    const nodeDiv=document.createElement('div'); nodeDiv.className='node';
    const expanded = nodesUI.expanded.has(key);
    if (expanded) nodeDiv.classList.add('expanded');

    const controlsId = `node-${safeId}-controls`;
    const head=document.createElement('div');
    head.className='node-head';
    head.tabIndex=0;
    head.setAttribute('role','button');
    head.setAttribute('aria-expanded', expanded?'true':'false');
    head.setAttribute('aria-controls', controlsId);

    const top=document.createElement('div'); top.className='top';
    const roleSpan=document.createElement('span'); roleSpan.className='pill role'; roleSpan.textContent=n.role||'—';
    const ipSpan=document.createElement('span'); ipSpan.className='ip'; ipSpan.textContent=`${n.ip||'—'}:${n.port||''}`;
    top.append(roleSpan, ipSpan);

    const deviceLine=document.createElement('div');
    const deviceStrong=document.createElement('strong'); deviceStrong.textContent=n.device||'—';
    const metaSpan=document.createElement('span'); metaSpan.className='meta'; metaSpan.textContent=`v${n.version||'—'}`;
    deviceLine.append(deviceStrong, document.createTextNode(' '), metaSpan);

    const metaLine=document.createElement('div'); metaLine.className='meta';
    metaLine.textContent = `last seen: ${tsToAgo(n.last_seen)} (${fmtDate(n.last_seen)})`;

    head.append(top, deviceLine, metaLine);

    const controlsWrap=document.createElement('div');
    controlsWrap.className='node-controls';
    controlsWrap.id = controlsId;
    controlsWrap.style.display = expanded ? 'grid' : 'none';

    const toolbar=document.createElement('div'); toolbar.className='node-control-toolbar';
    const cmdsHolder=document.createElement('div'); cmdsHolder.className='row';
    const cmdsId = `node-${safeId}-cmds`;
    cmdsHolder.id = cmdsId;
    const refreshBtn=document.createElement('button'); refreshBtn.type='button'; refreshBtn.textContent='Refresh values';
    const spacer=document.createElement('div'); spacer.className='spacer';
    const stats=document.createElement('div'); stats.className='node-control-stats';
    const statsId = `node-${safeId}-stats`;
    stats.id = statsId;
    stats.textContent='—';
    toolbar.append(cmdsHolder, refreshBtn, spacer, stats);

    const gridDiv=document.createElement('div'); gridDiv.className='video-grid';
    const gridId = `node-${safeId}-grid`;
    gridDiv.id = gridId;

    const targetInfo=document.createElement('div'); targetInfo.className='node-target mut';

    controlsWrap.append(toolbar, gridDiv, targetInfo);

    nodeDiv.append(head, controlsWrap);
    grid.appendChild(nodeDiv);

    entry.gridId = gridId;
    entry.cmdsId = cmdsId;
    entry.statsId = statsId;
    entry.targetEl = targetInfo;

    updateNodeTargetInfo(entry);

    const toggle = ()=> toggleNodeExpansion(entry, nodeDiv, controlsWrap, head);
    head.addEventListener('click', toggle);
    head.addEventListener('keydown', ev=>{ if(ev.key==='Enter'||ev.key===' '){ ev.preventDefault(); toggle(); } });

    refreshBtn.addEventListener('click', ev=>{
      ev.stopPropagation();
      const manager = ensureNodeManager(entry);
      manager.ensureUI();
    });

    if (expanded){
      const manager = ensureNodeManager(entry);
      manager.ensureUI();
    }
  });

  for (const key of Array.from(nodesUI.entries.keys())){
    if (!seen.has(key)){
      nodesUI.entries.delete(key);
      nodesUI.expanded.delete(key);
    }
  }
}
async function fetchNodes(){
  if (!nodesUI.enabled) return;
  try{
    const r = await fetch('/nodes',{cache:'no-store'});
    if (!nodesUI.enabled) return;
    const data = await r.json();
    if (!nodesUI.enabled) return;
    renderNodesCard(data);
    if (data.scanning){ if(!nodesPollTimer){ nodesPollTimer=setInterval(fetchNodes,800); } }
    else { if(nodesPollTimer){ clearInterval(nodesPollTimer); nodesPollTimer=null; } }
  }catch(e){
    if (!nodesUI.enabled) return;
    renderNodesCard({nodes:[]});
    $('#nodesNotice').textContent = `Failed to load /nodes: ${e.message}`;
    if (nodesPollTimer){ clearInterval(nodesPollTimer); nodesPollTimer = null; }
  }
}
async function triggerNodesScan(){
  if (!nodesUI.enabled) return;
  $('#nodesScanBtn').disabled = true;
  try{ await fetch('/nodes',{method:'POST',headers:{'Content-Type':'application/json'},body:'{}'}); }
  catch(e){ $('#nodesNotice').textContent = `Failed to POST /nodes: ${e.message}`; }
  finally{ fetchNodes(); }
}

function sortSettings(settings){
  const sliders=[], selects=[], toggles=[];
  for (const s of settings){
    const k = s.control?.kind;
    if (k==='range') sliders.push(s);
    else if (k==='select') selects.push(s);
    else if (k==='toggle') toggles.push(s);
  }
  return [...sliders, ...selects, ...toggles];
}
function coerceForKey(meta, raw){
  if (raw==null) return raw;
  const t = meta.type;
  if (t==='int') return (raw===true?1:(raw===false?0:parseInt(raw,10)));
  if (t==='float') return (raw===true?1:(raw===false?0:parseFloat(raw)));
  if (t==='bool') {
    if (typeof raw === 'boolean') return raw;
    const s = String(raw).toLowerCase();
    return (s==='1'||s==='true'||s==='yes'||s==='on');
  }
  return String(raw);
}
function valueToString(meta, v){
  if (meta.type==='bool') return v ? '1' : '0';
  if (typeof v === 'number') return (Number.isFinite(v)? String(v) : '');
  return String(v ?? '');
}

function createCtlContainer(meta){
  const wrap = document.createElement('div'); wrap.className='ctl';
  const lbl  = document.createElement('div'); lbl.className='lbl';
  const name = document.createElement('div'); name.className='name'; name.textContent = meta.key;
  const val  = document.createElement('div'); val.className='val'; val.textContent = '…';
  lbl.append(name,val);
  const holder = document.createElement('div');
  const desc = document.createElement('div'); desc.className='desc'; desc.textContent = meta.description || '';
  const err = document.createElement('div'); err.className='errtxt'; err.style.display='none';
  wrap.append(lbl, holder, desc, err);
  return {wrap,holder,valEl:val,errEl:err};
}

function createSlider(meta){
  const {wrap,holder,valEl,errEl} = createCtlContainer(meta);
  const input = document.createElement('input');
  input.type = 'range';
  const min = Number(meta.control?.min ?? 0);
  const max = Number(meta.control?.max ?? 100);
  const step= Number(meta.control?.step ?? 1);
  input.min = String(min); input.max = String(max); input.step = String(step);
  input.addEventListener('input', ()=>{ valEl.textContent = input.value + (meta.control?.unit?(' '+meta.control.unit):''); });
  holder.append(input);
  return {el:wrap,input,valEl,errEl,kind:'range',min,max,step};
}

function createSelect(meta){
  const {wrap,holder,valEl,errEl} = createCtlContainer(meta);
  const sel = document.createElement('select');
  const opts = (meta.control?.options ?? []);
  for (const o of opts){
    const opt = document.createElement('option'); opt.value = String(o); opt.textContent = String(o); sel.appendChild(opt);
  }

  const allowFree = !!meta.control?.allow_free;
  let freeWrap=null, freeInput=null;
  if (allowFree){
    const optFree = document.createElement('option'); optFree.value="__free__"; optFree.textContent="Input value…";
    sel.appendChild(optFree);

    freeWrap = document.createElement('div'); freeWrap.className = 'freebox';
    freeInput = document.createElement('input'); freeInput.type='text'; freeInput.placeholder='Enter value…';
    freeWrap.appendChild(freeInput);
  }

  sel.addEventListener('change', ()=>{
    if (allowFree && sel.value==="__free__"){
      if (freeWrap) freeWrap.style.display = 'block';
      valEl.textContent = (freeInput && freeInput.value) || '';
    } else {
      if (allowFree && freeWrap) freeWrap.style.display = 'none';
      valEl.textContent = sel.value;
    }
  });
  if (allowFree && freeInput){
    freeInput.addEventListener('input', ()=>{ valEl.textContent = freeInput.value; });
  }

  holder.append(sel);
  if (allowFree) holder.append(freeWrap);

  return {el:wrap,input:sel,valEl,errEl,kind:'select',allowFree,freeWrap,freeInput};
}

function createToggle(meta){
  const {wrap,holder,valEl,errEl} = createCtlContainer(meta);
  const label = document.createElement('label'); label.className='switch';
  const chk = document.createElement('input'); chk.type='checkbox';
  chk.addEventListener('change', ()=>{ valEl.textContent = chk.checked ? 'true' : 'false'; });
  label.append(chk); holder.append(label);
  return {el:wrap,input:chk,valEl,errEl,kind:'toggle'};
}

function createCapManager(config){
  const state = { help:null, controls:{}, order:[] };
  const execFn = typeof config.exec === 'function'
    ? config.exec
    : (body, timeoutMs)=> postExec(body, timeoutMs, config.prefix);

  const getTimeoutMs = Math.max(0, config.getTimeoutMs ?? CAP_GET_TIMEOUT_MS);
  const getRetryDelayMs = Math.max(0, config.getRetryDelayMs ?? 50);
  const getRetries = Math.max(1, config.getRetries ?? 3);
  const staggerMs = Math.max(0, config.staggerMs ?? CAP_GET_STAGGER_MS);
  const setTimeoutMs = Math.max(0, config.setTimeoutMs ?? CMD_TIMEOUT_MS);
  const helpTimeoutMs = Math.max(0, config.helpTimeoutMs ?? 350);

  const pairErrRe = /(missing (?:key|value) in pair|usage:[^\n]*key=value)/i;

  function responseOk(res){
    if (!res) return false;
    if (typeof res.rc === 'number') return res.rc === 0;
    if (res.rc !== undefined){
      const num = Number(res.rc);
      if (Number.isFinite(num)) return num === 0;
      return false;
    }
    return true;
  }

  function responseMessage(res){
    if (!res || typeof res !== 'object') return '';
    const stderr = (res.stderr ?? '').toString().trim();
    const stdout = (res.stdout ?? '').toString().trim();
    return stderr || stdout || '';
  }

  function combineMessages(...parts){
    const uniq = [];
    for (const part of parts){
      const text = (part ?? '').toString().trim();
      if (!text) continue;
      if (!uniq.includes(text)) uniq.push(text);
    }
    return uniq.join('\n');
  }

  async function execSetCommand(key, valStr){
    const path = `/sys/${config.cap}/set`;
    const run = async (args)=> execFn({ path, args }, setTimeoutMs);
    const firstArgs = [`${key}=${valStr}`];
    const firstRes = await run(firstArgs);
    if (responseOk(firstRes)){
      return { ok:true, res:firstRes };
    }
    const firstMsg = responseMessage(firstRes);
    if (!pairErrRe.test(firstMsg)){
      return { ok:false, res:firstRes };
    }
    const secondArgs = [key, valStr];
    const secondRes = await run(secondArgs);
    if (responseOk(secondRes)){
      return { ok:true, res:secondRes, prev:firstRes };
    }
    return { ok:false, res:secondRes, prev:firstRes };
  }

  function parseGetStdoutValue(key, stdout){
    if (stdout==null) return undefined;
    const t = String(stdout).trim();
    try{
      const j = JSON.parse(t);
      if (j && typeof j==='object'){
        if ('value' in j) return j.value;
        if (key in j) return j[key];
      }
    }catch{}
    const m = /^([^=\s]+)\s*=\s*(.+)$/.exec(t);
    if (m && m[1]===key) return m[2];
    return t;
  }

  function applyValueToUI(meta, value){
    const ctl = state.controls[meta.key];
    if (!ctl) return;
    ctl.errEl.style.display='none';
    const coerced = coerceForKey(meta, value);

    if (ctl.kind==='toggle'){
      ctl.input.checked = !!coerced;
      ctl.valEl.textContent = ctl.input.checked ? 'true' : 'false';
      return;
    }
    if (ctl.kind==='range'){
      const num = Number(coerced);
      const v = clamp(Number.isFinite(num)?num:Number(ctl.input.min), ctl.min, ctl.max);
      ctl.input.value = String(v);
      ctl.valEl.textContent = v + (meta.control?.unit?(' '+meta.control.unit):'');
      return;
    }
    if (ctl.kind==='select'){
      const s = String(coerced ?? '');
      let matched = false;
      for (const opt of ctl.input.options){
        if (opt.value !== "__free__" && opt.value === s){
          ctl.input.value = s; matched = true; break;
        }
      }
      if (matched){
        if (ctl.allowFree && ctl.freeWrap) ctl.freeWrap.style.display='none';
        ctl.valEl.textContent = ctl.input.value;
      } else if (ctl.allowFree){
        ctl.input.value = "__free__";
        if (ctl.freeWrap) ctl.freeWrap.style.display='block';
        if (ctl.freeInput) ctl.freeInput.value = s;
        ctl.valEl.textContent = s;
      } else {
        ctl.valEl.textContent = s;
      }
      return;
    }
  }

  async function getWithRetries(key, retries = getRetries){
    let attempt=0, lastErr='unknown';
    while (attempt<retries){
      try{
        const body = { path:`/sys/${config.cap}/get`, args:[ key ] };
        const res = await execFn(body, getTimeoutMs);
        const v = parseGetStdoutValue(key, res.stdout ?? '');
        if (v!==undefined && v!==null && String(v).length){
          return {ok:true, value:v};
        }
        if (v !== undefined && v !== null) return {ok:true, value:v};
        lastErr = 'empty';
      }catch(e){
        lastErr = e.message || 'fetch';
      }
      attempt++;
      if (attempt<retries) await sleep(getRetryDelayMs);
    }
    return {ok:false, err:lastErr};
  }

  function attachImmediateApply(meta, ctl){
    const key = meta.key;
    const apply = async (nextVal)=>{
      const rawStr = valueToString(meta, nextVal);
      const valStr = (typeof rawStr === 'string') ? rawStr.trim() : rawStr;
      try{
        ctl.errEl.style.display='none';
        const { ok, res, prev } = await execSetCommand(key, String(valStr ?? ''));
        flashCtl(ctl.el, ok);
        if (!ok){
          const detail = combineMessages(responseMessage(res), responseMessage(prev));
          const label = detail
            ? (/set failed/i.test(detail) ? detail : `set failed: ${detail}`)
            : 'set failed: command failed';
          ctl.errEl.textContent = label;
          ctl.errEl.style.display='block';
        }
        try {
          const got = await getWithRetries(key, Math.max(1, Math.min(2, getRetries)));
          if (got.ok) applyValueToUI(meta, got.value);
        } catch {}
      }catch(e){
        flashCtl(ctl.el, false);
        ctl.errEl.textContent = `set failed: ${e.message}`;
        ctl.errEl.style.display='block';
      }
    };
    const deb = makeDebounce(apply, CAP_SET_DEBOUNCE_MS);
    ctl.debouncedSet = deb;

    if (ctl.kind==='range'){
      const emit = ()=> ctl.debouncedSet(Number(ctl.input.value));
      ctl.input.addEventListener('input', emit);
      ctl.input.addEventListener('change', emit);
    } else if (ctl.kind==='select'){
      const emitSel = ()=>{
        if (ctl.allowFree && ctl.input.value==="__free__"){
          if (ctl.freeWrap) ctl.freeWrap.style.display='block';
          const v = (ctl.freeInput?.value ?? '').trim();
          if (!v) return;
          ctl.debouncedSet(v);
        } else {
          if (ctl.allowFree && ctl.freeWrap) ctl.freeWrap.style.display='none';
          ctl.debouncedSet(ctl.input.value);
        }
      };
      ctl.input.addEventListener('change', emitSel);
      if (ctl.allowFree && ctl.freeInput){
        ctl.freeInput.addEventListener('input', ()=>{
          const v=(ctl.freeInput.value||'').trim();
          if (!v) return;
          ctl.debouncedSet(v);
        });
      }
    } else if (ctl.kind==='toggle'){
      ctl.input.addEventListener('change', ()=> ctl.debouncedSet(!!ctl.input.checked));
    }
  }

  function buildCommandButtons(help){
    const holder = document.getElementById(config.cmdsId);
    if (!holder) return;
    holder.innerHTML = '';
    const names = new Set((help?.commands||[]).map(c=>c.name));
    const labelMap = { start:'Start', stop:'Stop', restart:'Restart', apply:'Apply', status:'Status', mode:'Mode', toggle_record:'Toggle record' };
    for (const cmd of ['start','stop','restart','apply','status','toggle_record']){
      if (!names.has(cmd)) continue;
      const btn = document.createElement('button');
      btn.textContent = labelMap[cmd] || cmd;
      btn.addEventListener('click', async ()=>{
        try{
          const res = await execFn({path:`/sys/${config.cap}/${cmd}`, args:[]}, CMD_TIMEOUT_MS);
          const ok = (res && typeof res.rc === 'number') ? res.rc===0 : true;
          const anyCtl = Object.values(state.controls)[0];
          if (anyCtl) flashCtl(anyCtl.el, ok);
        }catch{
          const anyCtl = Object.values(state.controls)[0];
          if (anyCtl) flashCtl(anyCtl.el, false);
        }
      });
      holder.appendChild(btn);
    }
  }

  function buildControls(settings){
    const grid = document.getElementById(config.gridId);
    if (!grid) return;
    grid.innerHTML = '';
    state.controls = {};
    const sorted = sortSettings(settings);
    state.order = sorted.map(s=>s.key);
    for (const meta of sorted){
      let ctl;
      const kind = meta.control?.kind;
      if (kind==='range') ctl = createSlider(meta);
      else if (kind==='select') ctl = createSelect(meta);
      else if (kind==='toggle') ctl = createToggle(meta);
      else continue;
      attachImmediateApply(meta, ctl);
      grid.appendChild(ctl.el);
      state.controls[meta.key] = {...ctl, meta};
      applyValueToUI(meta, meta.default);
    }
  }

  async function refreshValues(){
    const keys = state.order.slice();
    let idx = 0, ok=0, fail=0;
    for (const key of keys){
      if (idx>0) await sleep(staggerMs);
      const meta = state.controls[key]?.meta;
      if (!meta){ idx++; continue; }
      const got = await getWithRetries(key, getRetries);
      if (got.ok){ ok++; applyValueToUI(meta, got.value); }
      else { fail++; const ctl = state.controls[key]; if (ctl){ ctl.errEl.textContent = got.err || 'get failed'; ctl.errEl.style.display='block'; } }
      idx++;
    }
    const statsEl = document.getElementById(config.statsId);
    if (statsEl) statsEl.textContent = `refreshed ${ok} ok, ${fail} failed • ${new Date().toLocaleTimeString()}`;
  }

  async function ensureUI(){
    const statsEl = document.getElementById(config.statsId);
    if (!state.help){
      if (statsEl) statsEl.textContent = 'loading help…';
      let helpRes;
      try {
        helpRes = await execFn({path:`/sys/${config.cap}/help`, args:[]}, helpTimeoutMs);
      } catch(e){
        if (statsEl) statsEl.textContent = `failed to load help: ${e.message}`;
        return;
      }
      let helpJson = null;
      try { helpJson = JSON.parse(helpRes.stdout || '{}'); } catch { helpJson = null; }
      if (!helpJson || !Array.isArray(helpJson.settings)){
        if (statsEl) statsEl.textContent = 'failed to parse help';
        return;
      }
      state.help = helpJson;
      buildCommandButtons(helpJson);
      buildControls(helpJson.settings);
      if (typeof config.onFirstHelp === 'function') config.onFirstHelp(helpJson, state);
    }
    else {
      const cmdsHolder = document.getElementById(config.cmdsId);
      if (cmdsHolder && !cmdsHolder.childElementCount) buildCommandButtons(state.help);
      const gridEl = document.getElementById(config.gridId);
      if (gridEl && !gridEl.childElementCount && Array.isArray(state.help?.settings)){
        buildControls(state.help.settings);
      }
    }
    if (statsEl) statsEl.textContent = 'refreshing…';
    await refreshValues();
  }

  return { ensureUI, refreshValues };
}

const pixelpilotManager = createCapManager({
  cap:'pixelpilot',
  prefix:'pixelpilot',
  gridId:'pixelpilotGrid',
  statsId:'pixelpilotStats',
  cmdsId:'pixelpilotCmds'
});

const udpRelayManager = createCapManager({
  cap:'udp_relay',
  prefix:'udpRelay',
  gridId:'udpRelayGrid',
  statsId:'udpRelayStats',
  cmdsId:'udpRelayCmds',
  onFirstHelp(){ ensureUdpRelayEmbed(); }
});

const udpRelayEmbed = { initialized:false, iframe:null };
function ensureUdpRelayEmbed(){
  if (udpRelayEmbed.initialized) return;
  const wrap = document.getElementById('udpRelayEmbedContainer');
  if (!wrap) return;
  wrap.innerHTML = '';
  const iframe = document.createElement('iframe');
  iframe.src = relayBase();
  iframe.loading = 'lazy';
  iframe.referrerPolicy = 'no-referrer';
  iframe.className = 'embed-frame';
  iframe.title = 'UDP relay UI';
  wrap.appendChild(iframe);

  const note = document.createElement('div');
  note.className = 'embed-note mut';
  const base = relayBase();
  note.innerHTML = `If the live UI fails to load, <a href="${base}" target="_blank" rel="noreferrer">open ${base}</a> or <a href="../udp_relay/vtx_udp_relay.html" target="_blank" rel="noreferrer">view the static copy</a>.`;

  wrap.parentNode.insertBefore(note, wrap.nextSibling);

  udpRelayEmbed.initialized = true;
  udpRelayEmbed.iframe = iframe;
}
function reloadUdpRelayEmbed(){
  if (!udpRelayEmbed.iframe) ensureUdpRelayEmbed();
  if (udpRelayEmbed.iframe){
    const base = relayBase();
    udpRelayEmbed.iframe.src = base + (base.includes('?') ? '&' : '?') + 't=' + Date.now();

  }
}

const udpSenderDefaults = Object.freeze({
  host:'192.168.2.20',
  port:5005,
  xsize:50,
  ysize:50,
  xpos:50,
  ypos:50,
  ttl:10000
});

const udpSenderState = { initialized:false, values:{ ...udpSenderDefaults } };

const UDP_SENDER_ROI_KEYS = ['xsize','ysize','xpos','ypos'];
const UDP_SENDER_ROI_LIMITS = Object.freeze({
  xsize:{ min:25, max:100 },
  ysize:{ min:25, max:100 },
  xpos:{ min:0, max:100 },
  ypos:{ min:0, max:100 }
});

function clampUdpSenderValue(key, raw){
  const limits = UDP_SENDER_ROI_LIMITS[key] || {};
  let next = Math.round(Number(raw));
  if (!Number.isFinite(next)){
    next = udpSenderState.values[key] ?? udpSenderDefaults[key] ?? 0;
  }
  if (limits.min !== undefined && next < limits.min) next = limits.min;
  if (limits.max !== undefined && next > limits.max) next = limits.max;
  return next;
}

function setUdpSenderValue(key, value){
  const next = clampUdpSenderValue(key, value);
  udpSenderState.values[key] = next;
  return next;
}

function updateUdpSenderDisplays(){
  for (const key of UDP_SENDER_ROI_KEYS){
    const nodes = document.querySelectorAll(`[data-udp-value="${key}"]`);
    nodes.forEach(node => { node.textContent = udpSenderState.values[key]; });
  }
}

function collectUdpSenderValues(opts = {}){
  const strict = !!opts.strict;
  const errors = [];
  const values = { ...udpSenderState.values };

  const hostEl = document.getElementById('udpSenderHost');
  const hostRaw = (hostEl?.value ?? '').trim();
  if (!hostRaw){
    if (strict) errors.push('Host is required');
  } else {
    values.host = hostRaw;
  }

  function readInt(el, label, key, min, max){
    const raw = (el?.value ?? '').trim();
    if (!raw){
      if (strict) errors.push(`${label} is required`);
      return;
    }
    const num = Number(raw);
    if (!Number.isFinite(num)){
      if (strict) errors.push(`${label} must be a number`);
      return;
    }
    let val = Math.round(num);
    if (min !== undefined && val < min){
      if (strict) errors.push(`${label} must be ≥ ${min}`);
      val = min;
    }
    if (max !== undefined && val > max){
      if (strict) errors.push(`${label} must be ≤ ${max}`);
      val = max;
    }
    values[key] = val;
  }

  readInt(document.getElementById('udpSenderPort'), 'Port', 'port', 1, 65535);
  readInt(document.getElementById('udpSenderTtl'), 'TTL (ms)', 'ttl', 0);

  if (Number.isFinite(values.ttl)){
    udpSenderState.values.ttl = values.ttl;
  }

  return { values, errors };
}

function buildUdpSenderPayloadString(values){
  const zoom = `zoom=${values.xsize},${values.ysize},${values.xpos},${values.ypos}`;
  return `{"text":["","","","","","","","${zoom}"], "ttl_ms": ${values.ttl}}`;
}

function buildUdpSenderRequest(values){
  return {
    host: values.host,
    port: values.port,
    payload: buildUdpSenderPayloadString(values)
  };
}

function buildUdpSenderCurl(req){
  const origin = (typeof window !== 'undefined' && window.location && window.location.origin)
    ? window.location.origin
    : 'http://HOST:PORT';
  const body = JSON.stringify(req);
  const escaped = body.replace(/'/g, `'\''`);
  return [
    `curl -X POST ${origin}/udp \\`,
    `  -H 'Content-Type: application/json' \\`,
    `  -d '${escaped}'`
  ].join('\n');
}

function updateUdpSenderPreviews(){
  const { values } = collectUdpSenderValues();
  const req = buildUdpSenderRequest(values);
  const curlEl = document.getElementById('udpSenderCurlPreview');
  if (curlEl) curlEl.textContent = buildUdpSenderCurl(req);
  const bodyEl = document.getElementById('udpSenderBodyPreview');
  if (bodyEl) bodyEl.textContent = JSON.stringify(req, null, 2);
}

async function sendUdpSenderMessage(){
  const btn = document.getElementById('udpSenderSendBtn');
  const respEl = document.getElementById('udpSenderResponse');
  const { values, errors } = collectUdpSenderValues({ strict:true });
  if (errors.length){
    if (respEl) respEl.value = errors.join('\n');
    return;
  }
  const req = buildUdpSenderRequest(values);
  updateUdpSenderPreviews();
  if (respEl) respEl.value = 'Sending…';
  if (btn) btn.disabled = true;
  try {
    const res = await fetch('/udp', {
      method:'POST',
      headers:{ 'Content-Type':'application/json' },
      body: JSON.stringify(req)
    });
    const text = await res.text();
    let parsed = null;
    try { parsed = JSON.parse(text); } catch {}
    if (respEl){
      if (!res.ok){
        respEl.value = parsed ? JSON.stringify(parsed, null, 2) : `HTTP ${res.status} ${res.statusText}\n${text}`;
      } else {
        respEl.value = parsed ? JSON.stringify(parsed, null, 2) : text;
      }
    }
  } catch (err) {
    if (respEl) respEl.value = `Error: ${err?.message || err}`;
  } finally {
    if (btn) btn.disabled = false;
  }
}

function ensureUdpSenderUI(){
  if (udpSenderState.initialized) return;
  udpSenderState.values = { ...udpSenderDefaults };
  const inputIds = [
    'udpSenderHost',
    'udpSenderPort',
    'udpSenderTtl'
  ];
  for (const id of inputIds){
    const el = document.getElementById(id);
    if (!el) continue;
    el.addEventListener('input', updateUdpSenderPreviews);
    el.addEventListener('change', () => {
      updateUdpSenderPreviews();
      sendUdpSenderMessage();
    });
    if (el.tagName === 'INPUT'){
      el.addEventListener('keydown', ev => {
        if (ev.key === 'Enter'){
          ev.preventDefault();
          sendUdpSenderMessage();
        }
      });
    }
  }
  const ttlEl = document.getElementById('udpSenderTtl');
  if (ttlEl){
    const ttlNum = Math.round(Number(ttlEl.value));
    if (Number.isFinite(ttlNum) && ttlNum >= 0){
      udpSenderState.values.ttl = ttlNum;
    }
  }
  const dpadButtons = document.querySelectorAll('#udpSenderCard [data-udp-key][data-udp-delta]');
  dpadButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const key = btn.getAttribute('data-udp-key');
      const delta = Number(btn.getAttribute('data-udp-delta'));
      if (!key || Number.isNaN(delta)) return;
      setUdpSenderValue(key, (udpSenderState.values[key] ?? udpSenderDefaults[key] ?? 0) + delta);
      updateUdpSenderDisplays();
      updateUdpSenderPreviews();
      sendUdpSenderMessage();
    });
  });
  const sendBtn = document.getElementById('udpSenderSendBtn');
  if (sendBtn) sendBtn.addEventListener('click', sendUdpSenderMessage);
  const respEl = document.getElementById('udpSenderResponse');
  if (respEl) respEl.value = '';
  udpSenderState.initialized = true;
  updateUdpSenderDisplays();
  updateUdpSenderPreviews();
}

const linkUI = { help:null };

const nodesUI = { enabled:false, expanded:new Set(), entries:new Map() };

const pixelpilotMiniRkUI = { initialized:false };

const dvrUI = { initialized:false, hasExec:false, entries:[] };

function ensurePixelpilotMiniRkUI(){
  if (pixelpilotMiniRkUI.initialized) return;
  setMiniRkStatusIdle('Idle');
  const cfg = [
    { btn:'#pixelpilotMiniRkToggleOsdBtn', command:{ path:'/sys/pixelpilot_mini_rk/toggle_osd' } },
    { btn:'#pixelpilotMiniRkToggleRecordingBtn', command:{ path:'/sys/pixelpilot_mini_rk/toggle_recording' } },
    { btn:'#pixelpilotMiniRkRebootBtn', command:{ path:'/sys/reboot' } },
    { btn:'#pixelpilotMiniRkShutdownBtn', command:{ path:'/sys/shutdown' } },
    { btn:'#pixelpilotMiniRkRestartServiceBtn', command:{ path:'/sys/pixelpilot_mini_rk/restart' } },
    { btn:'#pixelpilotMiniRkStopServiceBtn', command:{ path:'/sys/pixelpilot_mini_rk/stop' } },
    { btn:'#pixelpilotMiniRkStartServiceBtn', command:{ path:'/sys/pixelpilot_mini_rk/start' } }
  ];
  for (const {btn, command} of cfg){
    const btnEl = document.querySelector(btn);
    if (!btnEl) continue;
    btnEl.addEventListener('click', ()=> runMiniRkCommand(command, btnEl));
  }
  pixelpilotMiniRkUI.initialized = true;
}

function parseDvrListFromHtml(html){
  if (typeof DOMParser !== 'function') return [];
  try{
    const doc = new DOMParser().parseFromString(html, 'text/html');
    const anchors = Array.from(doc.querySelectorAll('a'));
    const files = [];
    for (const a of anchors){
      const raw = a.getAttribute('href') || '';
      if (!raw || raw === '../') continue;
      const cleaned = raw.split('#')[0].split('?')[0].replace(/^\/+|\/+$/g,'');
      if (!cleaned || cleaned === '..') continue;
      let decoded = cleaned;
      try{ decoded = decodeURIComponent(cleaned); }catch{}
      if (decoded.toLowerCase().endsWith('.mp4')) files.push(decoded);
    }
    files.sort((a,b)=>a.localeCompare(b,'en',{numeric:true,sensitivity:'base'}));
    return files;
  }catch{
    return [];
  }
}

function renderDvrList(entries){
  const listEl = document.getElementById('dvrList');
  if (!listEl) return;
  dvrUI.entries = Array.isArray(entries) ? entries : [];
  listEl.innerHTML = '';
  for (const entry of dvrUI.entries){
    if (!entry || typeof entry.name !== 'string') continue;
    const item = document.createElement('div');
    item.className = 'dvr-item';
    const link = document.createElement('a');
    const encoded = encodeURIComponent(entry.name);
    link.href = `/media/${encoded}`;
    link.textContent = entry.name;
    link.download = entry.name;
    link.addEventListener('click', ev => {
      if (ev.button !== 0 || ev.metaKey || ev.ctrlKey || ev.shiftKey || ev.altKey) return;
      ev.preventDefault();
      downloadDvrRecording(entry);
    });
    item.appendChild(link);
    const meta = document.createElement('div');
    meta.className = 'dvr-meta';
    const sizeTxt = fmtSizeMb(entry.sizeBytes);
    const timeTxt = fmtLocalDateTime(entry.mtimeSec);
    meta.textContent = (sizeTxt === '—' && timeTxt === '—') ? '—' : `${sizeTxt} • ${timeTxt}`;
    meta.title = (typeof entry.mtimeSec === 'number' && Number.isFinite(entry.mtimeSec) && entry.mtimeSec > 0) ? fmtDate(entry.mtimeSec) : '';
    item.appendChild(meta);
    listEl.appendChild(item);
  }
}

async function enrichDvrEntries(entries){
  if (!Array.isArray(entries) || !entries.length) return;
  for (const entry of entries){
    if (!entry || typeof entry.name !== 'string') continue;
    const needsSize = !(typeof entry.sizeBytes === 'number' && Number.isFinite(entry.sizeBytes) && entry.sizeBytes >= 0);
    const needsTime = !(typeof entry.mtimeSec === 'number' && Number.isFinite(entry.mtimeSec) && entry.mtimeSec > 0);
    if (!needsSize && !needsTime) continue;
    try{
      const resp = await fetch(`/media/${encodeURIComponent(entry.name)}`, { method:'HEAD', cache:'no-store' });
      if (!resp.ok) continue;
      if (needsSize){
        const len = resp.headers.get('content-length');
        if (len){
          const size = Number(len);
          if (Number.isFinite(size) && size >= 0) entry.sizeBytes = size;
        }
      }
      if (needsTime){
        const lm = resp.headers.get('last-modified');
        if (lm){
          const ts = Date.parse(lm);
          if (!Number.isNaN(ts) && Number.isFinite(ts)) entry.mtimeSec = Math.floor(ts/1000);
        }
      }
    }catch{}
  }
}

async function downloadDvrRecording(entry){
  if (!entry || typeof entry.name !== 'string') return;
  const statusEl = document.getElementById('dvrStatus');
  const msgEl = document.getElementById('dvrMessage');
  const previousStatus = statusEl ? statusEl.textContent : '';
  if (statusEl) statusEl.textContent = `downloading ${entry.name}…`;
  if (msgEl){
    msgEl.classList.remove('ok','err');
    msgEl.textContent = `Preparing download for ${entry.name}…`;
    msgEl.style.display = 'block';
  }
  try{
    const resp = await fetch(`/media/${encodeURIComponent(entry.name)}`, { cache:'no-store' });
    if (!resp.ok) throw new Error(`download failed (${resp.status})`);
    const blob = await resp.blob();
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement('a');
    anchor.href = url;
    anchor.download = entry.name;
    document.body.appendChild(anchor);
    anchor.click();
    anchor.remove();
    setTimeout(()=> URL.revokeObjectURL(url), 1000);
    if (msgEl){
      msgEl.classList.add('ok');
      msgEl.textContent = `Download ready for ${entry.name}`;
    }
  }catch(e){
    if (msgEl){
      msgEl.classList.add('err');
      msgEl.textContent = e?.message || `Failed to download ${entry.name}`;
    }
  }finally{
    if (statusEl) statusEl.textContent = previousStatus || '';
  }
}

async function refreshDvrList(){
  const statusEl = document.getElementById('dvrStatus');
  const listEl = document.getElementById('dvrList');
  const emptyEl = document.getElementById('dvrEmptyState');
  const msgEl = document.getElementById('dvrMessage');
  if (!statusEl || !listEl || !emptyEl || !msgEl) return;
  statusEl.textContent = 'loading…';
  listEl.innerHTML = '';
  emptyEl.style.display = 'none';
  msgEl.style.display = 'none';
  msgEl.textContent = '';
  msgEl.classList.remove('ok','err');
  try{
    let entries = [];
    if (dvrUI.hasExec){
      const res = await postExec({path:'/sys/dvr/list', args:[]}, CMD_TIMEOUT_MS, 'dvr');
      const ok = (res && typeof res.rc === 'number') ? res.rc === 0 : true;
      const stdout = String(res?.stdout ?? '');
      entries = stdout.split(/\r?\n/).map(line => line.trim()).filter(Boolean).map(line => {
        const parts = line.split('\t');
        const name = (parts[0] || '').trim();
        if (!name) return null;
        const sizeCandidate = parts.length > 1 ? Number(parts[1]) : NaN;
        const mtimeCandidate = parts.length > 2 ? Number(parts[2]) : NaN;
        const sizeBytes = (Number.isFinite(sizeCandidate) && sizeCandidate >= 0) ? sizeCandidate : null;
        const mtimeSec = (Number.isFinite(mtimeCandidate) && mtimeCandidate > 0) ? Math.floor(mtimeCandidate) : null;
        return { name, sizeBytes, mtimeSec };
      }).filter(Boolean);
      if (!ok){
        entries = [];
        const errMsg = (res?.stderr || res?.stdout || 'failed to list recordings').trim();
        if (errMsg){
          msgEl.textContent = errMsg;
          msgEl.classList.add('err');
          msgEl.style.display = 'block';
        }
      }
    } else {
      const resp = await fetch('/media/', {cache:'no-store'});
      if (!resp.ok){
        throw new Error(`/media/ responded with ${resp.status}`);
      }
      const text = await resp.text();
      const names = parseDvrListFromHtml(text);
      entries = names.map(name => ({ name, sizeBytes:null, mtimeSec:null }));
    }
    if (entries.some(entry => !entry || typeof entry.name !== 'string')){
      entries = entries.filter(entry => entry && typeof entry.name === 'string');
    }
    const needsMeta = entries.some(entry => !(typeof entry.sizeBytes === 'number' && Number.isFinite(entry.sizeBytes) && entry.sizeBytes >= 0) || !(typeof entry.mtimeSec === 'number' && Number.isFinite(entry.mtimeSec) && entry.mtimeSec > 0));
    if (needsMeta){
      await enrichDvrEntries(entries);
    }
    entries.sort((a,b)=>{
      const aTs = (typeof a.mtimeSec === 'number' && Number.isFinite(a.mtimeSec)) ? a.mtimeSec : 0;
      const bTs = (typeof b.mtimeSec === 'number' && Number.isFinite(b.mtimeSec)) ? b.mtimeSec : 0;
      if (bTs !== aTs) return bTs - aTs;
      return a.name.localeCompare(b.name,'en',{numeric:true,sensitivity:'base'});
    });
    renderDvrList(entries);
    if (!entries.length){
      emptyEl.style.display = 'block';
    }
    statusEl.textContent = `${entries.length} recording${entries.length===1?'':'s'} • ${new Date().toLocaleTimeString()}`;
  }catch(e){
    statusEl.textContent = `error • ${new Date().toLocaleTimeString()}`;
    msgEl.textContent = e?.message || 'failed to load recordings';
    msgEl.classList.add('err');
    msgEl.style.display = 'block';
  }
}

async function deleteAllDvrRecordings(){
  if (!dvrUI.hasExec) return;
  if (!confirm('Delete all DVR recordings? This cannot be undone.')) return;
  const deleteBtn = document.getElementById('dvrDeleteAllBtn');
  const statusEl = document.getElementById('dvrStatus');
  const msgEl = document.getElementById('dvrMessage');
  if (deleteBtn) deleteBtn.disabled = true;
  if (msgEl){
    msgEl.style.display = 'none';
    msgEl.textContent = '';
    msgEl.classList.remove('ok','err');
  }
  if (statusEl) statusEl.textContent = 'deleting…';
  let finalMsg = '';
  let finalClass = '';
  try{
    const res = await postExec({path:'/sys/dvr/delete_all', args:[]}, CMD_TIMEOUT_MS, 'dvr');
    const ok = (res && typeof res.rc === 'number') ? res.rc === 0 : true;
    const stdout = (res?.stdout || '').trim();
    const stderr = (res?.stderr || '').trim();
    finalMsg = ok ? stdout : (stderr || stdout || 'failed to delete recordings');
    finalClass = ok ? 'ok' : 'err';
  }catch(e){
    finalMsg = e?.message || 'failed to delete recordings';
    finalClass = 'err';
  }
  await refreshDvrList();
  if (deleteBtn) deleteBtn.disabled = false;
  if (msgEl && finalMsg){
    msgEl.textContent = finalMsg;
    msgEl.classList.add(finalClass);
    msgEl.style.display = 'block';
  }
}

function ensureDvrUI(hasExec){
  dvrUI.hasExec = !!hasExec;
  const refreshBtn = document.getElementById('dvrRefreshBtn');
  const deleteBtn = document.getElementById('dvrDeleteAllBtn');
  if (!refreshBtn || !deleteBtn) return;
  if (!dvrUI.initialized){
    refreshBtn.addEventListener('click', refreshDvrList);
    deleteBtn.addEventListener('click', deleteAllDvrRecordings);
    dvrUI.initialized = true;
  }
  deleteBtn.disabled = !dvrUI.hasExec;
  deleteBtn.title = dvrUI.hasExec ? '' : 'Requires exec capability';
  refreshDvrList();
}

function buildLinkButtonsFromHelp(help){
  const names = new Set((help?.commands||[]).map(c=>c.name));
  const cmds = $('#linkCmds'); cmds.innerHTML='';
  const mk = (label, path)=> {
    const b = document.createElement('button'); b.textContent = label;
    b.addEventListener('click', async ()=>{
      try{
        const res = await postExec({path, args:[]}, CMD_TIMEOUT_MS, 'link');
        const ok = (res && typeof res.rc === 'number') ? res.rc===0 : true;
        const gridChild = $('#linkGrid')?.firstElementChild;
        if (gridChild) flashCtl(gridChild, ok);
      }catch{
        const gridChild = $('#linkGrid')?.firstElementChild;
        if (gridChild) flashCtl(gridChild, false);
      }
    });
    return b;
  };
  if (names.has('mode'))   cmds.appendChild(mk('Mode',   '/sys/link/mode'));
  if (names.has('start'))  cmds.appendChild(mk('Start',  '/sys/link/start'));
  if (names.has('stop'))   cmds.appendChild(mk('Stop',   '/sys/link/stop'));
  if (names.has('status')) cmds.appendChild(mk('Status', '/sys/link/status'));
}

function buildLinkModeSelector(help){
  const selectCmd = (help?.commands||[]).find(c=>c.name==='select');
  const arg0 = selectCmd?.args?.[0] || {};
  const opts = arg0?.control?.options || ['udp_relay','pixelpilot','none'];
  const allowFree = !!arg0?.control?.allow_free;

  const grid = $('#linkGrid'); grid.innerHTML='';
  const box = document.createElement('div'); box.className='ctl';
  const lbl = document.createElement('div'); lbl.className='lbl';
  const name = document.createElement('div'); name.className='name'; name.textContent='mode';
  const val = document.createElement('div'); val.className='val'; val.textContent='—';
  lbl.append(name,val);

  const holder = document.createElement('div');
  const sel = document.createElement('select');
  for (const o of opts){ const op=document.createElement('option'); op.value=String(o); op.textContent=String(o); sel.appendChild(op); }
  let freeWrap=null, freeInput=null;
  if (allowFree){
    const opFree=document.createElement('option'); opFree.value="__free__"; opFree.textContent="Input value…"; sel.appendChild(opFree);
    freeWrap = document.createElement('div'); freeWrap.className='freebox';
    freeInput = document.createElement('input'); freeInput.type='text'; freeInput.placeholder='Enter value…';
    freeWrap.appendChild(freeInput);
  }
  sel.addEventListener('change', ()=>{
    if (allowFree && sel.value==="__free__"){ if (freeWrap) freeWrap.style.display='block'; val.textContent = freeInput?.value || ''; }
    else { if (allowFree && freeWrap) freeWrap.style.display='none'; val.textContent = sel.value; }
  });
  if (allowFree && freeInput) freeInput.addEventListener('input', ()=>{ val.textContent = freeInput.value; });

  const err = document.createElement('div'); err.className='errtxt'; err.style.display='none';
  const getCur = ()=> (allowFree && sel.value==="__free__" ? (freeInput?.value ?? '') : sel.value);

  const applyBtn = document.createElement('button'); applyBtn.textContent='Apply mode';
  applyBtn.addEventListener('click', async ()=>{
    err.style.display='none';
    val.textContent = getCur();
    try{
      const res = await postExec({ path:'/sys/link/select', args:[ getCur() ] }, CMD_TIMEOUT_MS, 'link');
      const ok = (res && typeof res.rc === 'number') ? res.rc===0 : true;
      flashCtl(box, ok);
    }catch(e){
      flashCtl(box, false);
      err.textContent = `select failed: ${e.message}`; err.style.display='block';
    }
  });

  const statusBtn = document.createElement('button'); statusBtn.textContent='Status';
  statusBtn.addEventListener('click', async ()=>{ try{ await postExec({path:'/sys/link/status', args:[]}, CMD_TIMEOUT_MS, 'link'); }catch{} });

  const desc = document.createElement('div'); desc.className='desc'; desc.textContent='Routes the active downlink between pixelpilot, udp_relay, or none';

  holder.append(sel);
  if (allowFree) holder.append(freeWrap);
  box.append(lbl, holder, applyBtn, statusBtn, desc, err);
  grid.appendChild(box);

  // seed with current mode if available
  (async ()=>{
    try{
      const res = await postExec({path:'/sys/link/mode', args:[]}, CMD_TIMEOUT_MS, 'link');
      const stdout = String(res.stdout ?? '').trim();
      if (!stdout) return;
      let mode = stdout;
      const match = /([A-Za-z0-9_\-]+)/.exec(stdout);
      if (match) mode = match[1];
      val.textContent = mode;
      let matched = false;
      for (const opt of sel.options){
        if (opt.value === mode){ sel.value = mode; matched = true; break; }
      }
      if (!matched && allowFree){
        sel.value = "__free__";
        if (freeWrap) freeWrap.style.display='block';
        if (freeInput) freeInput.value = mode;
      }
    }catch{}
  })();
}

async function ensureLinkUI(){
  if (!linkUI.help){
    const helpRes = await postExec({path:'/sys/link/help', args:[]}, 400, 'link');
    let helpJson = null;
    try { helpJson = JSON.parse(helpRes.stdout || '{}'); } catch {}
    linkUI.help = helpJson || {commands:[]};
    buildLinkButtonsFromHelp(linkUI.help);
    buildLinkModeSelector(linkUI.help);
  }
  $('#linkStats').textContent = `ready • ${new Date().toLocaleTimeString()}`;
}

async function loadCaps(){
  $('#subtitle').textContent = 'loading caps…';
  try{
    const r = await fetch('/caps', {cache:'no-store'});
    const caps = await r.json();
    $('#dev_device').textContent  = caps.device || '—';
    $('#dev_role').textContent    = caps.role || '—';
    $('#dev_version').textContent = caps.version || '—';
    if (Array.isArray(caps.ifaddrs) && caps.ifaddrs.length){
      $('#dev_if').textContent = caps.ifaddrs.map(i => `${i.if}:${i.ip}`).join('  ');
    } else $('#dev_if').textContent = '—';
    $('#dev_uptime').textContent = caps.uptime_s ? secsToHhMmSs(caps.uptime_s) : '—';
    if (Array.isArray(caps.loadavg)) $('#dev_load').textContent = caps.loadavg.join(' ');
    else $('#dev_load').textContent = '—';
    const capsEl = $('#dev_caps'); capsEl.innerHTML = '';
    const chip = joinCaps(caps.caps);
    if (chip === '—') capsEl.textContent = '—'; else capsEl.appendChild(chip);
    const sseEl = $('#dev_sse'); sseEl.innerHTML = '';
    if (Array.isArray(caps.sse) && caps.sse.length){
      sseEl.innerHTML = caps.sse.map(e => `<a href="${e.url}" target="_blank" rel="noreferrer">${e.name||e.url}</a>`).join('  ');
    } else sseEl.textContent = '—';
    $('#subtitle').textContent = `${caps.device||'device'} ${caps.version?('v'+caps.version):''}`;

    const capList = Array.isArray(caps.caps) ? caps.caps : [];
    const hasExec = capList.includes('exec');
    const hasPixelpilotMiniRk = capList.includes('pixelpilot_mini_rk');

    const deviceCard = document.getElementById('capsCard');
    if (deviceCard){
      deviceCard.style.display = capList.includes('device') ? '' : 'none';
    }

    const deviceActionsRow = document.getElementById('deviceRuntimeActions');
    if (deviceActionsRow){
      deviceActionsRow.style.display = hasPixelpilotMiniRk ? '' : 'none';
    }

    const nodesCard = document.getElementById('nodesCard');
    const nodesEnabled = capList.includes('nodes');
    nodesUI.enabled = nodesEnabled;
    if (nodesCard){
      if (nodesEnabled){
        nodesCard.style.display = '';
        fetchNodes();
      } else {
        nodesCard.style.display = 'none';
        $('#nodesStats').textContent = 'cap missing';
        $('#nodesNotice').textContent = 'cap missing';
        $('#nodesProgress').style.width = '0%';
        $('#nodesGrid').innerHTML = '';
        $('#nodesScanBtn').disabled = true;
        nodesUI.entries.clear();
        nodesUI.expanded.clear();
        if (nodesPollTimer){
          clearInterval(nodesPollTimer);
          nodesPollTimer = null;
        }
      }
    }

    if (capList.includes('pixelpilot')){
      $('#pixelpilotCard').style.display = '';
      await pixelpilotManager.ensureUI();
    } else {
      $('#pixelpilotCard').style.display = 'none';
      $('#pixelpilotStats').textContent = 'cap missing';
    }

    if (capList.includes('udp_relay')){
      $('#udpRelayCard').style.display = '';
      ensureUdpRelayEmbed();
      await udpRelayManager.ensureUI();
    } else {
      $('#udpRelayCard').style.display = 'none';
      $('#udpRelayStats').textContent = 'cap missing';
    }

    if (capList.includes('udp_sender')){
      $('#udpSenderCard').style.display = '';
      ensureUdpSenderUI();
    } else {
      $('#udpSenderCard').style.display = 'none';
      const respEl = document.getElementById('udpSenderResponse');
      if (respEl) respEl.value = 'cap missing';
    }

    if (hasPixelpilotMiniRk){
      $('#pixelpilotMiniRkCard').style.display = '';
      ensurePixelpilotMiniRkUI();
      const statusEl = document.getElementById('pixelpilotMiniRkStatus');
      if (statusEl && statusEl.textContent === 'cap missing') setMiniRkStatusIdle('Idle');
    } else {
      $('#pixelpilotMiniRkCard').style.display = 'none';
      setMiniRkStatusIdle('cap missing');
    }

    if (capList.includes('link')){
      $('#linkCard').style.display = '';
      await ensureLinkUI();
    } else {
      $('#linkCard').style.display = 'none';
      $('#linkStats').textContent = 'cap missing';
    }

    if (capList.includes('dvr')){
      $('#dvrCard').style.display = '';
      ensureDvrUI(hasExec);
    } else {
      $('#dvrCard').style.display = 'none';
      const statusEl = document.getElementById('dvrStatus');
      const listEl = document.getElementById('dvrList');
      const emptyEl = document.getElementById('dvrEmptyState');
      const msgEl = document.getElementById('dvrMessage');
      if (statusEl) statusEl.textContent = 'cap missing';
      if (listEl) listEl.innerHTML = '';
      if (emptyEl) emptyEl.style.display = 'none';
      if (msgEl){
        msgEl.style.display = 'none';
        msgEl.textContent = '';
        msgEl.classList.remove('ok','err');
      }
    }

    const execCard = document.getElementById('execCard');
    if (execCard){
      execCard.style.display = hasExec ? '' : 'none';
    }

    const remoteExecCard = document.getElementById('remoteExecCard');
    if (remoteExecCard){
      remoteExecCard.style.display = hasExec ? '' : 'none';
    }

  }catch(e){
    $('#subtitle').textContent = 'failed to load /caps';
  }
}

$('#exec_btn').addEventListener('click', doExec);
$('#refreshCaps').addEventListener('click', loadCaps);
$('#exec_args').addEventListener('keydown',e=>{ if(e.key==='Enter') doExec(); });
$('#nodesScanBtn').addEventListener('click', triggerNodesScan);
$('#pixelpilotRefreshBtn').addEventListener('click', ()=> pixelpilotManager.refreshValues());
$('#udpRelayRefreshBtn').addEventListener('click', ()=> udpRelayManager.refreshValues());
$('#udpRelayReloadEmbedBtn').addEventListener('click', reloadUdpRelayEmbed);

const remoteExecTargetInput = $('#remoteExec_targetInput');
if (remoteExecTargetInput){
  if (!remoteExecTargetInput.value){
    remoteExecTargetInput.value = DEFAULT_REMOTE_EXEC_TARGET;
  }
  remoteExecTargetInput.addEventListener('input', updateRemoteExecTargetDisplay);
  remoteExecTargetInput.addEventListener('change', updateRemoteExecTargetDisplay);
  remoteExecTargetInput.addEventListener('keydown', e=>{ if(e.key==='Enter') doRemoteExec(); });
}
updateRemoteExecTargetDisplay();
const remoteExecBtn = $('#remoteExec_btn');
if (remoteExecBtn){
  remoteExecBtn.addEventListener('click', doRemoteExec);
}
const remoteExecArgs = $('#remoteExec_args');
if (remoteExecArgs){
  remoteExecArgs.addEventListener('keydown', e=>{ if(e.key==='Enter') doRemoteExec(); });
}

loadCaps();
fetchNodes();
</script>
